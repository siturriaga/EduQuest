<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="theme-color" content="#000000">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="CIVITAS">
  <link rel="manifest" href="manifest.json">
  <title>CIVITAS ULTIMATE - Educational Platform</title>
  <style>
    /* ========== CSS RESET & BASE ========== */
    * { box-sizing: border-box; margin: 0; padding: 0; -webkit-tap-highlight-color: transparent; }
    
    html, body { 
      background: #000; 
      overflow: hidden; 
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      touch-action: none;
      -webkit-touch-callout: none;
      -webkit-user-select: none;
      user-select: none;
      position: fixed;
      width: 100%;
      height: 100%;
      overscroll-behavior: none;
    }
    
    /* ========== GAME CANVAS ========== */
    canvas#c {
      display: block;
      background: #000;
      position: absolute;
      z-index: 1;
      transform: translateZ(0);
      will-change: transform;
    }
    
    /* ========== MOBILE TOUCH CONTROLS ========== */
    #touch-controls {
      display: none;
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      z-index: 500;
      pointer-events: none;
    }
    #touch-controls.active { display: block; }
    
    /* Joystick Zone - Left Side - FIXED POSITION */
    #joystick-zone {
      position: fixed;
      left: 0; 
      bottom: 0;
      width: 45%;
      height: 50%;
      pointer-events: auto;
      z-index: 500;
    }
    
    #joystick-base {
      position: absolute;
      left: 12px;
      bottom: 12px;
      width: 100px;
      height: 100px;
      background: rgba(255,255,255,0.15);
      border: 3px solid rgba(255,255,255,0.3);
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    #joystick-thumb {
      width: 44px;
      height: 44px;
      background: radial-gradient(circle, rgba(99,102,241,1) 0%, rgba(99,102,241,0.7) 100%);
      border: 2px solid rgba(255,255,255,0.7);
      border-radius: 50%;
    }
    
    /* Action Buttons - Right Side - FIXED PIXEL POSITIONING */
    #action-buttons {
      position: fixed;
      right: 8px;
      bottom: 8px;
      width: 200px;
      height: 220px;
      pointer-events: auto;
      z-index: 500;
    }
    
    .action-btn {
      position: absolute;
      width: 58px;
      height: 58px;
      border-radius: 50%;
      border: 3px solid rgba(255,255,255,0.5);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      font-size: 18px;
      color: #fff;
      cursor: pointer;
      transform: translateZ(0);
      -webkit-transform: translateZ(0);
    }
    
    .action-btn:active, .action-btn.pressed {
      transform: scale(0.85) translateZ(0);
      -webkit-transform: scale(0.85) translateZ(0);
      opacity: 0.8;
    }
    
    .action-btn span { 
      pointer-events: none;
      line-height: 1;
    }
    
    .action-btn .btn-label {
      font-size: 8px;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin-top: 2px;
      opacity: 0.9;
    }
    
    /* 2x3 Grid - EXPLICIT POSITIONS - No overlap */
    /* Row 1 (top) */
    #btn-jump { 
      right: 68px; 
      bottom: 148px;
      background: rgba(34, 197, 94, 0.75);
      border-color: #22c55e;
    }
    #btn-special { 
      right: 4px; 
      bottom: 148px;
      background: rgba(168, 85, 247, 0.75);
      border-color: #a855f7;
    }
    /* Row 2 (middle) */
    #btn-dash { 
      right: 68px; 
      bottom: 80px;
      background: rgba(59, 130, 246, 0.75);
      border-color: #3b82f6;
    }
    #btn-attack { 
      right: 4px; 
      bottom: 80px;
      background: rgba(239, 68, 68, 0.75);
      border-color: #ef4444;
    }
    /* Row 3 (bottom) */
    #btn-ranged {
      right: 68px; 
      bottom: 12px;
      background: rgba(6, 182, 212, 0.75);
      border-color: #06b6d4;
    }
    #btn-parry {
      right: 4px; 
      bottom: 12px;
      background: rgba(255, 255, 255, 0.5);
      border-color: #fff;
    }
    
    /* Ultimate button - left of grid */
    #btn-ultimate {
      right: 132px; 
      bottom: 80px;
      width: 52px;
      height: 52px;
      background: rgba(251, 191, 36, 0.75);
      border-color: #fbbf24;
    }
    #btn-ultimate.ready {
      animation: ult-pulse 0.8s infinite;
      background: rgba(251, 191, 36, 1);
    }
    @keyframes ult-pulse {
      0%, 100% { box-shadow: 0 0 8px #fbbf24; transform: scale(1); }
      50% { box-shadow: 0 0 18px #fbbf24; transform: scale(1.06); }
    }
    
    /* Sound toggle button - top left */
    #btn-sound {
      position: fixed;
      top: 10px;
      left: 10px;
      width: 44px;
      height: 44px;
      background: rgba(0,0,0,0.6);
      border: 2px solid rgba(255,255,255,0.3);
      border-radius: 10px;
      color: #fff;
      font-size: 18px;
      display: flex;
      align-items: center;
      justify-content: center;
      pointer-events: auto;
      z-index: 510;
    }
    #btn-sound.muted {
      opacity: 0.5;
      border-color: rgba(239, 68, 68, 0.5);
    }
    
    /* Settings button - top left after sound */
    #btn-settings {
      position: fixed;
      top: 10px;
      left: 60px;
      width: 44px;
      height: 44px;
      background: rgba(0,0,0,0.6);
      border: 2px solid rgba(255,255,255,0.3);
      border-radius: 10px;
      color: #fff;
      font-size: 18px;
      display: flex;
      align-items: center;
      justify-content: center;
      pointer-events: auto;
      z-index: 510;
    }
    
    /* Mobile Settings Overlay */
    #mobile-settings {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.9);
      z-index: 2500;
      display: none;
      align-items: center;
      justify-content: center;
      padding: 20px;
    }
    #mobile-settings.show {
      display: flex;
    }
    .settings-card {
      background: rgba(30,30,50,0.98);
      border: 3px solid #6366f1;
      border-radius: 16px;
      padding: 24px;
      max-width: 350px;
      width: 100%;
    }
    .settings-title {
      font-size: 1.5rem;
      font-weight: 900;
      color: #22d3ee;
      text-align: center;
      margin-bottom: 1rem;
    }
    .settings-options {
      display: flex;
      flex-direction: column;
      gap: 10px;
      margin-bottom: 1rem;
    }
    .settings-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      background: rgba(99,102,241,0.15);
      padding: 12px 16px;
      border-radius: 10px;
      cursor: pointer;
    }
    .settings-item.active {
      background: rgba(34,197,94,0.3);
      border: 1px solid #22c55e;
    }
    .setting-label {
      font-size: 0.95rem;
      color: #fff;
    }
    .setting-toggle {
      font-size: 0.85rem;
      font-weight: 700;
      color: #ef4444;
    }
    .settings-item.active .setting-toggle {
      color: #22c55e;
    }
    .settings-desc {
      font-size: 0.75rem;
      color: #888;
      line-height: 1.5;
      margin-bottom: 1rem;
    }
    .settings-close {
      width: 100%;
      padding: 14px;
      background: linear-gradient(135deg, #6366f1, #22d3ee);
      border: none;
      border-radius: 10px;
      color: #fff;
      font-size: 1.1rem;
      font-weight: 700;
      cursor: pointer;
    }
    
    /* Pause button - Top right corner */
    #btn-pause {
      position: fixed;
      top: 10px;
      right: 10px;
      width: 44px;
      height: 44px;
      background: rgba(0,0,0,0.6);
      border: 2px solid rgba(255,255,255,0.3);
      border-radius: 10px;
      color: #fff;
      font-size: 18px;
      display: flex;
      align-items: center;
      justify-content: center;
      pointer-events: auto;
      z-index: 510;
    }
    
    /* ========== HIDE DESKTOP UI ON MOBILE ========== */
    @media (max-width: 1024px), (hover: none) {
      /* Hide accessibility panel during game */
      body.game-active #a11y-panel { display: none !important; }
      
      /* Hide tier bar - too cluttered */
      body.game-active #tier-bar { display: none !important; }
      
      /* Reposition streak box to top left */
      body.game-active #streak-box { 
        top: 10px !important; 
        right: auto !important;
        left: 10px !important;
        transform: scale(0.8);
        transform-origin: top left;
      }
      
      /* Hide V button - use on-screen ultimate instead */
      body.game-active #v-btn { display: none !important; }
      
      /* Hide keyboard hints */
      body.game-active .keyboard-hints { display: none !important; }
    }
    
    /* ========== PORTRAIT MODE ========== */
    @media (orientation: portrait) and (max-width: 600px) {
      #joystick-base {
        width: 90px;
        height: 90px;
        left: 10px;
        bottom: 10px;
      }
      #joystick-thumb {
        width: 40px;
        height: 40px;
      }
      
      .action-btn {
        width: 52px;
        height: 52px;
        font-size: 18px;
      }
      
      /* Tighter spacing for portrait */
      #btn-jump { right: 60px; bottom: 120px; }
      #btn-special { right: 4px; bottom: 120px; }
      #btn-dash { right: 60px; bottom: 64px; }
      #btn-attack { right: 4px; bottom: 64px; }
      #btn-ranged { right: 60px; bottom: 8px; }
      #btn-parry { right: 4px; bottom: 8px; }
      #btn-ultimate { 
        right: 116px; bottom: 64px;
        width: 46px; height: 46px;
      }
    }
    
    /* ========== LANDSCAPE MODE ========== */
    @media (orientation: landscape) {
      .action-btn {
        width: 50px;
        height: 50px;
        font-size: 16px;
      }
      
      #joystick-base {
        width: 85px;
        height: 85px;
      }
      #joystick-thumb {
        width: 38px;
        height: 38px;
      }
      
      /* 3x2 layout for landscape */
      #btn-jump { right: 108px; bottom: 58px; }
      #btn-dash { right: 54px; bottom: 58px; }
      #btn-attack { right: 0px; bottom: 58px; }
      #btn-special { right: 108px; bottom: 4px; }
      #btn-ranged { right: 54px; bottom: 4px; }
      #btn-parry { right: 0px; bottom: 4px; }
      #btn-ultimate { 
        right: 162px; bottom: 30px;
        width: 44px; height: 44px;
      }
      
      #btn-pause {
        top: 5px;
        right: 5px;
        width: 36px;
        height: 36px;
        font-size: 14px;
      }
    }
    
    /* ========== VERY SMALL PHONES ========== */
    @media (max-width: 360px) {
      .action-btn {
        width: 46px;
        height: 46px;
        font-size: 16px;
      }
      #btn-jump { right: 52px; bottom: 104px; }
      #btn-special { right: 2px; bottom: 104px; }
      #btn-dash { right: 52px; bottom: 54px; }
      #btn-attack { right: 2px; bottom: 54px; }
      #btn-ranged { right: 52px; bottom: 4px; }
      #btn-parry { right: 2px; bottom: 4px; }
      #btn-ultimate { 
        right: 102px; bottom: 54px;
        width: 40px; height: 40px;
      }
      
      #joystick-base {
        width: 80px;
        height: 80px;
      }
      #joystick-thumb {
        width: 35px;
        height: 35px;
      }
    }
    
    /* Menu touch buttons */
    #menu-touch {
      display: none;
      position: fixed;
      bottom: 30px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 600;
      pointer-events: auto;
    }
    #menu-touch.active { display: flex; gap: 15px; }
    
    .menu-touch-btn {
      padding: 14px 28px;
      background: rgba(99, 102, 241, 0.85);
      border: 2px solid #6366f1;
      border-radius: 12px;
      color: #fff;
      font-size: 16px;
      font-weight: bold;
      cursor: pointer;
    }
    .menu-touch-btn:active {
      transform: scale(0.95);
      background: rgba(99, 102, 241, 1);
    }
    
    /* ========== FORCE HIDE DESKTOP UI ON MOBILE ========== */
    /* These must be very aggressive to override inline styles */
    @media (pointer: coarse), (max-width: 1024px) {
      #a11y-panel {
        display: none !important;
        visibility: hidden !important;
        opacity: 0 !important;
      }
      
      #tier-bar {
        display: none !important;
        visibility: hidden !important;
        opacity: 0 !important;
      }
      
      #streak-box {
        display: none !important;
        visibility: hidden !important;
        opacity: 0 !important;
      }
      
      #v-btn {
        display: none !important;
        visibility: hidden !important;
        opacity: 0 !important;
      }
      
      #mindset-msg {
        display: none !important;
      }
      
      #final-alert {
        display: none !important;
      }
    }
    
    /* ========== LOADING SCREEN ========== */
    #loading-screen {
      position: fixed;
      inset: 0;
      background: linear-gradient(135deg, #0a0a1a 0%, #1a1a2e 100%);
      z-index: 9999;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      transition: opacity 0.5s, visibility 0.5s;
    }
    #loading-screen.hidden {
      opacity: 0;
      visibility: hidden;
      pointer-events: none;
    }
    .loading-title {
      font-size: 3rem;
      font-weight: 900;
      background: linear-gradient(135deg, #6366f1, #22d3ee, #f472b6);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      margin-bottom: 2rem;
    }
    .loading-spinner {
      width: 50px;
      height: 50px;
      border: 4px solid rgba(99, 102, 241, 0.3);
      border-top-color: #6366f1;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }
    @keyframes spin {
      to { transform: rotate(360deg); }
    }
    .loading-text {
      margin-top: 1rem;
      color: #888;
      font-size: 0.9rem;
    }
    
    /* ========== TUTORIAL OVERLAY ========== */
    #tutorial-overlay {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.92);
      z-index: 2000;
      display: none;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 20px;
    }
    #tutorial-overlay.show {
      display: flex;
    }
    .tutorial-card {
      background: rgba(30,30,50,0.98);
      border: 3px solid #6366f1;
      border-radius: 16px;
      padding: 24px;
      max-width: 400px;
      width: 100%;
      text-align: center;
    }
    .tutorial-title {
      font-size: 1.5rem;
      font-weight: 900;
      color: #22d3ee;
      margin-bottom: 1rem;
    }
    .tutorial-controls {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 12px;
      margin: 1rem 0;
    }
    .tutorial-item {
      background: rgba(99, 102, 241, 0.15);
      border-radius: 10px;
      padding: 12px 8px;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 4px;
    }
    .tutorial-icon {
      font-size: 1.5rem;
    }
    .tutorial-label {
      font-size: 0.75rem;
      font-weight: 600;
      color: #fff;
    }
    .tutorial-desc {
      font-size: 0.65rem;
      color: #888;
    }
    .tutorial-btn {
      width: 100%;
      padding: 14px;
      background: linear-gradient(135deg, #6366f1, #22d3ee);
      border: none;
      border-radius: 10px;
      color: #fff;
      font-size: 1.1rem;
      font-weight: 700;
      cursor: pointer;
      margin-top: 1rem;
    }
    .tutorial-skip {
      background: none;
      border: none;
      color: #666;
      margin-top: 0.8rem;
      cursor: pointer;
      font-size: 0.85rem;
    }
    
    /* ========== CONNECTION STATUS ========== */
    #connection-status {
      position: fixed;
      top: 10px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0,0,0,0.8);
      padding: 6px 14px;
      border-radius: 20px;
      font-size: 0.75rem;
      font-weight: 600;
      z-index: 600;
      display: none;
      align-items: center;
      gap: 6px;
    }
    #connection-status.show { display: flex; }
    #connection-status.connected { color: #22c55e; }
    #connection-status.connecting { color: #fbbf24; }
    #connection-status.error { color: #ef4444; }
    .status-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: currentColor;
    }
    #connection-status.connecting .status-dot {
      animation: pulse-dot 1s infinite;
    }
    @keyframes pulse-dot {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.3; }
    }
    
    /* ========== MOBILE QUIZ IMPROVEMENTS ========== */
    @media (pointer: coarse), (max-width: 1024px) {
      /* Make quiz answers larger and more tappable */
      .quiz-answer {
        min-height: 54px !important;
        font-size: 15px !important;
        padding: 12px 16px !important;
        margin: 8px 0 !important;
        border-radius: 12px !important;
      }
      
      /* Quiz question text */
      .quiz-question {
        font-size: 17px !important;
        line-height: 1.5 !important;
      }
      
      /* Timer more visible */
      .quiz-timer {
        font-size: 24px !important;
      }
    }
    
    /* SESSION OVERLAY STYLES */
    #session-overlay {
      position: fixed; top: 0; left: 0; right: 0; bottom: 0;
      background: radial-gradient(ellipse at center, #1a1a2e 0%, #0a0a1a 100%);
      z-index: 1000; display: flex; flex-direction: column;
      align-items: center; justify-content: center;
      transition: opacity 0.5s, visibility 0.5s;
      padding: env(safe-area-inset-top, 20px) env(safe-area-inset-right, 20px) env(safe-area-inset-bottom, 20px) env(safe-area-inset-left, 20px);
    }
    #session-overlay.hidden { opacity: 0; visibility: hidden; pointer-events: none; display: none !important; }
    
    .s-title {
      font-family: 'Segoe UI', system-ui, sans-serif;
      font-size: clamp(2rem, 8vw, 3.5rem); font-weight: 900;
      background: linear-gradient(135deg, #6366f1, #22d3ee, #f472b6);
      -webkit-background-clip: text; -webkit-text-fill-color: transparent;
      margin-bottom: 0.5rem; text-align: center;
    }
    .s-sub { color: #888; margin-bottom: 2rem; text-align: center; }
    
    .s-card {
      background: rgba(30,30,50,0.95); border: 2px solid #333; border-radius: 1rem;
      padding: 1.5rem; width: 90%; max-width: 420px;
    }
    .s-card h2 { font-size: 1.2rem; margin-bottom: 1rem; text-align: center; color: #fff; }
    
    .s-btns { display: flex; gap: 1rem; flex-wrap: wrap; justify-content: center; }
    .s-btn {
      display: flex; flex-direction: column; align-items: center;
      padding: 1.2rem 1.5rem; background: #1e1e3a; border: 2px solid #6366f1;
      border-radius: 1rem; cursor: pointer; transition: all 0.3s; min-width: 140px; color: #fff;
      font-family: inherit; font-size: inherit;
      -webkit-tap-highlight-color: rgba(99, 102, 241, 0.3);
      touch-action: manipulation;
    }
    .s-btn:hover, .s-btn:active { transform: translateY(-3px); border-color: #22d3ee; box-shadow: 0 8px 25px rgba(99,102,241,0.3); }
    .s-btn-icon { font-size: 2rem; margin-bottom: 0.3rem; }
    .s-btn-title { font-weight: 700; }
    .s-btn-desc { color: #888; font-size: 0.75rem; margin-top: 0.2rem; }
    
    .s-code-row { display: flex; gap: 0.4rem; justify-content: center; margin: 1rem 0; }
    .s-code-digit {
      width: 42px; height: 50px; background: #0a0a1a; border: 2px solid #333;
      border-radius: 0.4rem; font-size: 1.4rem; font-weight: bold;
      text-align: center; color: #fff;
    }
    .s-code-digit:focus { outline: none; border-color: #6366f1; }
    
    .s-input {
      width: 100%; padding: 0.7rem; background: #0a0a1a;
      border: 2px solid #333; border-radius: 0.4rem; color: #fff;
      font-size: 1rem; margin-bottom: 0.8rem;
    }
    .s-input:focus { outline: none; border-color: #6366f1; }
    
    .s-button {
      width: 100%; padding: 0.8rem; background: linear-gradient(135deg, #6366f1, #4f46e5);
      border: none; border-radius: 0.4rem; color: #fff; font-size: 1rem;
      font-weight: 700; cursor: pointer; transition: all 0.2s;
    }
    .s-button:hover { transform: translateY(-2px); box-shadow: 0 4px 15px rgba(99,102,241,0.4); }
    .s-button:disabled { opacity: 0.5; cursor: not-allowed; transform: none; }
    .s-button.green { background: linear-gradient(135deg, #22c55e, #16a34a); }
    .s-button.ghost { background: transparent; border: 2px solid #333; }
    
    .s-status { text-align: center; padding: 0.4rem; font-size: 0.85rem; min-height: 1.5em; }
    .s-status.err { color: #ef4444; }
    .s-status.ok { color: #22c55e; }
    
    .s-code-display {
      font-size: 2.2rem; font-weight: bold; text-align: center;
      letter-spacing: 0.4rem; color: #6366f1; margin: 0.8rem 0;
      padding: 0.8rem; background: #0a0a1a; border-radius: 0.4rem;
    }
    
    .s-grid {
      display: grid; grid-template-columns: repeat(auto-fill, minmax(70px, 1fr));
      gap: 0.4rem; max-height: 120px; overflow-y: auto; margin: 0.8rem 0;
    }
    .s-tag { background: #1e1e3a; padding: 0.4rem; border-radius: 0.4rem; text-align: center; font-size: 0.75rem; color: #fff; }
    
    .s-link { 
      color: #6366f1; 
      cursor: pointer; 
      margin-top: 0.8rem; 
      display: inline-block; 
      font-size: 0.9rem;
      -webkit-tap-highlight-color: rgba(99, 102, 241, 0.3);
      touch-action: manipulation;
      user-select: none;
      -webkit-user-select: none;
      padding: 0.5rem 1rem;
    }
    .s-link:hover, .s-link:active { text-decoration: underline; }
    
    .s-notice { font-size: 0.7rem; color: #666; text-align: center; margin-top: 0.8rem; padding: 0.4rem; background: rgba(99,102,241,0.1); border-radius: 0.3rem; }
    
    /* P2P Connection Status */
    .p2p-status { 
      padding: 0.5rem 1rem; 
      border-radius: 0.4rem; 
      font-size: 0.85rem; 
      font-weight: 600; 
      margin: 0.5rem 0; 
      display: inline-block;
    }
    .p2p-status.connecting { background: rgba(251, 191, 36, 0.2); color: #fbbf24; }
    .p2p-status.connected { background: rgba(34, 197, 94, 0.2); color: #22c55e; }
    .p2p-status.disconnected { background: rgba(107, 114, 128, 0.2); color: #6b7280; }
    .p2p-status.reconnecting { background: rgba(251, 191, 36, 0.2); color: #fbbf24; animation: s-pulse 1s infinite; }
    .p2p-status.error { background: rgba(239, 68, 68, 0.2); color: #ef4444; }
    
    .s-screen { display: none; flex-direction: column; align-items: center; width: 100%; }
    .s-screen.active { display: flex; }
    
    @keyframes s-pulse { 0%,100% { opacity: 1; } 50% { opacity: 0.5; } }
    
    /* ========== ENHANCED TIER SYSTEM ========== */
    body.dyslexia-font, body.dyslexia-font * { font-family: 'Comic Sans MS', 'OpenDyslexic', cursive !important; letter-spacing: 0.06em; line-height: 1.7; }
    body.high-contrast-mode canvas { filter: contrast(1.25); }
    
    #a11y-panel { position:fixed; top:8px; right:8px; z-index:9999; background:rgba(30,30,50,0.95); border:2px solid #6366f1; border-radius:10px; padding:5px; display:flex; gap:4px; }
    #a11y-panel button { width:32px; height:32px; border-radius:6px; border:2px solid #6366f1; background:transparent; color:#fff; font-size:13px; cursor:pointer; display:flex; align-items:center; justify-content:center; }
    #a11y-panel button:hover, #a11y-panel button.on { background:#6366f1; }
    
    #tier-bar { position:fixed; bottom:12px; left:50%; transform:translateX(-50%); width:500px; max-width:88vw; background:rgba(25,25,45,0.95); border:2px solid #6366f1; border-radius:12px; padding:10px 14px; z-index:100; display:none; }
    #tier-bar.show { display:block; }
    .tier-hdr { display:flex; justify-content:space-between; font-size:11px; margin-bottom:5px; }
    .tier-lbl { color:#22d3ee; font-weight:700; }
    .tier-trk { height:14px; background:#1a1a2e; border-radius:7px; overflow:hidden; }
    .tier-fill { height:100%; background:linear-gradient(90deg,#6366f1,#22d3ee); transition:width 0.4s; border-radius:7px; }
    .tier-dots { display:flex; justify-content:space-between; margin-top:5px; }
    .tier-dot { width:28px; height:28px; border-radius:50%; background:#1a1a2e; border:2px solid #555; display:flex; align-items:center; justify-content:center; font-size:11px; font-weight:700; transition:all 0.3s; }
    .tier-dot.done { border-color:#22c55e; background:#22c55e; color:#000; }
    .tier-dot.now { border-color:#6366f1; box-shadow:0 0 10px #6366f1; transform:scale(1.1); }
    @keyframes tier-pop { 0%{transform:scale(1)} 50%{transform:scale(1.3)} 100%{transform:scale(1)} }
    .tier-dot.pop { animation:tier-pop 0.4s; }
    
    #v-btn { position:fixed; bottom:80px; right:12px; width:65px; height:65px; border-radius:50%; background:linear-gradient(135deg,#ef4444,#dc2626); border:3px solid #fff; color:#fff; font-size:26px; font-weight:900; cursor:pointer; z-index:100; display:none; align-items:center; justify-content:center; box-shadow:0 0 18px rgba(239,68,68,0.5); transition:all 0.2s; }
    #v-btn.show { display:flex; }
    #v-btn:hover { transform:scale(1.08); }
    #v-btn.final { background:linear-gradient(135deg,#fbbf24,#f59e0b); box-shadow:0 0 30px rgba(251,191,36,0.7); animation:vpulse 0.8s infinite; }
    @keyframes vpulse { 0%,100%{transform:scale(1)} 50%{transform:scale(1.08)} }
    #v-btn.cooldown { opacity:0.5; pointer-events:none; }
    
    #final-alert { position:fixed; top:50%; left:50%; transform:translate(-50%,-50%); background:linear-gradient(135deg,#fbbf24,#f59e0b); padding:20px 40px; border-radius:14px; font-size:24px; font-weight:900; color:#000; z-index:1000; display:none; text-align:center; }
    #final-alert.show { display:block; animation:apop 0.4s; }
    @keyframes apop { 0%{transform:translate(-50%,-50%) scale(0)} 50%{transform:translate(-50%,-50%) scale(1.1)} 100%{transform:translate(-50%,-50%) scale(1)} }
    
    #streak-box { position:fixed; top:85px; right:12px; background:rgba(25,25,45,0.95); border:2px solid #f59e0b; border-radius:10px; padding:8px 14px; z-index:100; text-align:center; display:none; }
    #streak-box.show { display:block; }
    #streak-box .num { font-size:26px; font-weight:900; color:#f59e0b; }
    #streak-box .lbl { font-size:9px; color:#888; text-transform:uppercase; }
    #streak-box.fire { animation:firepulse 0.4s infinite; border-color:#ef4444; }
    @keyframes firepulse { 0%,100%{box-shadow:0 0 10px rgba(239,68,68,0.5)} 50%{box-shadow:0 0 22px rgba(239,68,68,0.8)} }
    
    #mindset-msg { position:fixed; top:15%; left:50%; transform:translateX(-50%); background:linear-gradient(135deg,#6366f1,#22d3ee); padding:14px 32px; border-radius:12px; font-size:18px; font-weight:700; color:#fff; z-index:600; display:none; text-align:center; max-width:75%; box-shadow:0 4px 20px rgba(99,102,241,0.5); }
    #mindset-msg.show { display:block; animation:msgin 0.35s; }
    @keyframes msgin { from{transform:translateX(-50%) translateY(-18px);opacity:0} to{transform:translateX(-50%) translateY(0);opacity:1} }
    
    #battle-review { position:fixed; inset:0; background:rgba(0,0,0,0.95); z-index:950; display:none; align-items:center; justify-content:center; padding:20px; overflow-y:auto; }
    #battle-review.show { display:flex; }
    .rev-panel { background:rgba(25,25,45,0.98); border:3px solid #6366f1; border-radius:16px; padding:28px; max-width:750px; width:100%; max-height:90vh; overflow-y:auto; }
    .rev-title { font-size:28px; font-weight:900; text-align:center; margin-bottom:16px; background:linear-gradient(135deg,#6366f1,#22d3ee); -webkit-background-clip:text; -webkit-text-fill-color:transparent; }
    .rev-stats { display:grid; grid-template-columns:repeat(4,1fr); gap:10px; margin-bottom:18px; }
    @media(max-width:500px) { .rev-stats { grid-template-columns:repeat(2,1fr); } }
    .rev-stat { background:#1a1a2e; border-radius:10px; padding:12px; text-align:center; }
    .rev-stat .val { font-size:24px; font-weight:900; color:#6366f1; }
    .rev-stat .lbl { font-size:11px; color:#888; }
    .rev-list { max-height:220px; overflow-y:auto; margin-bottom:12px; }
    .rev-item { background:#1a1a2e; border-radius:8px; padding:10px; margin-bottom:7px; display:flex; align-items:center; gap:10px; font-size:13px; }
    .rev-icon { width:28px; height:28px; border-radius:50%; display:flex; align-items:center; justify-content:center; font-size:14px; flex-shrink:0; }
    .rev-icon.ok { background:#22c55e; }
    .rev-icon.no { background:#ef4444; }
    .rev-btn { width:100%; padding:12px; background:linear-gradient(135deg,#6366f1,#22d3ee); border:none; border-radius:10px; color:#fff; font-size:16px; font-weight:700; cursor:pointer; }
    
    .quiz-tts { position:absolute; top:90px; right:130px; background:#22d3ee; border:none; border-radius:50%; width:38px; height:38px; font-size:18px; cursor:pointer; z-index:10; }
    .quiz-tts:hover { transform:scale(1.1); }
  </style>
</head>
<body>

<!-- LOADING SCREEN -->
<div id="loading-screen">
  <div class="loading-title">CIVITAS</div>
  <div class="loading-spinner"></div>
  <div class="loading-text">Loading game...</div>
</div>

<!-- TUTORIAL OVERLAY -->
<div id="tutorial-overlay">
  <div class="tutorial-card">
    <div class="tutorial-title">üéÆ CONTROLS</div>
    <div class="tutorial-controls">
      <div class="tutorial-item">
        <span class="tutorial-icon">üïπÔ∏è</span>
        <span class="tutorial-label">JOYSTICK</span>
        <span class="tutorial-desc">Move left/right</span>
      </div>
      <div class="tutorial-item">
        <span class="tutorial-icon">‚¨ÜÔ∏è</span>
        <span class="tutorial-label">JUMP</span>
        <span class="tutorial-desc">Triple jump!</span>
      </div>
      <div class="tutorial-item">
        <span class="tutorial-icon">‚öîÔ∏è</span>
        <span class="tutorial-label">ATTACK</span>
        <span class="tutorial-desc">Melee strike</span>
      </div>
      <div class="tutorial-item">
        <span class="tutorial-icon">üéØ</span>
        <span class="tutorial-label">RANGED</span>
        <span class="tutorial-desc">Shoot projectile</span>
      </div>
      <div class="tutorial-item">
        <span class="tutorial-icon">üí®</span>
        <span class="tutorial-label">DASH</span>
        <span class="tutorial-desc">Invincible dodge</span>
      </div>
      <div class="tutorial-item">
        <span class="tutorial-icon">üõ°Ô∏è</span>
        <span class="tutorial-label">PARRY</span>
        <span class="tutorial-desc">Block & counter</span>
      </div>
      <div class="tutorial-item">
        <span class="tutorial-icon">‚ú®</span>
        <span class="tutorial-label">SPECIAL</span>
        <span class="tutorial-desc">Unique ability</span>
      </div>
      <div class="tutorial-item">
        <span class="tutorial-icon">üí•</span>
        <span class="tutorial-label">ULTIMATE</span>
        <span class="tutorial-desc">When charged</span>
      </div>
    </div>
    <p style="color:#888;font-size:0.8rem;margin-bottom:0.5rem;">Answer questions correctly to power up!</p>
    <button class="tutorial-btn" id="tutorial-start">LET'S GO!</button>
    <button class="tutorial-skip" id="tutorial-skip">Don't show again</button>
  </div>
</div>

<!-- CONNECTION STATUS -->
<div id="connection-status">
  <span class="status-dot"></span>
  <span id="connection-text">Connected</span>
</div>

<!-- ========== ENHANCED FEATURES UI ========== -->
<div id="a11y-panel">
  <button id="a11y-tts" title="Text-to-Speech">üîä</button>
  <button id="a11y-dys" title="Dyslexia Font">Aa</button>
  <button id="a11y-contrast" title="High Contrast">‚óê</button>
  <button id="a11y-time" title="Extended Time">‚è±</button>
</div>

<div id="tier-bar">
  <div class="tier-hdr"><span class="tier-lbl">REWARD TIER</span><span id="tier-txt">0/5</span></div>
  <div class="tier-trk"><div class="tier-fill" id="tier-fill"></div></div>
  <div class="tier-dots" id="tier-dots">
    <div class="tier-dot">1</div><div class="tier-dot">2</div><div class="tier-dot">3</div><div class="tier-dot">4</div><div class="tier-dot">‚≠ê</div>
  </div>
</div>

<button id="v-btn">V</button>

<div id="streak-box"><div class="num" id="streak-num">0</div><div class="lbl">üî• STREAK</div></div>

<div id="mindset-msg"></div>

<div id="final-alert">‚ö° FINAL ATTACK UNLOCKED! ‚ö°<br><span style="font-size:14px">Press V for devastating damage!</span></div>

<div id="battle-review">
  <div class="rev-panel">
    <div class="rev-title">üìä BATTLE REVIEW</div>
    <div class="rev-stats" id="rev-stats"></div>
    <h4 style="margin-bottom:8px;color:#22d3ee;font-size:14px;">Question Summary</h4>
    <div class="rev-list" id="rev-list"></div>
    <button class="rev-btn" id="rev-btn">Continue</button>
  </div>
</div>

<!-- SESSION MANAGEMENT OVERLAY -->
<div id="session-overlay">
  
  <!-- Entry -->
  <div id="scr-entry" class="s-screen active">
    <h1 class="s-title">CIVITAS ULTIMATE</h1>
    <p class="s-sub">Florida 7th Grade Civics ‚Ä¢ Educational Platform</p>
    <div class="s-btns">
      <button type="button" class="s-btn" id="btn-teacher-mode">
        <span class="s-btn-icon">üë®‚Äçüè´</span>
        <span class="s-btn-title">TEACHER</span>
        <span class="s-btn-desc">Create session</span>
      </button>
      <button type="button" class="s-btn" id="btn-student-mode">
        <span class="s-btn-icon">üéì</span>
        <span class="s-btn-title">STUDENT</span>
        <span class="s-btn-desc">Join with code</span>
      </button>
    </div>
    <p style="margin-top:1.5rem;color:#666;font-size:0.8rem;">
      <button type="button" class="s-link" id="btn-play-solo" style="background:none;border:none;font-family:inherit;">Play solo without session ‚Üí</button>
    </p>
  </div>
  
  <!-- Teacher Login -->
  <div id="scr-teacher" class="s-screen">
    <div class="s-card">
      <h2>üë®‚Äçüè´ Teacher Login</h2>
      <button class="s-button" id="btn-google-login">Sign in with Google</button>
      <p style="margin-top:0.8rem;color:#666;font-size:0.75rem;text-align:center;">
        Authorized: @dadeschools.net
      </p>
      <button type="button" class="s-link" id="btn-back-from-teacher" style="background:none;border:none;font-family:inherit;">‚Üê Back</button>
    </div>
  </div>
  
  <!-- Teacher Dashboard -->
  <div id="scr-dashboard" class="s-screen">
    <div class="s-card" style="max-width:550px;max-height:90vh;overflow-y:auto;">
      <h2>üìã Teacher Dashboard</h2>
      
      <!-- Tab buttons -->
      <div style="display:flex;gap:0.3rem;margin-bottom:1rem;flex-wrap:wrap;">
        <button class="s-button ghost" style="flex:1;padding:0.5rem;min-width:70px;" onclick="showDashTab('setup')" id="tab-setup">Setup</button>
        <button class="s-button ghost" style="flex:1;padding:0.5rem;min-width:70px;" onclick="showDashTab('session')" id="tab-session">Session</button>
        <button class="s-button ghost" style="flex:1;padding:0.5rem;min-width:70px;" onclick="showDashTab('questions')" id="tab-questions">Questions</button>
        <button class="s-button ghost" style="flex:1;padding:0.5rem;min-width:70px;" onclick="showDashTab('reports')" id="tab-reports">Reports</button>
      </div>
      
      <!-- SETUP Tab (NEW) -->
      <div id="dash-setup">
        <p style="font-weight:bold;margin-bottom:0.8rem;color:#fbbf24;">‚öôÔ∏è Game Setup</p>
        
        <!-- Game Mode Selection -->
        <div style="background:#1a1a2e;padding:0.8rem;border-radius:0.5rem;margin-bottom:0.8rem;">
          <p style="font-weight:bold;margin-bottom:0.5rem;">üéÆ Game Mode</p>
          <div style="display:flex;flex-direction:column;gap:0.4rem;">
            <label style="display:flex;align-items:center;gap:0.5rem;cursor:pointer;padding:0.4rem;background:#252545;border-radius:0.3rem;">
              <input type="radio" name="game-mode" value="solo" checked style="accent-color:#6366f1;">
              <span>üéØ Solo Only</span>
              <span style="font-size:0.7rem;color:#888;margin-left:auto;">Individual boss battles</span>
            </label>
            <label style="display:flex;align-items:center;gap:0.5rem;cursor:pointer;padding:0.4rem;background:#252545;border-radius:0.3rem;">
              <input type="radio" name="game-mode" value="raid" style="accent-color:#6366f1;">
              <span>üë• Raid Only</span>
              <span style="font-size:0.7rem;color:#888;margin-left:auto;">Class boss (Kahoot-style)</span>
            </label>
            <label style="display:flex;align-items:center;gap:0.5rem;cursor:pointer;padding:0.4rem;background:#252545;border-radius:0.3rem;">
              <input type="radio" name="game-mode" value="both" style="accent-color:#6366f1;">
              <span>‚öîÔ∏è Solo ‚Üí Raid</span>
              <span style="font-size:0.7rem;color:#888;margin-left:auto;">Both phases</span>
            </label>
          </div>
        </div>
        
        <!-- Question Count -->
        <div style="background:#1a1a2e;padding:0.8rem;border-radius:0.5rem;margin-bottom:0.8rem;">
          <p style="font-weight:bold;margin-bottom:0.5rem;">üìù Question Count</p>
          <div style="display:flex;gap:0.5rem;align-items:center;">
            <input type="range" id="question-count" min="5" max="50" value="15" 
                   style="flex:1;accent-color:#6366f1;" oninput="updateQuestionCount()">
            <span id="question-count-display" style="background:#252545;padding:0.3rem 0.6rem;border-radius:0.3rem;min-width:40px;text-align:center;">15</span>
          </div>
          <p style="font-size:0.7rem;color:#888;margin-top:0.3rem;">Questions per phase (solo + raid)</p>
        </div>
        
        <!-- Standards Selection -->
        <div style="background:#1a1a2e;padding:0.8rem;border-radius:0.5rem;margin-bottom:0.8rem;">
          <p style="font-weight:bold;margin-bottom:0.5rem;">üìö Standards Selection</p>
          <div id="standards-grid" style="display:grid;grid-template-columns:repeat(2,1fr);gap:0.3rem;max-height:180px;overflow-y:auto;">
            <!-- Will be populated by JS -->
          </div>
          <div style="display:flex;gap:0.3rem;margin-top:0.5rem;">
            <button class="s-button ghost" onclick="selectAllStandards()" style="flex:1;padding:0.3rem;font-size:0.75rem;">Select All</button>
            <button class="s-button ghost" onclick="deselectAllStandards()" style="flex:1;padding:0.3rem;font-size:0.75rem;">Deselect All</button>
          </div>
        </div>
        
        <!-- Raid Settings (conditional) -->
        <div id="raid-settings" style="background:#1a1a2e;padding:0.8rem;border-radius:0.5rem;margin-bottom:0.8rem;">
          <p style="font-weight:bold;margin-bottom:0.5rem;">üêâ Raid Boss Settings</p>
          <select id="raid-boss" class="s-input" style="padding:0.4rem;margin-bottom:0.4rem;">
            <option value="WORLD_SERPENT">üêç World Serpent (Epic)</option>
            <option value="TITAN_COLOSSUS">üóø Titan Colossus (Hard)</option>
            <option value="STORM_DRAGON">üå©Ô∏è Storm Dragon (Medium)</option>
          </select>
          <div style="display:flex;gap:0.5rem;align-items:center;margin-top:0.4rem;">
            <span style="font-size:0.85rem;">Question Timer:</span>
            <select id="raid-timer" class="s-input" style="padding:0.3rem;flex:1;">
              <option value="20">20 seconds</option>
              <option value="30" selected>30 seconds</option>
              <option value="45">45 seconds</option>
              <option value="60">60 seconds</option>
            </select>
          </div>
        </div>
        
        <button class="s-button green" onclick="saveGameSetup()" style="width:100%;">‚úì Save Setup & Continue</button>
      </div>
      
      <!-- Session Tab -->
      <div id="dash-session" style="display:none;">
        <p style="text-align:center;color:#888;font-size:0.85rem;">Share this code:</p>
        <div class="s-code-display" id="t-code">------</div>
        <button class="s-button" onclick="sCopyLink()">üìã Copy Student Link</button>
        
        <!-- Session Info -->
        <div style="background:#1a1a2e;padding:0.6rem;border-radius:0.5rem;margin-top:0.8rem;margin-bottom:0.8rem;">
          <p style="font-size:0.8rem;color:#888;">Mode: <span id="session-mode-display" style="color:#6366f1;">Solo Only</span></p>
          <p style="font-size:0.8rem;color:#888;">Questions: <span id="session-questions-display" style="color:#6366f1;">15</span></p>
          <p style="font-size:0.8rem;color:#888;">Standards: <span id="session-standards-display" style="color:#6366f1;">All</span></p>
        </div>
        
        <div style="margin-top:0.5rem;">
          <p style="color:#888;font-size:0.85rem;">Students: <span id="t-count">0</span>/50</p>
          <div class="s-grid" id="t-list"><p style="color:#555;grid-column:1/-1;text-align:center;font-size:0.8rem;">Waiting for students...</p></div>
        </div>
        
        <button class="s-button green" onclick="sTeacherStart()" style="margin-top:0.8rem;width:100%;">‚ñ∂Ô∏è START GAME</button>
        <div style="display:flex;gap:0.4rem;margin-top:0.4rem;">
          <button class="s-button ghost" onclick="sAddTest()" style="flex:1;">+ Test Student</button>
          <button class="s-button ghost" onclick="teacherJoinGame()" style="flex:1;">üëÅÔ∏è Join as Viewer</button>
        </div>
      </div>
      
      <!-- Questions Tab -->
      <div id="dash-questions" style="display:none;">
        <p style="color:#888;font-size:0.85rem;margin-bottom:0.8rem;">Questions loaded: <span id="q-count">40</span> (Demo) + <span id="q-custom">0</span> (Custom)</p>
        <p style="color:#22d3ee;font-size:0.75rem;margin-bottom:0.8rem;">‚è±Ô∏è Questions appear every 30 seconds during gameplay</p>
        
        <!-- Upload Section -->
        <div style="background:#1a1a2e;padding:0.8rem;border-radius:0.5rem;margin-bottom:0.8rem;">
          <p style="font-weight:bold;margin-bottom:0.5rem;">üì§ Upload Questions</p>
          <input type="file" id="file-upload" name="file-upload" accept=".csv,.json,.pdf" style="display:none;" onchange="handleFileUpload(event)">
          <button class="s-button ghost" onclick="document.getElementById('file-upload').click()" style="padding:0.5rem;width:100%;">Choose CSV, JSON, or PDF File</button>
          <p style="font-size:0.7rem;color:#666;margin-top:0.3rem;">CSV: level,standard,question,answer1,answer2,answer3,answer4</p>
          <p style="font-size:0.7rem;color:#666;">PDF: Questions extracted automatically</p>
          <p style="font-size:0.7rem;color:#22c55e;margin-top:0.2rem;">‚úì Syncs to all connected students</p>
        </div>
        
        <!-- Question Preview Area -->
        <div id="question-preview" style="background:#0a0a1a;padding:0.8rem;border-radius:0.5rem;margin-bottom:0.8rem;max-height:150px;overflow-y:auto;display:none;">
          <!-- Populated by showQuestionPreview() -->
        </div>
        
        <!-- Manual Entry -->
        <div style="background:#1a1a2e;padding:0.8rem;border-radius:0.5rem;">
          <p style="font-weight:bold;margin-bottom:0.5rem;">‚úèÔ∏è Add Question Manually</p>
          <select id="manual-level" class="s-input" style="margin-bottom:0.4rem;padding:0.4rem;">
            <option value="1">Level 1 - Basic</option>
            <option value="2" selected>Level 2 - Comprehension</option>
            <option value="3">Level 3 - Application</option>
            <option value="4">Level 4 - Analysis</option>
          </select>
          <input type="text" id="manual-standard" name="manual-standard" class="s-input" placeholder="Standard (e.g. SS.7.CL.1.1)" style="padding:0.4rem;margin-bottom:0.4rem;">
          <input type="text" id="manual-q" name="manual-q" class="s-input" placeholder="Question text" style="padding:0.4rem;margin-bottom:0.4rem;">
          <input type="text" id="manual-a1" name="manual-a1" class="s-input" placeholder="‚úì Correct answer" style="padding:0.4rem;margin-bottom:0.3rem;border-color:#22c55e;">
          <input type="text" id="manual-a2" name="manual-a2" class="s-input" placeholder="Wrong answer 2" style="padding:0.4rem;margin-bottom:0.3rem;">
          <input type="text" id="manual-a3" name="manual-a3" class="s-input" placeholder="Wrong answer 3" style="padding:0.4rem;margin-bottom:0.3rem;">
          <input type="text" id="manual-a4" name="manual-a4" class="s-input" placeholder="Wrong answer 4" style="padding:0.4rem;margin-bottom:0.5rem;">
          <button class="s-button" onclick="addManualQuestion()" style="padding:0.5rem;width:100%;">+ Add Question</button>
        </div>
        
        <button class="s-button ghost" onclick="clearCustomQuestions()" style="margin-top:0.5rem;padding:0.4rem;color:#ef4444;">Clear Custom Questions</button>
      </div>
      
      <!-- Reports Tab -->
      <div id="dash-reports" style="display:none;">
        <p style="color:#888;font-size:0.85rem;margin-bottom:0.8rem;">Session Reports</p>
        
        <!-- Live Stats -->
        <div style="display:grid;grid-template-columns:repeat(3,1fr);gap:0.4rem;margin-bottom:0.8rem;">
          <div style="background:#1a1a2e;padding:0.5rem;border-radius:0.3rem;text-align:center;">
            <p style="font-size:1.2rem;font-weight:bold;color:#22c55e;" id="stat-accuracy">0%</p>
            <p style="font-size:0.7rem;color:#888;">Accuracy</p>
          </div>
          <div style="background:#1a1a2e;padding:0.5rem;border-radius:0.3rem;text-align:center;">
            <p style="font-size:1.2rem;font-weight:bold;color:#6366f1;" id="stat-answered">0</p>
            <p style="font-size:0.7rem;color:#888;">Answered</p>
          </div>
          <div style="background:#1a1a2e;padding:0.5rem;border-radius:0.3rem;text-align:center;">
            <p style="font-size:1.2rem;font-weight:bold;color:#fbbf24;" id="stat-avg-time">0s</p>
            <p style="font-size:0.7rem;color:#888;">Avg Time</p>
          </div>
        </div>
        
        <div id="reports-content" style="background:#1a1a2e;padding:0.8rem;border-radius:0.5rem;max-height:250px;overflow-y:auto;">
          <p style="color:#555;text-align:center;">Reports will appear here after students complete gameplay.</p>
        </div>
        <button class="s-button ghost" onclick="exportAllReports()" style="margin-top:0.5rem;padding:0.4rem;width:100%;">üì• Export All Reports (CSV)</button>
      </div>
      
    </div>
  </div>
  
  <!-- Student Join -->
  <div id="scr-student" class="s-screen">
    <div class="s-card">
      <h2>üéì Join Session</h2>
      <p style="text-align:center;color:#888;font-size:0.85rem;">Enter 6-digit code from teacher:</p>
      <div class="s-code-row">
        <input type="text" class="s-code-digit" id="code-digit-0" name="code-digit-0" maxlength="1" data-i="0" autocomplete="off">
        <input type="text" class="s-code-digit" id="code-digit-1" name="code-digit-1" maxlength="1" data-i="1" autocomplete="off">
        <input type="text" class="s-code-digit" id="code-digit-2" name="code-digit-2" maxlength="1" data-i="2" autocomplete="off">
        <input type="text" class="s-code-digit" id="code-digit-3" name="code-digit-3" maxlength="1" data-i="3" autocomplete="off">
        <input type="text" class="s-code-digit" id="code-digit-4" name="code-digit-4" maxlength="1" data-i="4" autocomplete="off">
        <input type="text" class="s-code-digit" id="code-digit-5" name="code-digit-5" maxlength="1" data-i="5" autocomplete="off">
      </div>
      <div id="s-status" class="s-status"></div>
      <input type="text" class="s-input" id="s-name" name="s-name" placeholder="Your FIRST NAME only" maxlength="20" autocomplete="given-name">
      <button class="s-button" id="s-join-btn" disabled>Join Game</button>
      <div class="s-notice">üîí FERPA: Only first name shared. No data stored.</div>
      <button type="button" class="s-link" id="btn-back-from-student" style="background:none;border:none;font-family:inherit;">‚Üê Back</button>
    </div>
  </div>
  
  <!-- Student Waiting -->
  <div id="scr-waiting" class="s-screen">
    <div class="s-card" style="text-align:center;">
      <h2>‚è≥ Waiting for Teacher</h2>
      <p style="color:#888;">You're in! Get ready.</p>
      <div class="s-code-display" id="w-code" style="font-size:1.5rem;">------</div>
      <div id="p2p-status" class="p2p-status connecting">Connecting...</div>
      <p style="color:#888;font-size:0.85rem;">Players: <span id="w-count">1</span></p>
      <div class="s-grid" id="w-list"></div>
      <p style="color:#f59e0b;margin-top:0.8rem;animation:s-pulse 2s infinite;font-size:0.9rem;">Waiting for teacher...</p>
    </div>
  </div>
  
</div>

<!-- GAME CANVAS -->
<canvas id="c"></canvas>

<!-- MOBILE TOUCH CONTROLS -->
<div id="touch-controls">
  <div id="joystick-zone">
    <div id="joystick-base">
      <div id="joystick-thumb"></div>
    </div>
  </div>
  <div id="action-buttons">
    <div id="btn-jump" class="action-btn"><span>‚¨Ü</span><span class="btn-label">Jump</span></div>
    <div id="btn-special" class="action-btn"><span>‚ú®</span><span class="btn-label">Skill</span></div>
    <div id="btn-dash" class="action-btn"><span>üí®</span><span class="btn-label">Dash</span></div>
    <div id="btn-attack" class="action-btn"><span>‚öî</span><span class="btn-label">Hit</span></div>
    <div id="btn-ranged" class="action-btn"><span>üéØ</span><span class="btn-label">Shoot</span></div>
    <div id="btn-parry" class="action-btn"><span>üõ°</span><span class="btn-label">Block</span></div>
    <div id="btn-ultimate" class="action-btn"><span>üí•</span><span class="btn-label">Ult</span></div>
  </div>
  <div id="btn-pause"><span>‚è∏</span></div>
  <div id="btn-sound"><span>üîä</span></div>
  <div id="btn-settings"><span>‚öôÔ∏è</span></div>
</div>

<!-- MOBILE SETTINGS OVERLAY -->
<div id="mobile-settings">
  <div class="settings-card">
    <div class="settings-title">‚öôÔ∏è SETTINGS</div>
    <div class="settings-options">
      <div class="settings-item" id="setting-gesture">
        <span class="setting-label">Swipe Controls</span>
        <span class="setting-toggle">OFF</span>
      </div>
      <div class="settings-item" id="setting-autoattack">
        <span class="setting-label">Auto-Attack</span>
        <span class="setting-toggle">OFF</span>
      </div>
      <div class="settings-item" id="setting-battery">
        <span class="setting-label">Battery Saver (30fps)</span>
        <span class="setting-toggle">OFF</span>
      </div>
    </div>
    <div class="settings-desc">
      <b>Swipe:</b> Swipe up=jump, left/right=dash, down=parry<br>
      <b>Auto-Attack:</b> Auto-hit when near boss, auto-dodge<br>
      <b>Battery:</b> Reduces framerate to save power
    </div>
    <button class="settings-close" id="close-settings">DONE</button>
  </div>
</div>

<!-- MENU TOUCH BUTTONS -->
<div id="menu-touch">
  <div class="menu-touch-btn" id="touch-select">SELECT</div>
  <div class="menu-touch-btn" id="touch-back">BACK</div>
</div>

<!-- SESSION SYSTEM SCRIPT -->
<script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-database-compat.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
<script>
// ==========================================
// FIREBASE CONFIGURATION
// ==========================================
// Client-side Firebase config (security is via database rules)
const firebaseConfig = {
  apiKey: ['AIzaSy', 'CcS8Yg8', 'ixWWdtf', 'HDqHOYG', 'UhBDlnM', 'MB9Nw'].join(''),
  authDomain: "eduquest-8f086.firebaseapp.com",
  databaseURL: "https://eduquest-8f086-default-rtdb.firebaseio.com",
  projectId: "eduquest-8f086",
  storageBucket: "eduquest-8f086.firebasestorage.app",
  messagingSenderId: "953232337834",
  appId: "1:953232337834:web:c5580ecb777759733cd9d3"
};

// Initialize Firebase
let db = null;
let isFirebaseReady = false;
let activeListeners = []; // Track for cleanup

try {
  firebase.initializeApp(firebaseConfig);
  db = firebase.database();
  isFirebaseReady = true;
  console.log('‚úì Firebase connected (optimized)');
} catch(e) {
  console.error('Firebase error:', e);
}

// ==========================================
// OPTIMIZED SESSION SYSTEM - MINIMAL READS/WRITES
// ==========================================
const urlParams = new URLSearchParams(window.location.search);
const userRole = urlParams.get('role');

const SES = {
  data: {}, code: null, poll: null, studentName: null, isTeacher: false,
  studentId: null,
  connectionStatus: 'disconnected',
  
  // LOCAL CACHE - Reduces reads by 90%
  cache: {
    sessions: {},
    lastCheck: {},
    TTL: 30000, // 30 second cache
    
    get(code) {
      const cached = this.sessions[code];
      const age = Date.now() - (this.lastCheck[code] || 0);
      if (cached && age < this.TTL) return cached;
      return null;
    },
    
    set(code, data) {
      this.sessions[code] = data;
      this.lastCheck[code] = Date.now();
      try {
        localStorage.setItem('civitas_cache_' + code, JSON.stringify({ data, ts: Date.now() }));
      } catch(e) {}
    },
    
    loadFromStorage(code) {
      try {
        const stored = localStorage.getItem('civitas_cache_' + code);
        if (stored) {
          const { data, ts } = JSON.parse(stored);
          if (Date.now() - ts < 300000) { // 5 min from storage
            this.sessions[code] = data;
            this.lastCheck[code] = ts;
            return data;
          }
        }
      } catch(e) {}
      return null;
    }
  },
  
  // BATCH SYSTEM - Collects all data, writes ONCE at end
  batch: {
    answers: [],
    startTime: null,
    
    reset() {
      this.answers = [];
      this.startTime = Date.now();
    },
    
    addAnswer(qId, correct, responseTime) {
      this.answers.push({ q: qId, ok: correct ? 1 : 0, t: responseTime });
    },
    
    // SINGLE WRITE at game end
    async flush(code, studentId, finalReport) {
      if (!isFirebaseReady || !code || !studentId) return false;
      if (this.answers.length === 0 && !finalReport) return false;
      
      try {
        const payload = {
          answers: this.answers,
          report: finalReport || {},
          duration: Date.now() - this.startTime,
          completedAt: Date.now()
        };
        
        await db.ref('sessions/' + code + '/results/' + studentId).set(payload);
        console.log('‚úì Batch write: 1 write for', this.answers.length, 'answers');
        this.reset();
        return true;
      } catch(e) {
        console.error('Batch write failed:', e);
        return false;
      }
    }
  },
  
  init() { 
    if (userRole === 'student') {
      const setupStudent = () => {
        sShow('student');
        const autoCode = urlParams.get('code');
        if (autoCode) {
          autoCode.toUpperCase().split('').forEach((char, i) => {
            const inp = document.getElementById(`code-digit-${i}`);
            if (inp) inp.value = char;
          });
          setTimeout(() => sValidate(), 100);
        }
      };
      
      if (document.readyState === 'loading') {
        window.addEventListener('DOMContentLoaded', setupStudent);
      } else {
        setupStudent();
      }
    }
  },
  
  updateStatus(status, message) {
    this.connectionStatus = status;
    console.log('[Firebase]', status, message || '');
    const statusEl = document.getElementById('p2p-status');
    if (statusEl) {
      statusEl.textContent = message || status;
      statusEl.className = 'p2p-status ' + status;
    }
    
    if (typeof ConnectionUI !== 'undefined') {
      if (status === 'connected') ConnectionUI.connected();
      else if (status === 'connecting' || status === 'reconnecting') ConnectionUI.connecting();
      else if (status === 'error' || status === 'disconnected') ConnectionUI.error(message);
    }
  },

  get(code) { return this.data[code]; },
  genCode() { const c='ABCDEFGHJKLMNPQRSTUVWXYZ23456789'; let r=''; for(let i=0;i<6;i++) r+=c[Math.floor(Math.random()*c.length)]; return r; },
  
  // TEACHER: Create session (1 write)
  create(email) {
    if (!isFirebaseReady) {
      alert('Firebase not connected');
      return null;
    }
    
    const code = this.genCode();
    this.data[code] = { code, teacher: email, students: [], status: 'waiting', created: Date.now() };
    this.isTeacher = true;
    this.code = code;
    
    // SINGLE WRITE to create session
    db.ref('sessions/' + code).set({
      teacher: email,
      created: Date.now(),
      status: 'waiting'
    });
    
    // DEBOUNCED listener for students (reduces reads)
    let debounceTimer = null;
    const listener = db.ref('sessions/' + code + '/students').on('value', (snapshot) => {
      if (debounceTimer) clearTimeout(debounceTimer);
      debounceTimer = setTimeout(() => {
        const students = snapshot.val() || {};
        this.data[code].students = Object.entries(students).map(([id, s]) => ({
          id, name: s.name, masked: s.name.substring(0,3) + '***', joined: s.joined
        }));
        if (typeof sUpdateTeacher === 'function') sUpdateTeacher();
      }, 500); // Max 2 updates per second
    });
    
    activeListeners.push({ path: 'sessions/' + code + '/students', callback: listener });
    
    // Also listen for results (debounced)
    let resultsTimer = null;
    const resultsListener = db.ref('sessions/' + code + '/results').on('value', (snapshot) => {
      if (resultsTimer) clearTimeout(resultsTimer);
      resultsTimer = setTimeout(() => {
        const results = snapshot.val() || {};
        Object.entries(results).forEach(([studentId, data]) => {
          if (data.report) {
            const student = this.data[code].students.find(s => s.id === studentId);
            const name = student ? student.name : studentId;
            if (typeof addStudentReport === 'function') {
              addStudentReport(name, data.report);
            }
          }
        });
      }, 1000);
    });
    
    activeListeners.push({ path: 'sessions/' + code + '/results', callback: resultsListener });
    
    return code;
  },
  
  // STUDENT: Join session (1 write)
  joinSession(code, name) {
    if (!isFirebaseReady) {
      alert('Cannot connect to server');
      return false;
    }
    
    this.studentName = name;
    this.code = code;
    this.studentId = 's_' + Date.now().toString(36) + Math.random().toString(36).substr(2, 4);
    this.batch.reset();
    
    // SINGLE WRITE to join
    db.ref('sessions/' + code + '/students/' + this.studentId).set({
      name: name,
      joined: Date.now()
    });
    
    this.updateStatus('connected', 'Connected to class!');
    
    // POLL for game start instead of continuous listener (saves reads)
    const pollStatus = () => {
      if (!this.code) return;
      db.ref('sessions/' + code + '/status').once('value', (snapshot) => {
        if (snapshot.val() === 'playing') {
          sStart();
        } else {
          setTimeout(pollStatus, 2000); // Check every 2 seconds
        }
      });
    };
    pollStatus();
    
    return true;
  },
  
  // Check session exists (uses cache)
  checkSession(code, callback) {
    const cached = this.cache.get(code) || this.cache.loadFromStorage(code);
    if (cached) {
      callback(true);
      return;
    }
    
    if (!isFirebaseReady) {
      callback(false);
      return;
    }
    
    db.ref('sessions/' + code).once('value', (snapshot) => {
      const exists = snapshot.exists();
      if (exists) this.cache.set(code, { exists: true });
      callback(exists);
    });
  },
  
  // Start game (1 write)
  startGame() {
    if (this.code && isFirebaseReady) {
      db.ref('sessions/' + this.code + '/status').set('playing');
    }
  },
  
  // Track answer LOCALLY (no write)
  trackAnswer(questionId, correct, responseTime) {
    this.batch.addAnswer(questionId, correct, responseTime);
  },
  
  // Submit final results (1 write for entire game)
  submitResults(report) {
    if (!this.code || !this.studentId) return;
    this.batch.flush(this.code, this.studentId, report);
  },
  
  // End session (1 write to delete)
  endSession() {
    if (this.code && isFirebaseReady && this.isTeacher) {
      db.ref('sessions/' + this.code).remove();
    }
    this.cleanup();
  },
  
  // Leave session (student)
  leaveSession() {
    if (this.code && this.studentId) {
      // Flush any pending data
      this.batch.flush(this.code, this.studentId, null);
    }
    this.cleanup();
  },
  
  // CLEANUP all listeners
  cleanup() {
    activeListeners.forEach(({ path, callback }) => {
      try { db.ref(path).off('value', callback); } catch(e) {}
    });
    activeListeners = [];
    this.code = null;
    this.studentId = null;
    console.log('‚úì Firebase listeners cleaned up');
  },
  
  // Broadcast custom questions to students (1 write)
  broadcastQuestions() {
    if (!this.code || !isFirebaseReady || !this.isTeacher) return;
    if (typeof customQuestions === 'undefined' || customQuestions.length === 0) return;
    
    // Write questions to Firebase for students to fetch
    db.ref('sessions/' + this.code + '/customQuestions').set(customQuestions);
    console.log('‚úì Broadcast', customQuestions.length, 'custom questions');
  },
  
  // Fetch custom questions (for students)
  fetchQuestions(callback) {
    if (!this.code || !isFirebaseReady) {
      callback([]);
      return;
    }
    
    db.ref('sessions/' + this.code + '/customQuestions').once('value', (snapshot) => {
      const questions = snapshot.val() || [];
      callback(questions);
    });
  }
};

function sShow(id) {
  document.querySelectorAll('.s-screen').forEach(s => s.classList.remove('active'));
  const target = document.getElementById('scr-'+id);
  if (target) target.classList.add('active');
}

function sValidate() {
  const code = [...document.querySelectorAll('.s-code-digit')].map(i => i.value).join('');
  const nameEl = document.getElementById('s-name');
  const name = nameEl ? nameEl.value.trim() : '';
  const status = document.getElementById('s-status');
  const btn = document.getElementById('s-join-btn');
  
  if (!status || !btn) return;
  
  if(code.length < 6) { status.textContent = ''; status.className = 's-status'; btn.disabled = true; return; }
  
  // Check Firebase for session
  if (isFirebaseReady) {
    SES.checkSession(code, (exists) => {
      if (exists) {
        status.textContent = '‚úÖ Session found!';
        status.className = 's-status ok';
        btn.disabled = name.length < 2;
      } else {
        status.textContent = '‚ùå Session not found';
        status.className = 's-status err';
        btn.disabled = true;
      }
    });
  } else {
    status.textContent = '‚ö†Ô∏è Not connected to server';
    status.className = 's-status err';
    btn.disabled = true;
  }
}

// Initialize SES after sShow and sValidate are defined
SES.init();

// Security Warning for Teacher Login
function sTeacherLogin() {
  const email = prompt('Enter email:\n\nAuthorized: @dadeschools.net\nException: synapsecopilot@gmail.com');
  if(!email) return;
  
  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  if (!emailRegex.test(email)) {
    alert('Invalid email format.');
    return;
  }
  
  const ok = email.endsWith('@dadeschools.net') || email.endsWith('@students.dadeschools.net') || email === 'synapsecopilot@gmail.com';
  if(!ok) { alert('Access denied. Use authorized email.'); return; }
  
  SES.code = SES.create(email);
  SES.teacherEmail = email; 
  document.getElementById('t-code').textContent = SES.code;
  sShow('dashboard');
  SES.poll = setInterval(sUpdateTeacher, 1000);
}

function sUpdateTeacher() {
  const s = SES.get(SES.code);
  if(!s) return;
  document.getElementById('t-count').textContent = s.students.length;
  const list = document.getElementById('t-list');
  list.innerHTML = s.students.length 
    ? s.students.map(x => '<div class="s-tag">'+x.masked+'</div>').join('') 
    : '<p style="color:#555;grid-column:1/-1;text-align:center;font-size:0.8rem;">Waiting for students...</p>';
}

function sCopyLink() { 
  // 1. Get the current website URL (works locally or on GitHub)
  const baseUrl = window.location.origin + window.location.pathname;
  
  // 2. Build the magic student link
  const magicLink = `${baseUrl}?role=student&code=${SES.code}`;
  
  // 3. Copy it to the clipboard automatically
  navigator.clipboard.writeText(magicLink)
    .then(() => alert('Student Link Copied!\n\nPaste this in your classroom:\n' + magicLink))
    .catch(() => prompt('Copy this link:', magicLink)); 
}

function sAddTest() {
  const names = ['Maria','Carlos','Sofia','Diego','Isabella','Miguel','Ana','Luis'];
  const testName = names[Math.floor(Math.random()*names.length)];
  const s = SES.get(SES.code);
  if(s) {
      s.students.push({ name: testName, masked: testName.substring(0,3)+'***', joined: Date.now() });
      sUpdateTeacher();
  }
}

function sTeacherStart() {
  const s = SES.get(SES.code);
  if(s && s.students.length === 0) {
    if(confirm('No students yet. Add test student?')) sAddTest();
    else return;
  }
  if(s) s.status = 'active';
  clearInterval(SES.poll);
  
  // Tell Firebase to start game for all students
  SES.startGame();
  sStart();
}

// Student code input validation
document.addEventListener('DOMContentLoaded', () => {
  const inputs = document.querySelectorAll('.s-code-digit');
  inputs.forEach((inp, i) => {
    inp.addEventListener('input', () => {
      inp.value = inp.value.toUpperCase().replace(/[^A-Z0-9]/g,'');
      if(inp.value && i < 5) inputs[i+1].focus();
      sValidate();
    });
    inp.addEventListener('keydown', e => {
      if(e.key === 'Backspace' && !inp.value && i > 0) inputs[i-1].focus();
    });
  });
  const sNameInput = document.getElementById('s-name');
  if(sNameInput) sNameInput.addEventListener('input', sValidate);
});

function sStudentJoin() {
  const code = [...document.querySelectorAll('.s-code-digit')].map(i => i.value).join('');
  const name = document.getElementById('s-name').value.trim();
  
  // Join via Firebase
  if (SES.joinSession(code, name)) {
    document.getElementById('w-code').textContent = code;
    sShow('waiting');
    // Game starts when teacher clicks start (Firebase listener handles this)
  }
}

function sStart() {
  const overlay = document.getElementById('session-overlay');
  if (overlay) overlay.classList.add('hidden');
  const canvas = document.getElementById('c');
  if (canvas) {
    canvas.style.display = 'block';
    canvas.style.visibility = 'visible';
    canvas.style.opacity = '1';
  }
  
  // Fetch custom questions if in a session (students)
  if (typeof SES !== 'undefined' && SES.code && !SES.isTeacher && typeof SES.fetchQuestions === 'function') {
    SES.fetchQuestions((questions) => {
      if (questions && questions.length > 0) {
        if (typeof customQuestions !== 'undefined') {
          customQuestions.push(...questions);
          console.log('‚úì Loaded', questions.length, 'custom questions from teacher');
        }
      }
    });
  }
}

// ============ iOS-COMPATIBLE SESSION UI EVENT HANDLERS ============
document.addEventListener('DOMContentLoaded', function() {
  // Play Solo button
  const btnPlaySolo = document.getElementById('btn-play-solo');
  if (btnPlaySolo) {
    btnPlaySolo.addEventListener('click', sStart);
    btnPlaySolo.addEventListener('touchend', function(e) {
      e.preventDefault();
      sStart();
    });
  }
  
  // Teacher mode button
  const btnTeacher = document.getElementById('btn-teacher-mode');
  if (btnTeacher) {
    btnTeacher.addEventListener('click', function() { sShow('teacher'); });
    btnTeacher.addEventListener('touchend', function(e) {
      e.preventDefault();
      sShow('teacher');
    });
  }
  
  // Student mode button
  const btnStudent = document.getElementById('btn-student-mode');
  if (btnStudent) {
    btnStudent.addEventListener('click', function() { sShow('student'); });
    btnStudent.addEventListener('touchend', function(e) {
      e.preventDefault();
      sShow('student');
    });
  }
  
  // Back from teacher button
  const btnBackTeacher = document.getElementById('btn-back-from-teacher');
  if (btnBackTeacher) {
    btnBackTeacher.addEventListener('click', function() { sShow('entry'); });
    btnBackTeacher.addEventListener('touchend', function(e) {
      e.preventDefault();
      sShow('entry');
    });
  }
  
  // Back from student button
  const btnBackStudent = document.getElementById('btn-back-from-student');
  if (btnBackStudent) {
    btnBackStudent.addEventListener('click', function() { sShow('entry'); });
    btnBackStudent.addEventListener('touchend', function(e) {
      e.preventDefault();
      sShow('entry');
    });
  }
  
  // Google login button
  const btnGoogle = document.getElementById('btn-google-login');
  if (btnGoogle) {
    btnGoogle.addEventListener('click', sTeacherLogin);
    btnGoogle.addEventListener('touchend', function(e) {
      e.preventDefault();
      sTeacherLogin();
    });
  }
  
  // Student join button
  const btnJoin = document.getElementById('s-join-btn');
  if (btnJoin) {
    btnJoin.addEventListener('click', sStudentJoin);
    btnJoin.addEventListener('touchend', function(e) {
      e.preventDefault();
      if (!btnJoin.disabled) sStudentJoin();
    });
  }
});

// ============ TEACHER DASHBOARD TOOLS ============
let currentDashTab = 'setup';
let sessionReports = {}; // Store reports by student name

// Session configuration
const SessionConfig = {
  gameMode: 'solo', // 'solo', 'raid', 'both'
  questionCount: 15,
  selectedStandards: [],
  raidBoss: 'WORLD_SERPENT',
  raidTimer: 30,
  
  save() {
    this.gameMode = document.querySelector('input[name="game-mode"]:checked')?.value || 'solo';
    this.questionCount = parseInt(document.getElementById('question-count')?.value || 15);
    this.raidBoss = document.getElementById('raid-boss')?.value || 'WORLD_SERPENT';
    this.raidTimer = parseInt(document.getElementById('raid-timer')?.value || 30);
    
    // Get selected standards
    this.selectedStandards = [];
    document.querySelectorAll('#standards-grid input[type="checkbox"]:checked').forEach(cb => {
      this.selectedStandards.push(cb.value);
    });
    
    // Update session display
    const modeNames = { solo: 'Solo Only', raid: 'Raid Only', both: 'Solo ‚Üí Raid' };
    const modeDisplay = document.getElementById('session-mode-display');
    if (modeDisplay) modeDisplay.textContent = modeNames[this.gameMode] || 'Solo Only';
    
    const questionsDisplay = document.getElementById('session-questions-display');
    if (questionsDisplay) questionsDisplay.textContent = this.questionCount;
    
    const standardsDisplay = document.getElementById('session-standards-display');
    if (standardsDisplay) {
      standardsDisplay.textContent = this.selectedStandards.length === 0 || 
        this.selectedStandards.length >= getAllStandards().length ? 'All' : 
        this.selectedStandards.length + ' selected';
    }
  }
};

function showDashTab(tab) {
  currentDashTab = tab;
  const setupEl = document.getElementById('dash-setup');
  const sessionEl = document.getElementById('dash-session');
  const questionsEl = document.getElementById('dash-questions');
  const reportsEl = document.getElementById('dash-reports');
  
  if (setupEl) setupEl.style.display = tab === 'setup' ? 'block' : 'none';
  if (sessionEl) sessionEl.style.display = tab === 'session' ? 'block' : 'none';
  if (questionsEl) questionsEl.style.display = tab === 'questions' ? 'block' : 'none';
  if (reportsEl) reportsEl.style.display = tab === 'reports' ? 'block' : 'none';
  
  // Update tab styles
  const tabSetup = document.getElementById('tab-setup');
  const tabSession = document.getElementById('tab-session');
  const tabQuestions = document.getElementById('tab-questions');
  const tabReports = document.getElementById('tab-reports');
  
  if (tabSetup) tabSetup.className = tab === 'setup' ? 's-button' : 's-button ghost';
  if (tabSession) tabSession.className = tab === 'session' ? 's-button' : 's-button ghost';
  if (tabQuestions) tabQuestions.className = tab === 'questions' ? 's-button' : 's-button ghost';
  if (tabReports) tabReports.className = tab === 'reports' ? 's-button' : 's-button ghost';
  
  // Initialize setup tab
  if (tab === 'setup') {
    populateStandardsGrid();
  }
  
  // Update counts
  if (tab === 'questions') {
    document.getElementById('q-count').textContent = typeof QUESTIONS !== 'undefined' ? QUESTIONS.length : 40;
    document.getElementById('q-custom').textContent = typeof customQuestions !== 'undefined' ? customQuestions.length : 0;
  }
}

function getAllStandards() {
  const standards = new Set();
  if (typeof QUESTIONS !== 'undefined') {
    QUESTIONS.forEach(q => standards.add(q.standard));
  }
  if (typeof customQuestions !== 'undefined') {
    customQuestions.forEach(q => standards.add(q.standard));
  }
  return Array.from(standards).sort();
}

function populateStandardsGrid() {
  const grid = document.getElementById('standards-grid');
  if (!grid) return;
  
  const standards = getAllStandards();
  grid.innerHTML = standards.map(std => `
    <label style="display:flex;align-items:center;gap:0.3rem;cursor:pointer;padding:0.3rem;background:#252545;border-radius:0.2rem;font-size:0.75rem;">
      <input type="checkbox" value="${std}" checked style="accent-color:#6366f1;">
      <span style="white-space:nowrap;overflow:hidden;text-overflow:ellipsis;">${std}</span>
    </label>
  `).join('');
}

function selectAllStandards() {
  document.querySelectorAll('#standards-grid input[type="checkbox"]').forEach(cb => cb.checked = true);
}

function deselectAllStandards() {
  document.querySelectorAll('#standards-grid input[type="checkbox"]').forEach(cb => cb.checked = false);
}

function updateQuestionCount() {
  const count = document.getElementById('question-count')?.value || 15;
  const display = document.getElementById('question-count-display');
  if (display) display.textContent = count;
}

function saveGameSetup() {
  SessionConfig.save();
  showDashTab('session');
  alert('‚úÖ Game setup saved!');
}

function teacherJoinGame() {
  // Teacher can join as viewer to monitor
  SES.isTeacher = true;
  sStart();
}

function handleFileUpload(event) {
  const file = event.target.files[0];
  if (!file) return;
  
  // Handle PDF files separately
  if (file.name.endsWith('.pdf')) {
    handlePDFUpload(file);
    event.target.value = '';
    return;
  }
  
  const reader = new FileReader();
  reader.onload = function(e) {
    const content = e.target.result;
    let questions = [];
    
    if (file.name.endsWith('.json')) {
      questions = TeacherTools.parseJSON(content);
    } else if (file.name.endsWith('.csv')) {
      questions = TeacherTools.parseCSV(content);
    }
    
    if (questions.length > 0) {
      customQuestions.push(...questions);
      document.getElementById('q-custom').textContent = customQuestions.length;
      
      // Broadcast to students via P2P
      if (SES.isTeacher) {
        SES.broadcastQuestions();
      }
      
      // Show preview
      showQuestionPreview(questions);
    } else {
      alert('‚ùå No valid questions found in file.');
    }
  };
  reader.readAsText(file);
  event.target.value = ''; // Reset input
}

// PDF Upload Handler - SMARTER PARSING
async function handlePDFUpload(file) {
  try {
    // Set PDF.js worker
    pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
    
    const arrayBuffer = await file.arrayBuffer();
    const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
    
    let fullText = '';
    
    // Extract text from all pages
    for (let i = 1; i <= pdf.numPages; i++) {
      const page = await pdf.getPage(i);
      const textContent = await page.getTextContent();
      const pageText = textContent.items.map(item => item.str).join(' ');
      fullText += pageText + '\n';
    }
    
    // Parse questions from PDF text
    const questions = parsePDFQuestions(fullText);
    
    if (questions.length > 0) {
      customQuestions.push(...questions);
      document.getElementById('q-custom').textContent = customQuestions.length;
      
      // Broadcast to students via P2P
      if (SES.isTeacher) {
        SES.broadcastQuestions();
      }
      
      // Show preview
      showQuestionPreview(questions);
    } else {
      // Show extracted text for manual review
      alert('‚ùå Could not auto-detect questions.\n\nExtracted text preview:\n' + fullText.substring(0, 500) + '...\n\nTry CSV or JSON format for structured data.');
    }
  } catch (error) {
    console.error('PDF parsing error:', error);
    alert('‚ùå Error reading PDF: ' + error.message);
  }
}

// SMARTER PDF Question Parser
function parsePDFQuestions(text) {
  const questions = [];
  
  // Clean up text
  text = text.replace(/\s+/g, ' ').trim();
  
  // Multiple patterns to try (from most specific to least)
  const patterns = [
    // Pattern 1: "1. Question A) ans B) ans C) ans D) ans"
    /(\d+)\.\s*(.+?)\s*[Aa]\)\s*(.+?)\s*[Bb]\)\s*(.+?)\s*[Cc]\)\s*(.+?)\s*[Dd]\)\s*(.+?)(?=\d+\.|$)/gs,
    // Pattern 2: "1. Question A. ans B. ans C. ans D. ans"
    /(\d+)\.\s*(.+?)\s*[Aa]\.\s*(.+?)\s*[Bb]\.\s*(.+?)\s*[Cc]\.\s*(.+?)\s*[Dd]\.\s*(.+?)(?=\d+\.|$)/gs,
    // Pattern 3: "1) Question a) ans b) ans c) ans d) ans"
    /(\d+)\)\s*(.+?)\s*[Aa]\)\s*(.+?)\s*[Bb]\)\s*(.+?)\s*[Cc]\)\s*(.+?)\s*[Dd]\)\s*(.+?)(?=\d+\)|$)/gs,
    // Pattern 4: Newline separated "Question\nA. ans\nB. ans..."
    /(?:^|\n)(\d+)[.\)]\s*([^\n]+)\n\s*[Aa][.\)]\s*([^\n]+)\n\s*[Bb][.\)]\s*([^\n]+)\n\s*[Cc][.\)]\s*([^\n]+)\n\s*[Dd][.\)]\s*([^\n]+)/g,
  ];
  
  for (const pattern of patterns) {
    const matches = [...text.matchAll(pattern)];
    
    for (const match of matches) {
      const questionText = match[2].trim();
      const answers = [
        match[3].trim(),
        match[4].trim(),
        match[5].trim(),
        match[6].trim()
      ];
      
      // Only add if question and all answers are non-empty and reasonable length
      if (questionText.length > 5 && answers.every(a => a.length > 0 && a.length < 200)) {
        // Check for correct answer markers (* or bold or "correct")
        let correctIdx = 0;
        answers.forEach((a, i) => {
          if (a.includes('*') || a.toLowerCase().includes('correct')) {
            correctIdx = i;
            answers[i] = a.replace(/\*|correct/gi, '').trim();
          }
        });
        
        questions.push({
          id: 5000 + questions.length,
          level: 2, // Default to level 2
          standard: 'PDF Import',
          q: questionText,
          a: answers,
          correct: correctIdx
        });
      }
    }
    
    // If we found questions with this pattern, stop trying others
    if (questions.length > 0) break;
  }
  
  return questions;
}

// Show preview of imported questions
function showQuestionPreview(questions) {
  const previewHtml = questions.slice(0, 5).map((q, i) => 
    `<div style="background:#1a1a2e;padding:8px;border-radius:6px;margin:4px 0;font-size:12px;">
      <strong>Q${i+1}:</strong> ${q.q.substring(0, 60)}${q.q.length > 60 ? '...' : ''}<br>
      <span style="color:#22c55e;">‚úì ${q.a[q.correct]}</span>
    </div>`
  ).join('');
  
  const moreText = questions.length > 5 ? `<p style="color:#888;font-size:11px;">...and ${questions.length - 5} more questions</p>` : '';
  
  alert(`‚úÖ Imported ${questions.length} questions!\n\nQuestions will appear every 30 seconds during gameplay.`);
  
  // Update the Questions tab preview if it exists
  const previewArea = document.getElementById('question-preview');
  if (previewArea) {
    previewArea.style.display = 'block';
    previewArea.innerHTML = `<h4 style="color:#6366f1;margin-bottom:8px;">üìù Imported Questions (${customQuestions.length} total)</h4>` + previewHtml + moreText;
  }
}

function addManualQuestion() {
  const level = parseInt(document.getElementById('manual-level').value);
  const standard = document.getElementById('manual-standard').value.trim() || 'Custom';
  const q = document.getElementById('manual-q').value.trim();
  const a1 = document.getElementById('manual-a1').value.trim();
  const a2 = document.getElementById('manual-a2').value.trim();
  const a3 = document.getElementById('manual-a3').value.trim();
  const a4 = document.getElementById('manual-a4').value.trim();
  
  if (!q || !a1 || !a2 || !a3 || !a4) {
    alert('Please fill in all fields.');
    return;
  }
  
  TeacherTools.addQuestion(level, standard, q, [a1, a2, a3, a4], 0);
  document.getElementById('q-custom').textContent = customQuestions.length;
  
  // Broadcast to students via P2P
  if (SES.isTeacher) {
    SES.broadcastQuestions();
  }
  
  // Update preview
  showQuestionPreview([customQuestions[customQuestions.length - 1]]);
  
  // Clear form
  document.getElementById('manual-q').value = '';
  document.getElementById('manual-a1').value = '';
  document.getElementById('manual-a2').value = '';
  document.getElementById('manual-a3').value = '';
  document.getElementById('manual-a4').value = '';
  
  alert('‚úÖ Question added and synced to students!');
}

function clearCustomQuestions() {
  if (confirm('Clear all custom questions?')) {
    TeacherTools.clearCustom();
    document.getElementById('q-custom').textContent = '0';
    
    // Hide preview
    const previewArea = document.getElementById('question-preview');
    if (previewArea) {
      previewArea.style.display = 'none';
      previewArea.innerHTML = '';
    }
    
    // Broadcast empty questions to students
    if (SES.isTeacher) {
      SES.broadcastQuestions();
    }
    
    alert('Custom questions cleared.');
  }
}

function addStudentReport(studentName, report) {
  sessionReports[studentName] = report;
  updateReportsDisplay();
}

function updateReportsDisplay() {
  const container = document.getElementById('reports-content');
  const names = Object.keys(sessionReports);
  
  if (names.length === 0) {
    container.innerHTML = '<p style="color:#555;text-align:center;">Reports will appear here after students complete gameplay.</p>';
    return;
  }
  
  let html = '';
  names.forEach(name => {
    const r = sessionReports[name];
    html += `
      <div style="background:#0a0a1a;padding:0.6rem;border-radius:0.4rem;margin-bottom:0.5rem;">
        <p style="font-weight:bold;color:#6366f1;">${name}</p>
        <p style="font-size:0.8rem;color:#888;">
          Questions: ${r.totalQuestions} | Correct: ${r.correct} | 
          Accuracy: <span style="color:${r.accuracy >= 70 ? '#22c55e' : r.accuracy >= 50 ? '#f59e0b' : '#ef4444'}">${r.accuracy}%</span> |
          Level: ${r.finalLevel}
        </p>
      </div>
    `;
  });
  container.innerHTML = html;
}

function exportAllReports() {
  const names = Object.keys(sessionReports);
  if (names.length === 0) {
    alert('No reports to export yet.');
    return;
  }
  
  // Build CSV
  let csv = 'Student,Total Questions,Correct,Wrong,Accuracy,Final Level\n';
  names.forEach(name => {
    const r = sessionReports[name];
    csv += `"${name}",${r.totalQuestions},${r.correct},${r.wrong},${r.accuracy}%,${r.finalLevel}\n`;
  });
  
  // Add standards breakdown
  csv += '\n\nStandards Breakdown\n';
  csv += 'Student,Standard,Correct,Total,Percentage\n';
  names.forEach(name => {
    const r = sessionReports[name];
    if (r.byStandard) {
      Object.entries(r.byStandard).forEach(([std, data]) => {
        const pct = data.total > 0 ? Math.round(data.correct / data.total * 100) : 0;
        csv += `"${name}","${std}",${data.correct},${data.total},${pct}%\n`;
      });
    }
  });
  
  // Download
  const blob = new Blob([csv], { type: 'text/csv' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'civitas_reports_' + new Date().toISOString().split('T')[0] + '.csv';
  a.click();
  URL.revokeObjectURL(url);
}
</script>

<!-- ORIGINAL GAME SCRIPT (UNCHANGED) -->
<script>
// ============================================================
// CIVITAS ULTIMATE ‚Äî 3 UNIQUE BOSSES EDITION
// Each boss has distinct: AI, movement, attacks, personality
// ============================================================

const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d', { 
  alpha: false,  // Disable alpha for better performance
  desynchronized: true  // Allow async rendering where supported
});

// Handle high-DPI / Retina displays
const BASE_WIDTH = 1200;
const BASE_HEIGHT = 700;
const dpr = Math.min(window.devicePixelRatio || 1, 2); // Cap at 2x for performance

canvas.width = BASE_WIDTH * dpr;
canvas.height = BASE_HEIGHT * dpr;
canvas.style.width = BASE_WIDTH + 'px';
canvas.style.height = BASE_HEIGHT + 'px';
ctx.scale(dpr, dpr);

// Performance hints
ctx.imageSmoothingEnabled = true;
ctx.imageSmoothingQuality = 'medium';

const CFG = {
  // Base movement
  PLAYER_SPEED: 13, JUMP_FORCE: 19, GRAVITY: 0.88,
  DASH_SPEED: 32, AIR_JUMPS: 2, GROUND_Y: 580,
  
  // Advanced movement
  COYOTE_TIME: 8,           // Frames after leaving platform you can still jump
  JUMP_BUFFER: 10,          // Frames before landing that jump input is stored
  VARIABLE_JUMP_CUT: 0.45,  // Multiply vy by this when releasing jump early
  AIR_CONTROL: 0.6,         // How much control in air vs ground (0-1)
  WALL_SLIDE_SPEED: 3,      // Max fall speed when wall sliding
  WALL_JUMP_FORCE_X: 18,    // Horizontal force when wall jumping
  WALL_JUMP_FORCE_Y: 17,    // Vertical force when wall jumping
  GROUND_POUND_SPEED: 25,   // Fall speed during ground pound
  GROUND_POUND_DAMAGE: 150, // Damage dealt by ground pound
  ROLL_WINDOW: 12,          // Frames before landing to trigger roll
  ROLL_SPEED: 20,           // Speed during roll
  ROLL_INVULN: 15,          // Invulnerability frames during roll
  
  // Combat
  COMBO_WINDOW: 30,         // Frames to chain next attack
  CHARGE_TIME: 45,          // Frames to fully charge attack
  CHARGE_DAMAGE_MULT: 2.5,  // Damage multiplier for charged attack
  PARRY_CRIT_WINDOW: 90,    // Frames of crit opportunity after parry
  PARRY_CRIT_MULT: 3.0,     // Damage multiplier during parry crit window
  HITSTOP_LIGHT: 3,         // Frames of hitstop for light attacks
  HITSTOP_HEAVY: 6,         // Frames of hitstop for heavy attacks
  HITSTOP_CRIT: 10,         // Frames of hitstop for crits
  JUGGLE_GRAVITY: 0.5,      // Reduced gravity while enemy is juggled
  LAUNCHER_FORCE: 22,       // Upward force for launcher attack
  
  // Quiz
  QUIZ_INVULN_AFTER: 90,    // Invulnerability frames after quiz ends
  
  // Visual
  SHAKE_DECAY: 0.88,        // How fast screen shake decays
  TRAIL_LENGTH: 8,          // Number of afterimages in attack trail
  
  DIFFICULTY: {
    EASY: { bossHp: 0.6, bossDmg: 0.5, bossSpeed: 0.7, playerHp: 1.3 },
    NORMAL: { bossHp: 1, bossDmg: 1, bossSpeed: 1, playerHp: 1 },
    HARD: { bossHp: 1.5, bossDmg: 1.5, bossSpeed: 1.3, playerHp: 0.85 },
    NIGHTMARE: { bossHp: 2.5, bossDmg: 2, bossSpeed: 1.6, playerHp: 0.7 },
  },
};

// ============ SPIRIT CLASSES ============
const CLASSES = {
  INFERNO: {
    name: 'INFERNO', theme: 'FLAME BERSERKER',
    color: '#ef4444', glow: '#fca5a5', core: '#ff6b35', trail: '#ff9500',
    hp: 300, mana: 100, speed: 1.2, damage: 2.0,
    melee: { dmg: 80, range: 180 }, ranged: { dmg: 60, cost: 8, speed: 20 },
    special: { dmg: 350, range: 300 }, ultimate: { dmg: 800 },
    element: 'fire', rageBonus: 1.5,
  },
  CRYSTAL: {
    name: 'CRYSTAL', theme: 'ARCANE MAGE',
    color: '#8b5cf6', glow: '#c4b5fd', core: '#a78bfa', trail: '#7c3aed',
    hp: 250, mana: 150, speed: 1.0, damage: 2.5,
    melee: { dmg: 50, range: 130 }, ranged: { dmg: 70, cost: 5, speed: 24 },
    special: { dmg: 120, hits: 10 }, ultimate: { dmg: 900 },
    element: 'crystal', rageBonus: 2.0,
  },
  SHADOW: {
    name: 'SHADOW', theme: 'PHANTOM ASSASSIN',
    color: '#10b981', glow: '#6ee7b7', core: '#34d399', trail: '#059669',
    hp: 280, mana: 120, speed: 1.6, damage: 1.8,
    melee: { dmg: 55, range: 150, backstab: 2.5 }, ranged: { dmg: 45, cost: 6, speed: 28 },
    special: { dmg: 180 }, ultimate: { dmg: 1200 },
    element: 'shadow', rageBonus: 1.8,
  },
};

// ============ UNIQUE BOSSES ============
const BOSSES = {
  VOID_TITAN: {
    name: 'VOID TITAN',
    title: 'Devourer of Worlds',
    personality: 'slow_tank', // Slow but devastating hits
    hp: 25000, damage: 12, speed: 2.5,
    color: '#6366f1', secondColor: '#312e81', enrageColor: '#c026d3',
    moveStyle: 'stomp', // Slow, heavy footsteps
    idleAnim: 'float', // Hovers menacingly
    phases: [
      { hp: 1.0, attacks: ['void_slash', 'gravity_well'], aggression: 0.3, name: 'SLUMBER' },
      { hp: 0.7, attacks: ['void_slash', 'gravity_well', 'dark_orbs'], aggression: 0.5, name: 'AWAKENING' },
      { hp: 0.4, attacks: ['void_slash', 'singularity', 'dark_orbs', 'summon_void'], aggression: 0.7, name: 'HUNGER' },
      { hp: 0.2, attacks: ['void_combo', 'singularity', 'reality_tear'], aggression: 0.9, name: 'CONSUME' },
    ],
    // Unique attacks
    attacks: {
      void_slash: { damage: 1.0, range: 200, windup: 45, recovery: 40, desc: 'Slow powerful slash' },
      gravity_well: { damage: 0.5, range: 350, windup: 60, recovery: 50, desc: 'Pulls player toward boss' },
      dark_orbs: { damage: 0.6, count: 5, speed: 6, homing: true, desc: 'Slow homing orbs' },
      singularity: { damage: 2.0, range: 400, windup: 90, recovery: 70, desc: 'Massive AoE after delay' },
      void_combo: { damage: 0.8, hits: 3, windup: 30, recovery: 60, desc: '3-hit devastating combo' },
      summon_void: { desc: 'Summons void rifts that damage player' },
      reality_tear: { damage: 3.0, windup: 120, desc: 'Screen-wide unavoidable (must parry)' },
    },
  },
  
  FLAME_WYRM: {
    name: 'FLAME WYRM',
    title: 'Serpent of the Inferno',
    personality: 'aggressive_fast', // Quick, relentless attacks
    hp: 22000, damage: 8, speed: 5,
    color: '#f97316', secondColor: '#c2410c', enrageColor: '#fbbf24',
    moveStyle: 'slither', // Quick darting movements
    idleAnim: 'coil', // Coiled, ready to strike
    phases: [
      { hp: 1.0, attacks: ['bite', 'fire_breath'], aggression: 0.5, name: 'WARMING' },
      { hp: 0.65, attacks: ['bite', 'fire_breath', 'tail_sweep', 'flame_dash'], aggression: 0.7, name: 'IGNITED' },
      { hp: 0.3, attacks: ['bite_combo', 'inferno', 'flame_dash', 'eruption'], aggression: 0.95, name: 'INFERNO' },
    ],
    attacks: {
      bite: { damage: 0.8, range: 150, windup: 15, recovery: 20, desc: 'Quick snap' },
      fire_breath: { damage: 0.4, duration: 60, range: 400, windup: 30, desc: 'Continuous flame cone' },
      tail_sweep: { damage: 1.0, range: 250, windup: 25, recovery: 35, desc: 'Wide sweep behind' },
      flame_dash: { damage: 1.2, speed: 25, windup: 20, recovery: 30, desc: 'Charges through player' },
      bite_combo: { damage: 0.6, hits: 5, windup: 10, recovery: 40, desc: 'Rapid 5-bite combo' },
      inferno: { damage: 0.3, duration: 180, desc: 'Arena fills with fire patches' },
      eruption: { damage: 1.5, count: 6, windup: 40, desc: 'Fire pillars from ground' },
    },
  },
  
  FROST_QUEEN: {
    name: 'FROST QUEEN',
    title: 'Sovereign of Eternal Winter',
    personality: 'tactical_defensive', // Calculated, uses terrain
    hp: 24000, damage: 10, speed: 3.5,
    color: '#06b6d4', secondColor: '#0e7490', enrageColor: '#f0f9ff',
    moveStyle: 'glide', // Elegant skating motion
    idleAnim: 'regal', // Stands regally with ice aura
    phases: [
      { hp: 1.0, attacks: ['ice_lance', 'frost_barrier'], aggression: 0.3, name: 'DISDAIN' },
      { hp: 0.7, attacks: ['ice_lance', 'blizzard', 'ice_pillars'], aggression: 0.5, name: 'ATTENTION' },
      { hp: 0.4, attacks: ['ice_combo', 'blizzard', 'frozen_throne', 'mirror_image'], aggression: 0.7, name: 'WRATH' },
      { hp: 0.15, attacks: ['absolute_zero', 'ice_storm', 'shatter'], aggression: 1.0, name: 'ABSOLUTE ZERO' },
    ],
    attacks: {
      ice_lance: { damage: 1.0, speed: 18, windup: 25, recovery: 30, desc: 'Precise ice projectile' },
      frost_barrier: { duration: 120, desc: 'Creates ice wall, blocks attacks' },
      blizzard: { damage: 0.2, duration: 180, slowAmount: 0.5, desc: 'Slows player movement' },
      ice_pillars: { damage: 1.2, count: 4, windup: 35, desc: 'Pillars erupt from ground' },
      ice_combo: { damage: 0.7, hits: 4, windup: 20, recovery: 50, desc: 'Elegant 4-strike combo' },
      frozen_throne: { duration: 90, desc: 'Creates ice platform, rains projectiles' },
      mirror_image: { count: 2, duration: 180, desc: 'Creates 2 illusions' },
      absolute_zero: { damage: 2.5, windup: 80, desc: 'Freezes arena center' },
      ice_storm: { damage: 0.4, duration: 120, desc: 'Icicles rain from above' },
      shatter: { damage: 1.8, range: 300, windup: 10, desc: 'Instant close-range burst' },
    },
  },
};

// ============ RAID BOSSES (Class Boss Battle - Kahoot Style) ============
const RAID_BOSSES = {
  WORLD_SERPENT: {
    name: 'WORLD SERPENT',
    title: 'J√∂rmungandr',
    hp: 50000, // High HP for class battle
    color: '#06b6d4', secondColor: '#0e7490',
    phases: [
      { hp: 1.0, name: 'SLUMBER' },
      { hp: 0.75, name: 'AWAKENING' },
      { hp: 0.50, name: 'WRATH' },
      { hp: 0.25, name: 'RAGNAROK' },
    ],
  },
  TITAN_COLOSSUS: {
    name: 'TITAN COLOSSUS',
    title: 'Guardian of Ages',
    hp: 60000,
    color: '#a78bfa', secondColor: '#6366f1',
    phases: [
      { hp: 1.0, name: 'DORMANT' },
      { hp: 0.70, name: 'RISING' },
      { hp: 0.40, name: 'FURY' },
      { hp: 0.15, name: 'APOCALYPSE' },
    ],
  },
  STORM_DRAGON: {
    name: 'STORM DRAGON',
    title: 'Tempest Incarnate',
    hp: 40000,
    color: '#fbbf24', secondColor: '#f97316',
    phases: [
      { hp: 1.0, name: 'CALM' },
      { hp: 0.65, name: 'WINDS' },
      { hp: 0.35, name: 'HURRICANE' },
      { hp: 0.10, name: 'DEVASTATION' },
    ],
  },
};

// ============ RAID BATTLE SYSTEM (Kahoot-Style Class Boss) ============
const RaidBattle = {
  active: false,
  boss: null,
  bossKey: 'WORLD_SERPENT',
  hp: 0,
  maxHp: 0,
  phase: 0,
  
  // Question state
  currentQuestion: null,
  questionTimer: 30,
  questionTimerMax: 30,
  questionIndex: 0,
  totalQuestions: 15,
  
  // Student responses (simulated multiplayer)
  responses: [],
  studentCount: 0,
  correctCount: 0,
  
  // Attack animation state
  attackState: 'idle', // 'idle', 'normal', 'special', 'kamehameha'
  attackTimer: 0,
  attackDamage: 0,
  
  // Render state
  shakeAmount: 0,
  tintColor: null,
  tintAlpha: 0,
  
  init(bossKey, questionCount, timerSeconds, studentCount) {
    this.bossKey = bossKey || 'WORLD_SERPENT';
    this.boss = RAID_BOSSES[this.bossKey];
    this.maxHp = this.boss.hp;
    this.hp = this.maxHp;
    this.phase = 0;
    this.questionIndex = 0;
    this.totalQuestions = questionCount || 15;
    this.questionTimerMax = timerSeconds || 30;
    this.studentCount = studentCount || 1;
    this.active = true;
    this.responses = [];
    this.attackState = 'idle';
    this.attackTimer = 0;
    this.currentQuestion = null;
    
    // Start first question after intro
    setTimeout(() => this.nextQuestion(), 3000);
  },
  
  nextQuestion() {
    if (!this.active) return;
    if (this.questionIndex >= this.totalQuestions) {
      this.endBattle();
      return;
    }
    
    // Get question from pool
    const pool = [...QUESTIONS, ...customQuestions];
    const selectedStandards = SessionConfig.selectedStandards;
    let filtered = pool;
    if (selectedStandards.length > 0) {
      filtered = pool.filter(q => selectedStandards.includes(q.standard));
    }
    if (filtered.length === 0) filtered = pool;
    
    this.currentQuestion = filtered[Math.floor(Math.random() * filtered.length)];
    this.questionTimer = this.questionTimerMax * 60; // Convert to frames
    this.responses = [];
    this.questionIndex++;
  },
  
  submitAnswer(studentId, answerIndex, responseTime) {
    // Check if already answered
    if (this.responses.find(r => r.studentId === studentId)) return;
    
    const correct = answerIndex === this.currentQuestion.correct;
    this.responses.push({ studentId, answerIndex, correct, responseTime });
    
    // Check if all students answered
    if (this.responses.length >= this.studentCount) {
      this.evaluateResponses();
    }
  },
  
  evaluateResponses() {
    if (!this.currentQuestion) return;
    
    this.correctCount = this.responses.filter(r => r.correct).length;
    const percentage = (this.correctCount / Math.max(1, this.studentCount)) * 100;
    
    // Determine attack type based on performance
    if (percentage >= 80) {
      this.triggerAttack('kamehameha', this.maxHp * 0.08); // 8% damage
    } else if (percentage >= 70) {
      this.triggerAttack('special', this.maxHp * 0.05); // 5% damage
    } else if (percentage >= 60) {
      this.triggerAttack('normal', this.maxHp * 0.03); // 3% damage
    } else {
      // Boss attacks class (visual only)
      this.triggerBossAttack();
    }
    
    this.currentQuestion = null;
  },
  
  triggerAttack(type, damage) {
    this.attackState = type;
    this.attackTimer = type === 'kamehameha' ? 180 : type === 'special' ? 120 : 60;
    this.attackDamage = damage;
    this.shakeAmount = type === 'kamehameha' ? 30 : type === 'special' ? 15 : 5;
    
    // Apply damage after animation peak
    const delay = type === 'kamehameha' ? 2000 : type === 'special' ? 1500 : 800;
    setTimeout(() => {
      this.hp = Math.max(0, this.hp - damage);
      this.checkPhase();
      if (this.hp <= 0) {
        this.victory();
      } else {
        // Next question after attack
        setTimeout(() => this.nextQuestion(), 1500);
      }
    }, delay);
  },
  
  triggerBossAttack() {
    this.attackState = 'boss_attack';
    this.attackTimer = 90;
    this.shakeAmount = 20;
    this.tintColor = '#ef4444';
    this.tintAlpha = 0.3;
    
    setTimeout(() => {
      this.attackState = 'idle';
      this.nextQuestion();
    }, 2000);
  },
  
  checkPhase() {
    const hpPercent = this.hp / this.maxHp;
    const phases = this.boss.phases;
    for (let i = phases.length - 1; i >= 0; i--) {
      if (hpPercent <= phases[i].hp && this.phase !== i) {
        this.phase = i;
        this.shakeAmount = 40;
        break;
      }
    }
  },
  
  victory() {
    this.active = false;
    this.attackState = 'victory';
    this.attackTimer = 300;
    // Show victory screen
  },
  
  endBattle() {
    this.active = false;
    // Show results
  },
  
  update() {
    if (!this.active) return;
    
    // Update question timer
    if (this.currentQuestion && this.questionTimer > 0) {
      this.questionTimer--;
      if (this.questionTimer <= 0) {
        this.evaluateResponses();
      }
    }
    
    // Update attack animation
    if (this.attackTimer > 0) {
      this.attackTimer--;
      if (this.attackTimer <= 0) {
        this.attackState = 'idle';
      }
    }
    
    // Decay effects
    if (this.shakeAmount > 0) this.shakeAmount *= 0.95;
    if (this.tintAlpha > 0) this.tintAlpha *= 0.98;
  },
  
  render(ctx) {
    if (!this.active && this.attackState !== 'victory') return;
    
    const W = 1200, H = 700;
    
    // Apply shake
    ctx.save();
    if (this.shakeAmount > 1) {
      ctx.translate(
        (Math.random() - 0.5) * this.shakeAmount,
        (Math.random() - 0.5) * this.shakeAmount
      );
    }
    
    // Background
    const bgGrad = ctx.createLinearGradient(0, 0, 0, H);
    bgGrad.addColorStop(0, '#0a0a1a');
    bgGrad.addColorStop(1, '#1a1a3a');
    ctx.fillStyle = bgGrad;
    ctx.fillRect(0, 0, W, H);
    
    // Render boss
    this.renderRaidBoss(ctx, W / 2, 280);
    
    // Render attack animation
    this.renderAttack(ctx, W / 2, 400);
    
    // UI
    this.renderUI(ctx, W, H);
    
    // Tint overlay
    if (this.tintAlpha > 0.01) {
      ctx.fillStyle = this.tintColor || '#ffffff';
      ctx.globalAlpha = this.tintAlpha;
      ctx.fillRect(0, 0, W, H);
      ctx.globalAlpha = 1;
    }
    
    ctx.restore();
  },
  
  renderRaidBoss(ctx, x, y) {
    const boss = this.boss;
    const hpPercent = this.hp / this.maxHp;
    const pulse = Math.sin(Date.now() * 0.003) * 10;
    
    ctx.save();
    ctx.translate(x, y);
    
    // Aura based on phase
    const auraSize = 200 + (1 - hpPercent) * 100 + pulse;
    const auraGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, auraSize);
    auraGrad.addColorStop(0, boss.color + '40');
    auraGrad.addColorStop(0.5, boss.secondColor + '20');
    auraGrad.addColorStop(1, 'transparent');
    ctx.fillStyle = auraGrad;
    ctx.beginPath();
    ctx.arc(0, 0, auraSize, 0, Math.PI * 2);
    ctx.fill();
    
    // Boss body (simplified serpent/dragon shape)
    ctx.fillStyle = boss.color;
    ctx.shadowColor = boss.color;
    ctx.shadowBlur = 30;
    
    // Main body
    ctx.beginPath();
    ctx.ellipse(0, 0, 80, 120, 0, 0, Math.PI * 2);
    ctx.fill();
    
    // Head
    ctx.beginPath();
    ctx.ellipse(0, -100, 50, 40, 0, 0, Math.PI * 2);
    ctx.fill();
    
    // Eyes (glow more at low HP)
    ctx.fillStyle = hpPercent < 0.3 ? '#ef4444' : '#fff';
    ctx.shadowColor = hpPercent < 0.3 ? '#ef4444' : '#fff';
    ctx.beginPath();
    ctx.arc(-20, -110, 8, 0, Math.PI * 2);
    ctx.arc(20, -110, 8, 0, Math.PI * 2);
    ctx.fill();
    
    ctx.shadowBlur = 0;
    ctx.restore();
  },
  
  renderAttack(ctx, x, y) {
    if (this.attackState === 'idle') return;
    
    const progress = 1 - (this.attackTimer / (this.attackState === 'kamehameha' ? 180 : this.attackState === 'special' ? 120 : 60));
    
    ctx.save();
    ctx.translate(x, y);
    
    if (this.attackState === 'kamehameha') {
      // KAMEHAMEHA - DBZ style beam
      const beamWidth = 60 + progress * 100;
      const beamLength = progress * 500;
      
      // Charging orb
      if (progress < 0.4) {
        const chargeSize = progress * 2.5 * 80;
        const chargeGrad = ctx.createRadialGradient(0, 200, 0, 0, 200, chargeSize);
        chargeGrad.addColorStop(0, '#fff');
        chargeGrad.addColorStop(0.3, '#60a5fa');
        chargeGrad.addColorStop(0.6, '#3b82f6');
        chargeGrad.addColorStop(1, 'transparent');
        ctx.fillStyle = chargeGrad;
        ctx.beginPath();
        ctx.arc(0, 200, chargeSize, 0, Math.PI * 2);
        ctx.fill();
      }
      
      // Main beam
      if (progress > 0.3) {
        const beamProg = (progress - 0.3) / 0.7;
        ctx.save();
        
        // Beam glow
        ctx.shadowColor = '#3b82f6';
        ctx.shadowBlur = 50;
        
        // Beam gradient
        const beamGrad = ctx.createLinearGradient(0, 200, 0, 200 - beamLength * beamProg);
        beamGrad.addColorStop(0, '#fff');
        beamGrad.addColorStop(0.2, '#60a5fa');
        beamGrad.addColorStop(1, '#1d4ed8');
        ctx.fillStyle = beamGrad;
        
        // Draw beam
        ctx.beginPath();
        ctx.moveTo(-beamWidth/2, 200);
        ctx.lineTo(-beamWidth/3, 200 - beamLength * beamProg);
        ctx.lineTo(beamWidth/3, 200 - beamLength * beamProg);
        ctx.lineTo(beamWidth/2, 200);
        ctx.closePath();
        ctx.fill();
        
        // Impact flash at boss
        if (beamProg > 0.5) {
          const impactGrad = ctx.createRadialGradient(0, -100, 0, 0, -100, 150);
          impactGrad.addColorStop(0, '#fff');
          impactGrad.addColorStop(0.5, '#60a5fa80');
          impactGrad.addColorStop(1, 'transparent');
          ctx.fillStyle = impactGrad;
          ctx.beginPath();
          ctx.arc(0, -100, 150 * (beamProg - 0.5) * 2, 0, Math.PI * 2);
          ctx.fill();
        }
        
        ctx.restore();
      }
      
    } else if (this.attackState === 'special') {
      // SPECIAL - Multiple energy slashes
      const slashCount = 5;
      for (let i = 0; i < slashCount; i++) {
        const slashProg = Math.max(0, Math.min(1, (progress * slashCount - i) / 1));
        if (slashProg <= 0) continue;
        
        const angle = (i - 2) * 0.3;
        ctx.save();
        ctx.rotate(angle);
        
        ctx.strokeStyle = `rgba(168, 85, 247, ${1 - slashProg})`;
        ctx.lineWidth = 8 * (1 - slashProg * 0.5);
        ctx.shadowColor = '#a855f7';
        ctx.shadowBlur = 20;
        
        ctx.beginPath();
        ctx.moveTo(0, 200 - slashProg * 400);
        ctx.lineTo(0, 200 - slashProg * 500);
        ctx.stroke();
        
        ctx.restore();
      }
      
    } else if (this.attackState === 'normal') {
      // NORMAL - Single energy burst
      const burstSize = progress * 200;
      const burstGrad = ctx.createRadialGradient(0, 50, 0, 0, 50, burstSize);
      burstGrad.addColorStop(0, '#fbbf24');
      burstGrad.addColorStop(0.5, '#f97316');
      burstGrad.addColorStop(1, 'transparent');
      ctx.fillStyle = burstGrad;
      ctx.globalAlpha = 1 - progress;
      ctx.beginPath();
      ctx.arc(0, 50 - progress * 200, burstSize, 0, Math.PI * 2);
      ctx.fill();
      ctx.globalAlpha = 1;
      
    } else if (this.attackState === 'boss_attack') {
      // Boss attacks class - red danger zone
      const dangerSize = progress * 400;
      ctx.fillStyle = `rgba(239, 68, 68, ${0.3 * (1 - progress)})`;
      ctx.beginPath();
      ctx.arc(0, 100, dangerSize, 0, Math.PI * 2);
      ctx.fill();
    }
    
    ctx.restore();
  },
  
  renderUI(ctx, W, H) {
    // Boss HP bar
    const barW = 600, barH = 30;
    const barX = (W - barW) / 2, barY = 30;
    const hpPercent = this.hp / this.maxHp;
    
    // Background
    ctx.fillStyle = '#1a1a2e';
    ctx.fillRect(barX - 2, barY - 2, barW + 4, barH + 4);
    
    // HP fill
    const hpGrad = ctx.createLinearGradient(barX, barY, barX + barW * hpPercent, barY);
    hpGrad.addColorStop(0, this.boss.color);
    hpGrad.addColorStop(1, this.boss.secondColor);
    ctx.fillStyle = hpGrad;
    ctx.fillRect(barX, barY, barW * hpPercent, barH);
    
    // Boss name
    ctx.fillStyle = '#fff';
    ctx.font = 'bold 24px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText(this.boss.name, W / 2, barY - 8);
    
    // Phase name
    const phaseName = this.boss.phases[this.phase]?.name || '';
    ctx.font = '16px sans-serif';
    ctx.fillStyle = this.boss.color;
    ctx.fillText(phaseName, W / 2, barY + barH + 20);
    
    // HP text
    ctx.fillStyle = '#fff';
    ctx.font = 'bold 14px sans-serif';
    ctx.fillText(Math.round(this.hp).toLocaleString() + ' / ' + this.maxHp.toLocaleString(), W / 2, barY + barH / 2 + 5);
    
    // Question display
    if (this.currentQuestion) {
      this.renderQuestion(ctx, W, H);
    }
    
    // Performance indicator
    if (this.attackState !== 'idle' && this.correctCount > 0) {
      const percentage = Math.round((this.correctCount / this.studentCount) * 100);
      ctx.font = 'bold 32px sans-serif';
      ctx.fillStyle = percentage >= 80 ? '#22c55e' : percentage >= 70 ? '#fbbf24' : percentage >= 60 ? '#f97316' : '#ef4444';
      ctx.fillText(percentage + '% CORRECT!', W / 2, H - 50);
    }
  },
  
  renderQuestion(ctx, W, H) {
    const q = this.currentQuestion;
    const timerPercent = this.questionTimer / (this.questionTimerMax * 60);
    
    // Question box
    const boxW = 800, boxH = 250;
    const boxX = (W - boxW) / 2, boxY = H - boxH - 30;
    
    ctx.fillStyle = 'rgba(26, 26, 46, 0.95)';
    ctx.strokeStyle = timerPercent < 0.25 ? '#ef4444' : '#6366f1';
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.roundRect(boxX, boxY, boxW, boxH, 10);
    ctx.fill();
    ctx.stroke();
    
    // Timer bar
    ctx.fillStyle = timerPercent < 0.25 ? '#ef4444' : '#6366f1';
    ctx.fillRect(boxX, boxY, boxW * timerPercent, 5);
    
    // Question number
    ctx.fillStyle = '#888';
    ctx.font = '14px sans-serif';
    ctx.textAlign = 'left';
    ctx.fillText(`Question ${this.questionIndex}/${this.totalQuestions}`, boxX + 15, boxY + 25);
    
    // Timer
    ctx.textAlign = 'right';
    const timerSec = Math.ceil(this.questionTimer / 60);
    ctx.fillStyle = timerPercent < 0.25 ? '#ef4444' : '#fff';
    ctx.fillText(`${timerSec}s`, boxX + boxW - 15, boxY + 25);
    
    // Question text
    ctx.fillStyle = '#fff';
    ctx.font = 'bold 20px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText(q.q, W / 2, boxY + 60);
    
    // Answer options (2x2 grid)
    const optW = 350, optH = 50;
    const optGap = 20;
    const colors = ['#ef4444', '#3b82f6', '#22c55e', '#fbbf24'];
    
    for (let i = 0; i < 4; i++) {
      const col = i % 2;
      const row = Math.floor(i / 2);
      const ox = boxX + 40 + col * (optW + optGap);
      const oy = boxY + 90 + row * (optH + 10);
      
      ctx.fillStyle = colors[i];
      ctx.beginPath();
      ctx.roundRect(ox, oy, optW, optH, 8);
      ctx.fill();
      
      ctx.fillStyle = '#fff';
      ctx.font = 'bold 16px sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText(q.a[i], ox + optW / 2, oy + optH / 2 + 6);
    }
    
    // Responses count
    ctx.fillStyle = '#888';
    ctx.font = '14px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText(`Responses: ${this.responses.length}/${this.studentCount}`, W / 2, boxY + boxH - 15);
  }
};

// ============ QUESTION BANK (Demo - 40 questions across 4 levels) ============
const QUESTIONS = [
  // Level 1 - Basic Knowledge (10 questions)
  { id: 1, level: 1, standard: 'SS.7.CG.1.1', q: 'Where was democracy born?', a: ['Greece', 'Rome', 'Egypt', 'Persia'], correct: 0 },
  { id: 2, level: 1, standard: 'SS.7.CG.2.1', q: 'How many amendments in the Bill of Rights?', a: ['10', '5', '15', '27'], correct: 0 },
  { id: 3, level: 1, standard: 'SS.7.CG.3.1', q: 'Which branch makes laws?', a: ['Legislative', 'Executive', 'Judicial', 'Federal'], correct: 0 },
  { id: 13, level: 1, standard: 'SS.7.CG.1.1', q: 'Who wrote the Declaration of Independence?', a: ['Thomas Jefferson', 'George Washington', 'Ben Franklin', 'John Adams'], correct: 0 },
  { id: 14, level: 1, standard: 'SS.7.CG.2.1', q: 'What is the supreme law of the land?', a: ['The Constitution', 'The President', 'State laws', 'City laws'], correct: 0 },
  { id: 15, level: 1, standard: 'SS.7.CG.3.1', q: 'How many senators does each state have?', a: ['2', '4', '6', 'Depends on population'], correct: 0 },
  { id: 16, level: 1, standard: 'SS.7.CG.1.1', q: 'What year was the Constitution written?', a: ['1787', '1776', '1791', '1800'], correct: 0 },
  { id: 17, level: 1, standard: 'SS.7.CG.2.1', q: 'The 1st Amendment protects which right?', a: ['Free speech', 'Bear arms', 'Fair trial', 'No quartering'], correct: 0 },
  { id: 18, level: 1, standard: 'SS.7.CG.3.1', q: 'Who is the Commander in Chief?', a: ['The President', 'Top General', 'Congress', 'Supreme Court'], correct: 0 },
  { id: 19, level: 1, standard: 'SS.7.CG.1.1', q: 'What are the first 10 amendments called?', a: ['Bill of Rights', 'Preamble', 'Articles', 'Federalist Papers'], correct: 0 },

  // Level 2 - Comprehension (10 questions)
  { id: 4, level: 2, standard: 'SS.7.CG.1.2', q: 'What did the Magna Carta limit?', a: ['King\'s power', 'Trade', 'Voting', 'Taxes'], correct: 0 },
  { id: 5, level: 2, standard: 'SS.7.CG.2.2', q: 'What is "due process"?', a: ['Fair legal treatment', 'Fast trials', 'No appeals', 'Jury only'], correct: 0 },
  { id: 6, level: 2, standard: 'SS.7.CG.3.2', q: 'How can Congress check the President?', a: ['Override veto', 'Fire them', 'Close courts', 'Start war'], correct: 0 },
  { id: 20, level: 2, standard: 'SS.7.CG.1.2', q: 'What is federalism?', a: ['Shared power between states and federal', 'President\'s power', 'King\'s power', 'Judge\'s power'], correct: 0 },
  { id: 21, level: 2, standard: 'SS.7.CG.2.2', q: 'What does "popular sovereignty" mean?', a: ['Power from the people', 'King rules', 'Judges rule', 'Military rule'], correct: 0 },
  { id: 22, level: 2, standard: 'SS.7.CG.3.2', q: 'What does the Executive Branch do?', a: ['Enforces laws', 'Makes laws', 'Interprets laws', 'Writes Constitution'], correct: 0 },
  { id: 23, level: 2, standard: 'SS.7.CG.1.2', q: 'Why was the Constitution written?', a: ['Replace weak Articles', 'Declare war', 'Tax people', 'Elect President'], correct: 0 },
  { id: 24, level: 2, standard: 'SS.7.CG.2.2', q: 'What is the purpose of the Preamble?', a: ['States Constitution\'s goals', 'Lists amendments', 'Names President', 'Declares war'], correct: 0 },
  { id: 25, level: 2, standard: 'SS.7.CG.3.2', q: 'What is a constitutional republic?', a: ['People elect representatives', 'King rules', 'Direct vote on all', 'No government'], correct: 0 },
  { id: 26, level: 2, standard: 'SS.7.CG.1.2', q: 'What inspired the Bill of Rights?', a: ['English Bill of Rights', 'Roman laws', 'Greek democracy', 'Egyptian rules'], correct: 0 },

  // Level 3 - Application (10 questions)
  { id: 7, level: 3, standard: 'SS.7.CG.1.3', q: 'Student suspended without hearing - which amendment?', a: ['14th', '1st', '2nd', '5th'], correct: 0 },
  { id: 8, level: 3, standard: 'SS.7.CG.2.3', q: 'Search without warrant violates which amendment?', a: ['4th', '1st', '6th', '8th'], correct: 0 },
  { id: 9, level: 3, standard: 'SS.7.CG.3.3', q: 'Who decides if a law is unconstitutional?', a: ['Supreme Court', 'President', 'Congress', 'States'], correct: 0 },
  { id: 27, level: 3, standard: 'SS.7.CG.1.3', q: 'Police enter home without warrant - which right violated?', a: ['4th Amendment', '1st Amendment', '2nd Amendment', '5th Amendment'], correct: 0 },
  { id: 28, level: 3, standard: 'SS.7.CG.2.3', q: 'Cruel punishment violates which amendment?', a: ['8th', '4th', '1st', '6th'], correct: 0 },
  { id: 29, level: 3, standard: 'SS.7.CG.3.3', q: 'President vetoes bill - what can Congress do?', a: ['Override with 2/3 vote', 'Nothing', 'Sue President', 'Call election'], correct: 0 },
  { id: 30, level: 3, standard: 'SS.7.CG.1.3', q: 'School bans student newspaper - which amendment issue?', a: ['1st - Free press', '4th - Search', '5th - Self-incrimination', '6th - Trial'], correct: 0 },
  { id: 31, level: 3, standard: 'SS.7.CG.2.3', q: 'Denied lawyer in trial - which amendment violated?', a: ['6th', '1st', '4th', '8th'], correct: 0 },
  { id: 32, level: 3, standard: 'SS.7.CG.3.3', q: 'Who confirms Supreme Court justices?', a: ['Senate', 'House', 'President alone', 'States'], correct: 0 },
  { id: 33, level: 3, standard: 'SS.7.CG.1.3', q: 'State law conflicts with federal law - which wins?', a: ['Federal law', 'State law', 'Whoever passed first', 'Neither'], correct: 0 },

  // Level 4 - Analysis (10 questions)
  { id: 10, level: 4, standard: 'SS.7.CG.1.4', q: 'Why did direct democracy work in Athens but not now?', a: ['Population size', 'Technology', 'Language', 'Climate'], correct: 0 },
  { id: 11, level: 4, standard: 'SS.7.CG.2.4', q: 'Can free speech ever be limited?', a: ['Yes, if it causes harm', 'Never', 'Only in war', 'Only online'], correct: 0 },
  { id: 12, level: 4, standard: 'SS.7.CG.3.4', q: 'Why is the legislature bicameral?', a: ['Balance big/small states', 'Save money', 'Work faster', 'Tradition'], correct: 0 },
  { id: 34, level: 4, standard: 'SS.7.CG.1.4', q: 'Why do we have separation of powers?', a: ['Prevent tyranny', 'Save money', 'Speed up laws', 'Honor tradition'], correct: 0 },
  { id: 35, level: 4, standard: 'SS.7.CG.2.4', q: 'Why is an independent judiciary important?', a: ['Fair rulings without pressure', 'Faster trials', 'Cheaper courts', 'Popular decisions'], correct: 0 },
  { id: 36, level: 4, standard: 'SS.7.CG.3.4', q: 'Why does the Constitution need to be amendable?', a: ['Society changes over time', 'Mistakes need fixing', 'States want changes', 'Tradition'], correct: 0 },
  { id: 37, level: 4, standard: 'SS.7.CG.1.4', q: 'Why did Founders fear direct democracy?', a: ['Mob rule / tyranny of majority', 'Too slow', 'Too expensive', 'Foreign influence'], correct: 0 },
  { id: 38, level: 4, standard: 'SS.7.CG.2.4', q: 'Why is the right to vote fundamental?', a: ['Citizens control government', 'Tradition', 'Convenience', 'Economic reasons'], correct: 0 },
  { id: 39, level: 4, standard: 'SS.7.CG.3.4', q: 'Why do we have an Electoral College?', a: ['Balance state power', 'Count votes faster', 'Reduce fraud', 'Save money'], correct: 0 },
  { id: 40, level: 4, standard: 'SS.7.CG.1.4', q: 'How does checks and balances protect liberty?', a: ['No branch has absolute power', 'Faster laws', 'Less taxes', 'More military'], correct: 0 },
];

// Custom question storage (teacher uploads)
let customQuestions = [];

// ============ SUBJECT SELECTION ============
const SubjectFilter = {
  enabled: false,
  selectedStandards: new Set(),
  
  // Available standards
  standards: [
    { id: 'SS.7.CG.1', name: 'Origins & Purposes', desc: 'Constitutional foundations' },
    { id: 'SS.7.CG.2', name: 'Rights & Responsibilities', desc: 'Bill of Rights & duties' },
    { id: 'SS.7.CG.3', name: 'Government Structure', desc: 'Branches & checks' },
  ],
  
  toggle(standardId) {
    if (this.selectedStandards.has(standardId)) {
      this.selectedStandards.delete(standardId);
    } else {
      this.selectedStandards.add(standardId);
    }
    this.enabled = this.selectedStandards.size > 0;
  },
  
  isSelected(standardId) {
    return this.selectedStandards.has(standardId);
  },
  
  filterQuestions(questions) {
    if (!this.enabled || this.selectedStandards.size === 0) return questions;
    return questions.filter(q => {
      const stdBase = q.standard.substring(0, 10); // e.g., SS.7.CG.1
      return this.selectedStandards.has(stdBase);
    });
  },
  
  reset() {
    this.selectedStandards.clear();
    this.enabled = false;
  }
};

// ============ STUDY MODE ============
const StudyMode = {
  missedQuestions: [],
  allAnsweredQuestions: [],
  active: false,
  currentIndex: 0,
  showingAnswer: false,
  
  trackQuestion(question, wasCorrect, playerAnswer) {
    this.allAnsweredQuestions.push({
      question: question,
      correct: wasCorrect,
      playerAnswer: playerAnswer,
      correctAnswer: question.correct,
      timestamp: Date.now()
    });
    
    if (!wasCorrect) {
      // Check if already in missed
      if (!this.missedQuestions.find(q => q.question.id === question.id)) {
        this.missedQuestions.push({
          question: question,
          playerAnswer: playerAnswer,
          attempts: 1
        });
      } else {
        // Increment attempts
        const existing = this.missedQuestions.find(q => q.question.id === question.id);
        if (existing) existing.attempts++;
      }
    } else {
      // Remove from missed if answered correctly
      this.missedQuestions = this.missedQuestions.filter(q => q.question.id !== question.id);
    }
  },
  
  start() {
    if (this.missedQuestions.length === 0) return false;
    this.active = true;
    this.currentIndex = 0;
    this.showingAnswer = false;
    return true;
  },
  
  next() {
    if (this.showingAnswer) {
      this.showingAnswer = false;
      this.currentIndex++;
      if (this.currentIndex >= this.missedQuestions.length) {
        this.active = false;
        return false;
      }
    } else {
      this.showingAnswer = true;
    }
    return true;
  },
  
  getCurrentQuestion() {
    if (this.currentIndex >= this.missedQuestions.length) return null;
    return this.missedQuestions[this.currentIndex];
  },
  
  render(ctx) {
    if (!this.active) return;
    
    const item = this.getCurrentQuestion();
    if (!item) return;
    
    const q = item.question;
    
    // Background
    ctx.fillStyle = 'rgba(0,0,0,0.95)';
    ctx.fillRect(0, 0, 1200, 700);
    
    // Header
    ctx.fillStyle = '#22d3ee';
    ctx.font = 'bold 36px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText('üìö STUDY MODE', 600, 60);
    
    ctx.fillStyle = '#888';
    ctx.font = '18px sans-serif';
    ctx.fillText(`Question ${this.currentIndex + 1} of ${this.missedQuestions.length}`, 600, 95);
    
    // Question box
    ctx.fillStyle = 'rgba(30, 30, 60, 0.95)';
    ctx.strokeStyle = '#6366f1';
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.roundRect(100, 120, 1000, 450, 20);
    ctx.fill();
    ctx.stroke();
    
    // Standard
    ctx.fillStyle = '#6366f1';
    ctx.font = 'bold 16px sans-serif';
    ctx.textAlign = 'left';
    ctx.fillText(q.standard + ' | Level ' + q.level, 130, 160);
    
    // Question
    ctx.fillStyle = '#fff';
    ctx.font = '24px sans-serif';
    ctx.textAlign = 'center';
    QuizSystem.wrapText(ctx, q.q, 600, 220, 900, 32);
    
    // Answers
    const labels = ['A', 'B', 'C', 'D'];
    q.a.forEach((ans, i) => {
      const y = 280 + i * 55;
      let bgColor = 'rgba(50, 50, 80, 0.8)';
      let borderColor = '#4b5563';
      
      if (this.showingAnswer) {
        if (i === q.correct) {
          bgColor = 'rgba(34, 197, 94, 0.6)';
          borderColor = '#22c55e';
        } else if (i === item.playerAnswer) {
          bgColor = 'rgba(239, 68, 68, 0.6)';
          borderColor = '#ef4444';
        }
      }
      
      ctx.fillStyle = bgColor;
      ctx.strokeStyle = borderColor;
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.roundRect(200, y, 800, 50, 10);
      ctx.fill();
      ctx.stroke();
      
      ctx.fillStyle = '#6366f1';
      ctx.font = 'bold 20px sans-serif';
      ctx.textAlign = 'left';
      ctx.fillText(labels[i], 220, y + 32);
      
      ctx.fillStyle = '#fff';
      ctx.font = '18px sans-serif';
      ctx.fillText(ans, 260, y + 32);
    });
    
    // Instructions
    ctx.fillStyle = this.showingAnswer ? '#22c55e' : '#fbbf24';
    ctx.font = 'bold 20px sans-serif';
    ctx.textAlign = 'center';
    
    if (this.showingAnswer) {
      ctx.fillText('‚úì Correct answer highlighted in green', 600, 520);
    } else {
      ctx.fillText('Your answer was: ' + (item.playerAnswer >= 0 ? labels[item.playerAnswer] : 'No answer'), 600, 520);
    }
    
    // Continue button
    const isMobile = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);
    ctx.fillStyle = '#6366f1';
    ctx.beginPath();
    ctx.roundRect(450, 560, 300, 50, 12);
    ctx.fill();
    ctx.fillStyle = '#fff';
    ctx.font = 'bold 20px sans-serif';
    ctx.fillText(this.showingAnswer ? 
      (this.currentIndex < this.missedQuestions.length - 1 ? 'NEXT QUESTION' : 'FINISH REVIEW') : 
      'SHOW ANSWER', 600, 592);
  },
  
  handleClick(x, y) {
    if (!this.active) return false;
    
    // Continue button
    if (x > 450 && x < 750 && y > 560 && y < 610) {
      this.next();
      playSound('menu');
      if (typeof Haptics !== 'undefined') Haptics.light();
      return true;
    }
    return false;
  },
  
  reset() {
    this.missedQuestions = [];
    this.allAnsweredQuestions = [];
    this.active = false;
    this.currentIndex = 0;
    this.showingAnswer = false;
  },
  
  getStats() {
    const total = this.allAnsweredQuestions.length;
    const correct = this.allAnsweredQuestions.filter(q => q.correct).length;
    return {
      total,
      correct,
      missed: this.missedQuestions.length,
      accuracy: total > 0 ? Math.round(correct / total * 100) : 0
    };
  }
};

// ============ QUIZ SYSTEM ============
const QuizSystem = {
  active: false,
  currentQuestion: null,
  questionTimer: 0,
  maxTime: 20 * 60, // 20 seconds at 60fps
  answered: false,
  selectedAnswer: -1,
  showResult: false,
  resultTimer: 0,
  
  // Adaptive testing
  currentLevel: 2, // Start at level 2
  questionsAnswered: 0,
  correctInWindow: 0,
  windowSize: 4,
  recentResults: [],
  usedQuestions: new Set(),
  
  // Stats
  totalCorrect: 0,
  totalWrong: 0,
  standardsPerformance: {},
  questionsAskedThisGame: [],
  
  // Standard exhaustion tracking
  coveredStandards: new Set(),
  requiredStandards: new Set(),
  
  // Combat integration timing
  combatTimer: 0,
  questionInterval: 30 * 60,
  bossHPTriggers: [0.75, 0.50, 0.25],
  bossHPTriggered: new Set(),
  minQuestionsPerBattle: 5,
  maxQuestionsPerBattle: 15,
  
  // === NEW: HINT SYSTEM ===
  hintUsed: false,
  eliminatedOptions: [],
  hintCost: 25, // Mana cost for hint
  
  // === NEW: STREAK SYSTEM ===
  correctStreak: 0,
  maxStreak: 0,
  
  // === DIFFICULTY-SCALED REWARDS ===
  getRewards(level, correct, usedHint) {
    // Base rewards scale with question difficulty
    const baseHeal = 15 + level * 5;       // 20-35% heal
    const baseDamage = 75 + level * 25;    // 100-175 damage
    const baseMana = 15 + level * 5;       // 20-35 mana
    const baseUlt = 15 + level * 5;        // 20-35 ult charge
    
    // Streak bonus
    const streakMult = 1 + Math.min(this.correctStreak, 5) * 0.1; // Up to 50% bonus
    
    // Hint penalty
    const hintMult = usedHint ? 0.5 : 1;
    
    return {
      heal: Math.round(baseHeal * streakMult * hintMult),
      damage: Math.round(baseDamage * streakMult * hintMult),
      mana: Math.round(baseMana * streakMult * hintMult),
      ult: Math.round(baseUlt * streakMult * hintMult),
      streakBonus: this.correctStreak >= 3
    };
  },
  
  reset() {
    this.active = false;
    this.currentQuestion = null;
    this.answered = false;
    this.selectedAnswer = -1;
    this.showResult = false;
    this.currentLevel = 2;
    this.questionsAnswered = 0;
    this.correctInWindow = 0;
    this.recentResults = [];
    this.usedQuestions.clear();
    this.totalCorrect = 0;
    this.totalWrong = 0;
    this.standardsPerformance = {};
    this.combatTimer = 0;
    this.questionsAskedThisGame = [];
    this.bossHPTriggered = new Set();
    this.coveredStandards = new Set();
    this.postQuizCooldown = 0;
    this.hintUsed = false;
    this.eliminatedOptions = [];
    this.correctStreak = 0;
    this.maxStreak = 0;
    this.requiredStandards = new Set(this.getQuestionPool().map(q => q.standard));
  },
  
  // === USE HINT (eliminate 1 wrong answer) ===
  useHint() {
    if (this.hintUsed || this.answered || !this.active) return false;
    if (!game || game.player.mana < this.hintCost) {
      spawnDmgNum(game.player.x, game.player.y - 80, 'NOT ENOUGH MANA', 'hurt');
      return false;
    }
    
    // Spend mana
    game.player.mana -= this.hintCost;
    this.hintUsed = true;
    
    // Find a wrong answer to eliminate
    const wrongAnswers = [];
    for (let i = 0; i < 4; i++) {
      if (i !== this.currentQuestion.correct) {
        wrongAnswers.push(i);
      }
    }
    
    // Eliminate one random wrong answer
    if (wrongAnswers.length > 0) {
      const toEliminate = wrongAnswers[Math.floor(Math.random() * wrongAnswers.length)];
      this.eliminatedOptions.push(toEliminate);
      spawnDmgNum(game.player.x, game.player.y - 100, 'HINT USED!', 'special');
      playSound('menu');
    }
    
    return true;
  },
  
  // Check if all standards have been covered
  allStandardsCovered() {
    for (const std of this.requiredStandards) {
      if (!this.coveredStandards.has(std)) return false;
    }
    return true;
  },
  
  // Get uncovered standards
  getUncoveredStandards() {
    return [...this.requiredStandards].filter(s => !this.coveredStandards.has(s));
  },
  
  getQuestionPool() {
    // Combine built-in and custom questions
    let pool = [...QUESTIONS, ...customQuestions];
    
    // Apply subject filter if enabled
    if (typeof SubjectFilter !== 'undefined' && SubjectFilter.enabled) {
      pool = SubjectFilter.filterQuestions(pool);
    }
    
    return pool;
  },
  
  selectQuestion() {
    const pool = this.getQuestionPool();
    
    // Filter by level (allow +/- 1 level for variety)
    const levelRange = [
      Math.max(1, this.currentLevel - 1),
      Math.min(4, this.currentLevel + 1)
    ];
    
    let candidates = pool.filter(q => 
      q.level >= levelRange[0] && 
      q.level <= levelRange[1] && 
      !this.usedQuestions.has(q.id)
    );
    
    // STANDARD EXHAUSTION: Prioritize uncovered standards
    const uncoveredStandards = this.getUncoveredStandards();
    if (uncoveredStandards.length > 0) {
      const uncoveredCandidates = candidates.filter(q => uncoveredStandards.includes(q.standard));
      if (uncoveredCandidates.length > 0) {
        candidates = uncoveredCandidates;
      }
    }
    
    // Prefer current level
    const exactLevel = candidates.filter(q => q.level === this.currentLevel);
    if (exactLevel.length > 0) candidates = exactLevel;
    
    // If all used, reset
    if (candidates.length === 0) {
      this.usedQuestions.clear();
      candidates = pool.filter(q => q.level >= levelRange[0] && q.level <= levelRange[1]);
    }
    
    // Random selection
    const q = candidates[Math.floor(Math.random() * candidates.length)];
    this.usedQuestions.add(q.id);
    
    // Track that this standard was covered
    this.coveredStandards.add(q.standard);
    
    // Shuffle answers
    const shuffled = this.shuffleAnswers(q);
    return shuffled;
  },
  
  shuffleAnswers(q) {
    const answers = q.a.map((text, origIdx) => ({ text, origIdx }));
    // Fisher-Yates shuffle
    for (let i = answers.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [answers[i], answers[j]] = [answers[j], answers[i]];
    }
    // Find new correct index
    const newCorrect = answers.findIndex(a => a.origIdx === q.correct);
    return {
      ...q,
      a: answers.map(a => a.text),
      correct: newCorrect
    };
  },
  
  startQuestion() {
    // DON'T start quiz during phase changes or cinematics
    if (game && game.boss && game.boss.state === 'phase_change') {
      return; // Wait for cinematic to finish
    }
    if (PhaseManager.isTransitioning) {
      return; // Wait for phase transition
    }
    
    // CLEANUP: Reset screen effects to prevent stuck states
    screenFx.resetSlowmo();
    screenFx.shake = 0;
    screenFx.shakeX = 0;
    screenFx.shakeY = 0;
    
    // === PAUSE GAME DURING QUIZ ===
    if (game) {
      game.gamePaused = true;
      // Store velocities to resume later
      game._pausedState = {
        playerVx: game.player.vx,
        playerVy: game.player.vy,
        bossVx: game.boss.vx,
        bossVy: game.boss.vy,
        bossState: game.boss.state,
        bossStateTimer: game.boss.stateTimer,
      };
      // Freeze everything
      game.player.vx = 0;
      game.player.vy = 0;
      game.boss.vx = 0;
      game.boss.vy = 0;
    }
    
    this.currentQuestion = this.selectQuestion();
    this.active = true;
    this.answered = false;
    this.selectedAnswer = -1;
    this.showResult = false;
    this.questionTimer = this.maxTime;
    
    // Track this question
    this.questionsAskedThisGame.push({
      id: this.currentQuestion.id,
      standard: this.currentQuestion.standard,
      level: this.currentQuestion.level,
      timestamp: Date.now()
    });
    
    playSound('menu');
  },
  
  // Called when quiz ends (after result shown)
  endQuestion() {
    this.active = false;
    this.postQuizCooldown = 180; // 3 seconds before next quiz
    
    // === UNPAUSE GAME AND GRANT INVULNERABILITY ===
    if (game) {
      game.gamePaused = false;
      
      // Grant invulnerability frames after quiz
      game.player.invuln = Math.max(game.player.invuln, CFG.QUIZ_INVULN_AFTER);
      
      // Visual feedback for invuln
      spawnEffect('shield', game.player.x, game.player.y - 60, { color: '#22d3ee' });
      spawnDmgNum(game.player.x, game.player.y - 120, 'PROTECTED!', 'heal');
    }
  },
  
  submitAnswer(idx) {
    if (this.answered) return;
    
    this.selectedAnswer = idx;
    this.answered = true;
    this.questionsAnswered++;
    
    const correct = idx === this.currentQuestion.correct;
    const responseTime = this.maxTime - this.questionTimer; // Time taken
    
    // Track for Study Mode
    if (typeof StudyMode !== 'undefined') {
      StudyMode.trackQuestion(this.currentQuestion, correct, idx);
    }
    
    // Track for Firebase batch (NO WRITE - just collects data)
    if (typeof SES !== 'undefined' && SES.batch) {
      SES.batch.addAnswer(this.currentQuestion.id, correct, responseTime);
    }
    
    // Haptic feedback
    if (typeof Haptics !== 'undefined') {
      if (correct) {
        Haptics.success();
      } else {
        Haptics.error();
      }
    }
    
    // Track results
    this.recentResults.push(correct);
    if (this.recentResults.length > this.windowSize) {
      this.recentResults.shift();
    }
    
    // === STREAK TRACKING ===
    if (correct) {
      this.correctStreak++;
      this.maxStreak = Math.max(this.maxStreak, this.correctStreak);
    } else {
      this.correctStreak = 0;
    }
    
    // === GET SCALED REWARDS ===
    const rewards = this.getRewards(this.currentLevel, correct, this.hintUsed);
    
    // Track stats
    if (correct) {
      this.totalCorrect++;
      this.correctInWindow++;
      playSound('crit');
      
      // Apply scaled rewards
      if (game && game.player) {
        const p = game.player;
        const healAmt = Math.round(p.maxHp * rewards.heal / 100);
        p.hp = Math.min(p.maxHp, p.hp + healAmt);
        p.mana = Math.min(p.maxMana, p.mana + rewards.mana);
        p.ultCharge = Math.min(100, p.ultCharge + rewards.ult);
        
        spawnDmgNum(p.x, p.y - 100, '+' + healAmt + ' HP', 'heal');
        
        // Streak bonus feedback
        if (rewards.streakBonus) {
          spawnDmgNum(p.x, p.y - 140, this.correctStreak + ' STREAK!', 'crit');
        }
      }
      
      // Deal scaled damage to boss
      if (game && game.boss && game.boss.hp > 0 && game.boss.invuln <= 0) {
        const dmg = rewards.damage;
        game.boss.hp = Math.max(HPGates.getMinHP(game.boss.maxHp), game.boss.hp - dmg);
        spawnDmgNum(game.boss.x, game.boss.y - 120, dmg, 'special');
        game.stats.dmg += dmg;
      }
      
      // UNLOCK HP GATES on correct answer
      const unlockedGate = HPGates.onCorrectAnswer();
      if (unlockedGate >= 0) {
        if (game && game.boss) {
          spawnDmgNum(game.boss.x, game.boss.y - 200, 'GATE OPEN!', 'heal');
        }
      }
      
      // TierSystem integration
      if (typeof TierSystem !== 'undefined' && game && game.player) {
        const playerClass = game.player.classKey || selectedClass || 'INFERNO';
        TierSystem.onCorrect(this.currentQuestion, playerClass);
      }
    } else {
      this.totalWrong++;
      playSound('hurt');
      
      // Wrong answer penalty (scaled by difficulty)
      if (game && game.player) {
        const dmgPct = 10 + this.currentLevel * 3; // 13-22% damage
        const dmgAmt = Math.round(game.player.maxHp * dmgPct / 100);
        game.player.hp = Math.max(1, game.player.hp - dmgAmt);
        game.stats.damageTaken += dmgAmt;
        spawnDmgNum(game.player.x, game.player.y - 100, '-' + dmgAmt, 'hurt');
      }
      
      // TierSystem integration
      if (typeof TierSystem !== 'undefined' && game && game.player) {
        TierSystem.onWrong(this.currentQuestion, game.player);
      }
    }
    
    // Reset hint state for next question
    this.hintUsed = false;
    this.eliminatedOptions = [];
    
    // Track by standard
    const std = this.currentQuestion.standard;
    if (!this.standardsPerformance[std]) {
      this.standardsPerformance[std] = { correct: 0, total: 0 };
    }
    this.standardsPerformance[std].total++;
    if (correct) this.standardsPerformance[std].correct++;
    
    // Adapt difficulty
    this.adaptDifficulty();
    
    // Show result
    this.showResult = true;
    this.resultTimer = 60;
    
    return correct;
  },
  
  adaptDifficulty() {
    if (this.recentResults.length < this.windowSize) return;
    
    const recentCorrect = this.recentResults.filter(r => r).length;
    const accuracy = recentCorrect / this.windowSize;
    
    if (accuracy >= 0.8 && this.currentLevel < 4) {
      this.currentLevel++;
      this.recentResults = [];
    } else if (accuracy < 0.4 && this.currentLevel > 1) {
      this.currentLevel--;
      this.recentResults = [];
    }
  },
  
  update() {
    if (!this.active) return;
    
    if (this.showResult) {
      this.resultTimer--;
      if (this.resultTimer <= 0) {
        this.showResult = false;
        // Call endQuestion to unpause and grant invuln
        this.endQuestion();
        // CLEANUP: Reset screen effects when quiz ends
        screenFx.resetSlowmo();
      }
      return;
    }
    
    // Timer countdown
    if (!this.answered) {
      this.questionTimer--;
      if (this.questionTimer <= 0) {
        // Time's up - count as wrong
        this.submitAnswer(-1);
      }
    }
  },
  
  render(ctx) {
    if (!this.active) return;
    
    const q = this.currentQuestion;
    
    // Darken background
    ctx.fillStyle = 'rgba(0,0,0,0.85)';
    ctx.fillRect(0, 0, 1200, 700);
    
    // Question box
    ctx.fillStyle = 'rgba(30, 30, 60, 0.95)';
    ctx.strokeStyle = '#6366f1';
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.roundRect(100, 80, 1000, 540, 20);
    ctx.fill();
    ctx.stroke();
    
    // Standard badge
    ctx.fillStyle = '#6366f1';
    ctx.font = 'bold 16px sans-serif';
    ctx.textAlign = 'left';
    ctx.fillText(q.standard + ' | Level ' + q.level, 130, 120);
    
    // ENHANCED: TTS button
    ctx.fillStyle = '#22d3ee';
    ctx.beginPath();
    ctx.arc(1050, 110, 18, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = '#000';
    ctx.font = '18px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText('üîä', 1050, 116);
    
    // Timer bar
    const timerPct = this.questionTimer / this.maxTime;
    const timerColor = timerPct > 0.5 ? '#22c55e' : timerPct > 0.25 ? '#f59e0b' : '#ef4444';
    ctx.fillStyle = '#1a1a2e';
    ctx.fillRect(130, 140, 940, 15);
    ctx.fillStyle = timerColor;
    ctx.fillRect(130, 140, 940 * timerPct, 15);
    
    // Timer text
    const secs = Math.ceil(this.questionTimer / 60);
    ctx.fillStyle = '#fff';
    ctx.font = 'bold 14px sans-serif';
    ctx.textAlign = 'right';
    ctx.fillText(secs + 's', 1070, 153);
    
    // Question text
    ctx.fillStyle = '#fff';
    ctx.font = '24px sans-serif';
    ctx.textAlign = 'center';
    this.wrapText(ctx, q.q, 600, 210, 900, 32);
    
    // Answer buttons
    const labels = ['A', 'B', 'C', 'D'];
    const btnY = [320, 390, 460, 530];
    
    q.a.forEach((ans, i) => {
      const y = btnY[i];
      let bgColor = 'rgba(50, 50, 80, 0.8)';
      let borderColor = '#4b5563';
      
      if (this.showResult) {
        if (i === q.correct) {
          bgColor = 'rgba(34, 197, 94, 0.6)';
          borderColor = '#22c55e';
        } else if (i === this.selectedAnswer && i !== q.correct) {
          bgColor = 'rgba(239, 68, 68, 0.6)';
          borderColor = '#ef4444';
        }
      } else if (this.selectedAnswer === i) {
        bgColor = 'rgba(99, 102, 241, 0.6)';
        borderColor = '#6366f1';
      }
      
      ctx.fillStyle = bgColor;
      ctx.strokeStyle = borderColor;
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.roundRect(200, y, 800, 55, 12);
      ctx.fill();
      ctx.stroke();
      
      // Label
      ctx.fillStyle = '#6366f1';
      ctx.font = 'bold 22px sans-serif';
      ctx.textAlign = 'left';
      ctx.fillText(labels[i], 220, y + 36);
      
      // Answer text
      ctx.fillStyle = '#fff';
      ctx.font = '20px sans-serif';
      ctx.fillText(ans, 260, y + 36);
    });
    
    // Result overlay
    if (this.showResult) {
      const correct = this.selectedAnswer === q.correct;
      ctx.fillStyle = correct ? '#22c55e' : '#ef4444';
      ctx.font = 'bold 48px sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText(correct ? '‚úì CORRECT!' : '‚úó INCORRECT', 600, 650);
      
      // Combat effect hint
      ctx.fillStyle = '#888';
      ctx.font = '18px sans-serif';
      ctx.fillText(correct ? '+25% HP ‚Ä¢ Mana +20 ‚Ä¢ Attack hits boss!' : '-25% HP ‚Ä¢ Attack bounces back!', 600, 690);
    } else {
      // Input hint
      ctx.fillStyle = '#888';
      ctx.font = '18px sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText('Press 1-4 or A-D to answer ‚Ä¢ Click/Tap answer', 600, 640);
    }
  },
  
  wrapText(ctx, text, x, y, maxWidth, lineHeight) {
    const words = text.split(' ');
    let line = '';
    let testLine, metrics, testWidth;
    
    for (let n = 0; n < words.length; n++) {
      testLine = line + words[n] + ' ';
      metrics = ctx.measureText(testLine);
      testWidth = metrics.width;
      
      if (testWidth > maxWidth && n > 0) {
        ctx.fillText(line.trim(), x, y);
        line = words[n] + ' ';
        y += lineHeight;
      } else {
        line = testLine;
      }
    }
    ctx.fillText(line.trim(), x, y);
  },
  
  handleClick(x, y) {
    if (!this.active) return;
    
    // ENHANCED: TTS button click (circle at 1050, 110 with radius 18)
    if (x >= 1032 && x <= 1068 && y >= 92 && y <= 128) {
      if (typeof A11y !== 'undefined' && this.currentQuestion) {
        A11y.speak(this.currentQuestion.q);
      }
      return true;
    }
    
    if (this.answered) return;
    
    const btnY = [320, 390, 460, 530];
    for (let i = 0; i < 4; i++) {
      if (x >= 200 && x <= 1000 && y >= btnY[i] && y <= btnY[i] + 55) {
        this.submitAnswer(i);
        return true;
      }
    }
    return false;
  },
  
  handleKey(key) {
    if (!this.active || this.answered) return false;
    
    const keyMap = { '1': 0, '2': 1, '3': 2, '4': 3, 'a': 0, 'b': 1, 'c': 2, 'd': 3 };
    if (keyMap[key] !== undefined) {
      this.submitAnswer(keyMap[key]);
      return true;
    }
    return false;
  },
  
  // Generate report data
  getReport() {
    return {
      totalQuestions: this.questionsAnswered,
      correct: this.totalCorrect,
      wrong: this.totalWrong,
      accuracy: this.questionsAnswered > 0 ? Math.round(this.totalCorrect / this.questionsAnswered * 100) : 0,
      finalLevel: this.currentLevel,
      byStandard: this.standardsPerformance
    };
  }
};

// ============ ENHANCED TIER SYSTEM (5 TIERS) ============
const TierSystem = {
  current: 0,
  progress: 0,
  correctPerTier: 2,
  maxTiers: 5,
  streak: 0,
  maxStreak: 0,
  history: [],
  retryPool: [],
  vCooldown: 0,
  
  // Unique tier attacks per class
  tierAttacks: {
    INFERNO: [
      { name: 'Ember Punch', dmg: 80 },
      { name: 'Flame Burst', dmg: 150 },
      { name: 'Inferno Wave', dmg: 250 },
      { name: 'Meteor Strike', dmg: 400 },
      { name: 'SOLAR ERUPTION', dmg: 800, final: true }
    ],
    CRYSTAL: [
      { name: 'Shard Throw', dmg: 70 },
      { name: 'Prism Beam', dmg: 140 },
      { name: 'Crystal Storm', dmg: 230 },
      { name: 'Void Rift', dmg: 380 },
      { name: 'ARCANE ANNIHILATION', dmg: 900, final: true }
    ],
    SHADOW: [
      { name: 'Shadow Strike', dmg: 75 },
      { name: 'Phantom Dash', dmg: 145 },
      { name: 'Dark Vortex', dmg: 240 },
      { name: 'Soul Reaper', dmg: 390 },
      { name: 'ETERNAL DARKNESS', dmg: 1000, final: true }
    ]
  },
  
  vDamage: { INFERNO: 60, CRYSTAL: 55, SHADOW: 65 },
  
  reset() {
    this.current = 0;
    this.progress = 0;
    this.streak = 0;
    this.maxStreak = 0;
    this.history = [];
    this.retryPool = [];
    this.vCooldown = 0;
    this.updateUI();
  },
  
  onCorrect(question, playerClass) {
    this.streak++;
    this.maxStreak = Math.max(this.maxStreak, this.streak);
    this.progress++;
    this.history.push({ q: question.q, std: question.standard, ok: true });
    
    // Check tier unlock
    if (this.progress >= this.correctPerTier && this.current < this.maxTiers) {
      this.current++;
      this.progress = 0;
      const atk = this.tierAttacks[playerClass]?.[this.current - 1];
      if (atk) {
        this.showMindset(`üéâ TIER ${this.current} UNLOCKED!\n${atk.name} (${atk.dmg} DMG)`, true);
        if (this.current === 5) this.showFinalAlert();
      }
    } else {
      this.showMindset(this.getGrowthMsg(true));
    }
    
    this.updateUI();
    return this.current;
  },
  
  onWrong(question, player) {
    this.streak = 0;
    this.history.push({ q: question.q, std: question.standard, ok: false });
    this.retryPool.push(question);
    
    // -15% HP penalty
    if (player) {
      const penalty = Math.floor(player.maxHp * 0.15);
      player.hp = Math.max(1, player.hp - penalty);
      spawnDmgNum(player.x, player.y - 50, `-${penalty} HP`, 'hurt');
    }
    
    this.showMindset(this.getGrowthMsg(false));
    this.updateUI();
  },
  
  getRetryQuestion() {
    if (this.retryPool.length > 0 && Math.random() < 0.3) {
      return this.retryPool.shift();
    }
    return null;
  },
  
  vAttack(player, boss) {
    if (this.vCooldown > 0 || !player || !boss) return false;
    
    const cls = player.classKey || 'INFERNO';
    let dmg, name;
    
    if (this.current >= 5) {
      const atk = this.tierAttacks[cls][4];
      dmg = atk.dmg;
      name = atk.name;
    } else if (this.current > 0) {
      const atk = this.tierAttacks[cls][this.current - 1];
      dmg = atk.dmg;
      name = atk.name;
    } else {
      dmg = this.vDamage[cls] || 50;
      name = 'V Attack';
    }
    
    boss.hp -= dmg;
    this.vCooldown = 90; // 1.5 second cooldown
    spawnDmgNum(boss.x, boss.y - 100, `${name}! ${dmg}`, 'crit');
    playSound('special');
    
    this.showMindset(`‚ö° ${name}!`);
    return true;
  },
  
  updateVCooldown() {
    if (this.vCooldown > 0) this.vCooldown--;
    const btn = document.getElementById('v-btn');
    if (btn) btn.classList.toggle('cooldown', this.vCooldown > 0);
  },
  
  showFinalAlert() {
    const el = document.getElementById('final-alert');
    if (el) {
      el.classList.add('show');
      const btn = document.getElementById('v-btn');
      if (btn) btn.classList.add('final');
      setTimeout(() => el.classList.remove('show'), 3000);
    }
  },
  
  getGrowthMsg(correct) {
    const msgs = correct ? [
      "Excellent! Your brain is growing! üß†",
      "That's the power of learning! ‚≠ê",
      "Effort leads to success! üí™",
      "Knowledge is your weapon! üéØ",
      "You're mastering this! üèÜ"
    ] : [
      "Mistakes help us learn! üí™",
      "Every wrong answer teaches something! üå±",
      "This is how we grow! üöÄ",
      "Keep pushing forward! üìö",
      "Learning in progress! üîÑ"
    ];
    return msgs[Math.floor(Math.random() * msgs.length)];
  },
  
  showMindset(msg, isTierUp) {
    const el = document.getElementById('mindset-msg');
    if (el) {
      el.textContent = msg;
      el.style.background = isTierUp ? 
        'linear-gradient(135deg, #fbbf24, #f59e0b)' : 
        'linear-gradient(135deg, #6366f1, #22d3ee)';
      el.style.color = isTierUp ? '#000' : '#fff';
      el.classList.add('show');
      setTimeout(() => el.classList.remove('show'), isTierUp ? 3000 : 2000);
    }
  },
  
  updateUI() {
    // Check if mobile - don't show desktop UI elements
    const isMobile = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0) || (window.innerWidth <= 1024);
    
    // Tier bar - HIDE ON MOBILE
    const tierBar = document.getElementById('tier-bar');
    if (tierBar) {
      if (isMobile) {
        tierBar.classList.remove('show');
        tierBar.style.display = 'none';
      } else {
        tierBar.classList.toggle('show', state === 'game' && game && !game.victory && !game.gameOver);
      }
    }
    
    // Progress fill
    const pct = ((this.current * this.correctPerTier) + this.progress) / (this.maxTiers * this.correctPerTier) * 100;
    const fill = document.getElementById('tier-fill');
    if (fill) fill.style.width = pct + '%';
    
    // Tier text
    const txt = document.getElementById('tier-txt');
    if (txt) txt.textContent = `${this.current}/${this.maxTiers}`;
    
    // Tier dots
    document.querySelectorAll('.tier-dot').forEach((dot, i) => {
      dot.classList.toggle('done', i < this.current);
      dot.classList.toggle('now', i === this.current);
    });
    
    // Streak - HIDE ON MOBILE
    const streakBox = document.getElementById('streak-box');
    const streakNum = document.getElementById('streak-num');
    if (streakBox) {
      if (isMobile) {
        streakBox.classList.remove('show');
        streakBox.style.display = 'none';
      } else {
        streakBox.classList.toggle('show', state === 'game' && game);
        streakBox.classList.toggle('fire', this.streak >= 3);
      }
    }
    if (streakNum) streakNum.textContent = this.streak;
    
    // V button - HIDE ON MOBILE (use on-screen ultimate button instead)
    const vBtn = document.getElementById('v-btn');
    if (vBtn) {
      if (isMobile) {
        vBtn.classList.remove('show');
        vBtn.style.display = 'none';
      } else {
        vBtn.classList.toggle('show', state === 'game' && game && !game.victory && !game.gameOver);
        vBtn.classList.toggle('final', this.current >= 5);
      }
    }
  },
  
  showReview(victory) {
    const stats = document.getElementById('rev-stats');
    const list = document.getElementById('rev-list');
    const review = document.getElementById('battle-review');
    
    if (!stats || !list || !review) return;
    
    const total = this.history.length;
    const correct = this.history.filter(h => h.ok).length;
    const acc = total > 0 ? Math.round(correct / total * 100) : 0;
    
    stats.innerHTML = `
      <div class="rev-stat"><div class="val">${victory ? 'üèÜ' : 'üíÄ'}</div><div class="lbl">${victory ? 'VICTORY' : 'DEFEAT'}</div></div>
      <div class="rev-stat"><div class="val">${correct}/${total}</div><div class="lbl">Correct</div></div>
      <div class="rev-stat"><div class="val">${acc}%</div><div class="lbl">Accuracy</div></div>
      <div class="rev-stat"><div class="val">${this.maxStreak}</div><div class="lbl">Best Streak</div></div>
    `;
    
    list.innerHTML = this.history.map(h => `
      <div class="rev-item">
        <div class="rev-icon ${h.ok ? 'ok' : 'no'}">${h.ok ? '‚úì' : '‚úó'}</div>
        <div style="flex:1;overflow:hidden;">
          <div style="font-weight:600;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;">${h.q}</div>
          <div style="font-size:10px;color:#888;">${h.std}</div>
        </div>
      </div>
    `).join('');
    
    review.classList.add('show');
  }
};

// ============ ACCESSIBILITY SYSTEM ============
const A11y = {
  tts: false,
  dyslexia: false,
  contrast: false,
  extendedTime: false,
  
  init() {
    // Hide a11y panel on mobile - it's in the way
    const isMobile = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0) || (window.innerWidth <= 1024);
    const panel = document.getElementById('a11y-panel');
    if (isMobile && panel) {
      panel.style.display = 'none';
    }
    
    document.getElementById('a11y-tts')?.addEventListener('click', () => this.toggle('tts'));
    document.getElementById('a11y-dys')?.addEventListener('click', () => this.toggle('dyslexia'));
    document.getElementById('a11y-contrast')?.addEventListener('click', () => this.toggle('contrast'));
    document.getElementById('a11y-time')?.addEventListener('click', () => this.toggle('extendedTime'));
    document.getElementById('rev-btn')?.addEventListener('click', () => {
      document.getElementById('battle-review')?.classList.remove('show');
    });
    
    // V button click - only for desktop
    if (!isMobile) {
      document.getElementById('v-btn')?.addEventListener('click', () => {
        if (game && game.player && game.boss) {
          TierSystem.vAttack(game.player, game.boss);
        }
      });
    }
  },
  
  toggle(setting) {
    this[setting] = !this[setting];
    const btnMap = { tts: 'a11y-tts', dyslexia: 'a11y-dys', contrast: 'a11y-contrast', extendedTime: 'a11y-time' };
    const btn = document.getElementById(btnMap[setting]);
    if (btn) btn.classList.toggle('on', this[setting]);
    
    if (setting === 'dyslexia') document.body.classList.toggle('dyslexia-font', this.dyslexia);
    if (setting === 'contrast') document.body.classList.toggle('high-contrast-mode', this.contrast);
    if (setting === 'extendedTime' && QuizSystem) {
      QuizSystem.maxTime = this.extendedTime ? 35 * 60 : 20 * 60;
    }
  },
  
  speak(text) {
    if (!this.tts || !('speechSynthesis' in window)) return;
    speechSynthesis.cancel();
    const u = new SpeechSynthesisUtterance(text);
    u.rate = 0.9;
    speechSynthesis.speak(u);
  }
};

// Initialize A11y on DOM ready
document.addEventListener('DOMContentLoaded', () => A11y.init());

// ============ TEACHER TOOLS ============
const TeacherTools = {
  // Parse CSV upload
  parseCSV(csvText) {
    const lines = csvText.trim().split('\n');
    const questions = [];
    
    // Skip header row
    for (let i = 1; i < lines.length; i++) {
      const cols = lines[i].split(',').map(c => c.trim().replace(/^"|"$/g, ''));
      if (cols.length >= 7) {
        questions.push({
          id: 1000 + i,
          level: parseInt(cols[0]) || 2,
          standard: cols[1] || 'Custom',
          q: cols[2],
          a: [cols[3], cols[4], cols[5], cols[6]],
          correct: 0 // First answer is correct
        });
      }
    }
    return questions;
  },
  
  // Parse JSON upload
  parseJSON(jsonText) {
    try {
      const data = JSON.parse(jsonText);
      return Array.isArray(data) ? data.map((q, i) => ({ ...q, id: 2000 + i })) : [];
    } catch (e) {
      console.error('Invalid JSON:', e);
      return [];
    }
  },
  
  // Add single question manually
  addQuestion(level, standard, question, answers, correctIndex) {
    customQuestions.push({
      id: 3000 + customQuestions.length,
      level,
      standard,
      q: question,
      a: answers,
      correct: correctIndex
    });
  },
  
  // Clear custom questions
  clearCustom() {
    customQuestions = [];
  },
  
  // Export report as CSV
  exportReportCSV(report, studentName) {
    let csv = 'Student,Total Questions,Correct,Wrong,Accuracy,Final Level\n';
    csv += `${studentName},${report.totalQuestions},${report.correct},${report.wrong},${report.accuracy}%,${report.finalLevel}\n\n`;
    csv += 'Standard,Correct,Total,Percentage\n';
    
    for (const [std, data] of Object.entries(report.byStandard)) {
      const pct = data.total > 0 ? Math.round(data.correct / data.total * 100) : 0;
      csv += `${std},${data.correct},${data.total},${pct}%\n`;
    }
    
    return csv;
  }
};

// ============ AUDIO ============
let audioCtx = null;
function initAudio() { if (!audioCtx) { audioCtx = new (window.AudioContext || window.webkitAudioContext)(); audioCtx.resume(); } }
function playSound(type, vol = 0.25) {
  // Check if muted
  if (typeof SoundManager !== 'undefined' && SoundManager.muted) return;
  
  // Add haptic feedback for certain sounds
  if (typeof Haptics !== 'undefined') {
    if (type === 'hit' || type === 'crit') Haptics.medium();
    else if (type === 'hurt') Haptics.heavy();
    else if (type === 'parry') Haptics.success();
  }
  
  if (!audioCtx) return;
  const t = audioCtx.currentTime, o = audioCtx.createOscillator(), g = audioCtx.createGain();
  o.connect(g).connect(audioCtx.destination);
  g.gain.setValueAtTime(vol, t);
  const sounds = {
    hit: () => { o.type = 'square'; o.frequency.setValueAtTime(200, t); o.frequency.exponentialRampToValueAtTime(80, t + 0.08); },
    crit: () => { o.type = 'sawtooth'; o.frequency.setValueAtTime(400, t); o.frequency.exponentialRampToValueAtTime(100, t + 0.15); g.gain.setValueAtTime(0.35, t); },
    special: () => { o.type = 'sawtooth'; o.frequency.setValueAtTime(300, t); o.frequency.linearRampToValueAtTime(900, t + 0.2); },
    ranged: () => { o.frequency.setValueAtTime(500, t); o.frequency.exponentialRampToValueAtTime(200, t + 0.1); },
    hurt: () => { o.type = 'sawtooth'; o.frequency.setValueAtTime(150, t); o.frequency.exponentialRampToValueAtTime(50, t + 0.15); },
    jump: () => { o.frequency.setValueAtTime(300, t); o.frequency.exponentialRampToValueAtTime(500, t + 0.08); g.gain.setValueAtTime(0.12, t); },
    dash: () => { o.type = 'sine'; o.frequency.setValueAtTime(200, t); o.frequency.exponentialRampToValueAtTime(400, t + 0.1); },
    parry: () => { o.frequency.setValueAtTime(800, t); o.frequency.exponentialRampToValueAtTime(400, t + 0.15); g.gain.setValueAtTime(0.35, t); },
    phase: () => { o.type = 'sine'; o.frequency.setValueAtTime(400, t); o.frequency.linearRampToValueAtTime(100, t + 0.5); g.gain.setValueAtTime(0.4, t); },
    freeze: () => { o.type = 'sine'; o.frequency.setValueAtTime(1200, t); o.frequency.exponentialRampToValueAtTime(200, t + 0.3); },
    fire: () => { o.type = 'sawtooth'; o.frequency.setValueAtTime(100, t); o.frequency.linearRampToValueAtTime(50, t + 0.2); },
    void: () => { o.type = 'sine'; o.frequency.setValueAtTime(80, t); o.frequency.linearRampToValueAtTime(40, t + 0.4); g.gain.setValueAtTime(0.4, t); },
    menu: () => { o.frequency.setValueAtTime(440, t); g.gain.setValueAtTime(0.15, t); },
    // New sounds
    heavy: () => { o.type = 'sawtooth'; o.frequency.setValueAtTime(80, t); o.frequency.exponentialRampToValueAtTime(40, t + 0.2); g.gain.setValueAtTime(0.4, t); },
    launch: () => { o.type = 'square'; o.frequency.setValueAtTime(200, t); o.frequency.exponentialRampToValueAtTime(600, t + 0.15); },
    sweep: () => { o.type = 'sawtooth'; o.frequency.setValueAtTime(100, t); o.frequency.exponentialRampToValueAtTime(200, t + 0.1); },
    telegraph: () => { o.type = 'sine'; o.frequency.setValueAtTime(800, t); g.gain.setValueAtTime(0.2, t); },
    phase_change: () => { o.type = 'sine'; o.frequency.setValueAtTime(200, t); o.frequency.linearRampToValueAtTime(800, t + 0.5); g.gain.setValueAtTime(0.35, t); },
  };
  if (sounds[type]) sounds[type]();
  g.gain.exponentialRampToValueAtTime(0.01, t + 0.5);
  o.start(t); o.stop(t + 0.5);
}

// ============ DYNAMIC AUDIO SYSTEM ============
const DynamicAudio = {
  intensity: 0,        // 0-1, based on game state
  targetIntensity: 0,
  bpm: 120,
  lastBeat: 0,
  bassOsc: null,
  
  update() {
    if (!game || state !== 'game') {
      this.targetIntensity = 0;
    } else {
      // Calculate intensity based on game state
      const playerHpPct = game.player.hp / game.player.maxHp;
      const bossHpPct = game.boss.hp / game.boss.maxHp;
      const inDanger = playerHpPct < 0.3;
      const bossLowHp = bossHpPct < 0.25;
      const bossEnraged = game.boss.enraged;
      
      this.targetIntensity = 0.3; // Base
      if (inDanger) this.targetIntensity += 0.3;
      if (bossLowHp) this.targetIntensity += 0.2;
      if (bossEnraged) this.targetIntensity += 0.2;
      this.targetIntensity = Math.min(1, this.targetIntensity);
    }
    
    // Smooth transition
    this.intensity += (this.targetIntensity - this.intensity) * 0.02;
  },
  
  // Ambient drone based on boss
  startAmbient(bossKey) {
    if (!audioCtx || typeof SoundManager !== 'undefined' && SoundManager.muted) return;
    
    // Different ambient sounds per boss
    const themes = {
      VOID_TITAN: { freq: 55, type: 'sine' },      // Deep void hum
      FLAME_WYRM: { freq: 80, type: 'sawtooth' },  // Crackling fire base
      FROST_QUEEN: { freq: 110, type: 'triangle' } // Icy wind
    };
    
    const theme = themes[bossKey] || themes.VOID_TITAN;
    // Ambient would be continuous - for now just note the theme
    this.currentTheme = theme;
  }
};

// ============ PHASE TRANSITION ============
function triggerPhaseTransition(boss, newPhase) {
  if (!PhaseManager.startTransition()) return;
  
  // Pause game briefly
  game.gamePaused = true;
  
  // Visual effects
  screenFx.shake = 25;
  screenFx.setSlowmo(0.3, 90);
  screenFx.addTint(boss.data.color, 0.5);
  
  // Phase announcement
  spawnDmgNum(boss.x, boss.y - 180, newPhase.name, 'crit');
  spawnEffect('phase_burst', boss.x, boss.y - 80, { 
    color: boss.data.color, 
    size: 200 
  });
  
  // Boss roar/effect
  for (let i = 0; i < 6; i++) {
    const angle = (i / 6) * Math.PI * 2;
    spawnEffect('phase_energy', boss.x, boss.y - 80, { 
      color: boss.data.color, 
      angle: angle,
      size: 30
    });
  }
  
  // Spawn minions on phase change
  if (typeof MinionSystem !== 'undefined') {
    MinionSystem.spawnWave(boss.key, newPhase.name);
  }
  
  playSound('phase_change');
  
  // Haptic
  if (typeof Haptics !== 'undefined') Haptics.heavy();
  
  // End transition after delay
  safeTimeout(() => {
    PhaseManager.endTransition();
    game.gamePaused = false;
    // Boss is briefly invulnerable after phase change
    boss.invuln = 60;
  }, 1500);
}

// ============ MINION SYSTEM ============
const MinionSystem = {
  minions: [],
  maxMinions: 6,
  
  // Minion types per boss
  minionTypes: {
    VOID_TITAN: {
      void_orb: { hp: 30, damage: 15, speed: 2, color: '#8b5cf6', size: 20, behavior: 'orbit' },
      shadow_wisp: { hp: 20, damage: 10, speed: 4, color: '#6366f1', size: 15, behavior: 'chase' },
    },
    FLAME_WYRM: {
      fire_imp: { hp: 40, damage: 20, speed: 3, color: '#ef4444', size: 22, behavior: 'chase' },
      ember: { hp: 15, damage: 8, speed: 5, color: '#f97316', size: 12, behavior: 'swarm' },
    },
    FROST_QUEEN: {
      ice_shard: { hp: 25, damage: 12, speed: 3.5, color: '#22d3ee', size: 18, behavior: 'orbit' },
      frost_spirit: { hp: 35, damage: 18, speed: 2.5, color: '#67e8f9', size: 20, behavior: 'chase' },
    }
  },
  
  spawnWave(bossKey, phaseName) {
    const types = this.minionTypes[bossKey];
    if (!types) return;
    
    const typeKeys = Object.keys(types);
    const count = phaseName === 'HUNGER' || phaseName === 'RAGNAROK' || phaseName === 'APOCALYPSE' ? 4 : 2;
    
    for (let i = 0; i < count && this.minions.length < this.maxMinions; i++) {
      const typeKey = typeKeys[Math.floor(Math.random() * typeKeys.length)];
      const type = types[typeKey];
      
      // Spawn position (around boss)
      const angle = (i / count) * Math.PI * 2;
      const dist = 100 + Math.random() * 50;
      const x = game.boss.x + Math.cos(angle) * dist;
      const y = game.boss.y - 50 + Math.sin(angle) * 30;
      
      this.spawn(typeKey, type, x, y);
    }
  },
  
  spawn(typeKey, type, x, y) {
    if (this.minions.length >= this.maxMinions) return;
    
    this.minions.push({
      type: typeKey,
      x, y,
      hp: type.hp,
      maxHp: type.hp,
      damage: type.damage,
      speed: type.speed,
      color: type.color,
      size: type.size,
      behavior: type.behavior,
      angle: Math.random() * Math.PI * 2,
      timer: 0,
      attackCD: 0,
      vx: 0, vy: 0
    });
    
    spawnEffect('hit', x, y, { color: type.color, size: 30 });
  },
  
  update() {
    if (!game || !game.player) return;
    
    const p = game.player;
    const b = game.boss;
    
    this.minions.forEach(m => {
      m.timer++;
      if (m.attackCD > 0) m.attackCD--;
      
      const dx = p.x - m.x;
      const dy = (p.y - 60) - m.y;
      const dist = Math.sqrt(dx*dx + dy*dy);
      
      // Behavior
      switch (m.behavior) {
        case 'chase':
          // Move toward player
          if (dist > 50) {
            m.vx += (dx / dist) * m.speed * 0.1;
            m.vy += (dy / dist) * m.speed * 0.1;
          }
          break;
          
        case 'orbit':
          // Orbit around boss
          m.angle += 0.03;
          const orbitDist = 120;
          const targetX = b.x + Math.cos(m.angle) * orbitDist;
          const targetY = b.y - 60 + Math.sin(m.angle) * 40;
          m.vx += (targetX - m.x) * 0.05;
          m.vy += (targetY - m.y) * 0.05;
          break;
          
        case 'swarm':
          // Erratic movement toward player
          m.vx += (dx / dist) * m.speed * 0.15 + (Math.random() - 0.5) * 2;
          m.vy += (dy / dist) * m.speed * 0.15 + (Math.random() - 0.5) * 2;
          break;
      }
      
      // Apply velocity
      m.vx *= 0.9;
      m.vy *= 0.9;
      m.x += m.vx * screenFx.slowmo;
      m.y += m.vy * screenFx.slowmo;
      
      // Keep in bounds
      m.x = Math.max(80, Math.min(1120, m.x));
      m.y = Math.max(100, Math.min(550, m.y));
      
      // Attack player on contact
      if (dist < m.size + 30 && m.attackCD <= 0 && p.invuln <= 0) {
        p.hp -= m.damage;
        p.invuln = 30;
        p.stagger = 8;
        m.attackCD = 60;
        game.stats.damageTaken += m.damage;
        spawnDmgNum(p.x, p.y - 80, m.damage, 'hurt');
        playSound('hurt');
        if (typeof Haptics !== 'undefined') Haptics.medium();
      }
    });
    
    // Remove dead minions
    this.minions = this.minions.filter(m => m.hp > 0);
  },
  
  damageMinion(minion, damage) {
    minion.hp -= damage;
    spawnDmgNum(minion.x, minion.y - 20, damage, 'hit');
    
    if (minion.hp <= 0) {
      spawnEffect('break', minion.x, minion.y, { color: minion.color, size: 40 });
      playSound('crit');
      // Drop small reward
      if (game && game.player) {
        game.player.ultCharge = Math.min(100, game.player.ultCharge + 5);
      }
    }
  },
  
  render(ctx) {
    this.minions.forEach(m => {
      // Glow
      ctx.shadowColor = m.color;
      ctx.shadowBlur = 10;
      
      // Body
      ctx.fillStyle = m.color;
      ctx.beginPath();
      ctx.arc(m.x, m.y, m.size, 0, Math.PI * 2);
      ctx.fill();
      
      // Inner glow
      ctx.fillStyle = '#fff';
      ctx.globalAlpha = 0.5;
      ctx.beginPath();
      ctx.arc(m.x - m.size * 0.3, m.y - m.size * 0.3, m.size * 0.3, 0, Math.PI * 2);
      ctx.fill();
      ctx.globalAlpha = 1;
      
      // HP bar
      const hpPct = m.hp / m.maxHp;
      ctx.fillStyle = '#333';
      ctx.fillRect(m.x - 15, m.y - m.size - 10, 30, 4);
      ctx.fillStyle = hpPct > 0.5 ? '#22c55e' : hpPct > 0.25 ? '#f59e0b' : '#ef4444';
      ctx.fillRect(m.x - 15, m.y - m.size - 10, 30 * hpPct, 4);
      
      ctx.shadowBlur = 0;
    });
  },
  
  // Check if player attack hits minions
  checkPlayerHit(px, py, range, damage) {
    this.minions.forEach(m => {
      const dist = Math.sqrt((px - m.x) ** 2 + ((py - 60) - m.y) ** 2);
      if (dist < range + m.size) {
        this.damageMinion(m, damage);
      }
    });
  },
  
  reset() {
    this.minions = [];
  }
};

// ============ GAME STATE ============
let state = 'menu', game = null, keys = {}, frame = 0, mouseX = 0, mouseY = 0;
let selectedClass = 'INFERNO', selectedBoss = 'VOID_TITAN', difficulty = 'NORMAL';
let isPaused = false, killCam = null;

// ============ PARALLAX BG ============
class ParallaxBG {
  constructor() {
    this.layers = [];
    for (let i = 0; i < 5; i++) {
      this.layers.push({ speed: 0.1 + i * 0.15, y: 350 + i * 40, amp: 80 - i * 10, color: `hsl(240, 30%, ${5 + i * 4}%)` });
    }
    this.clouds = Array.from({length: 10}, () => ({ x: Math.random() * 1400, y: 50 + Math.random() * 150, size: 30 + Math.random() * 50, speed: 0.2 + Math.random() * 0.3 }));
    this.stars = Array.from({length: 150}, () => ({ x: Math.random() * 1200, y: Math.random() * 400, size: Math.random() * 2, twinkle: Math.random() * Math.PI * 2 }));
    this.theme = 'void';
    this.hazards = [];
  }
  
  setTheme(bossKey) {
    this.theme = bossKey === 'FLAME_WYRM' ? 'fire' : bossKey === 'FROST_QUEEN' ? 'ice' : 'void';
    this.hazards = [];
  }
  
  addHazard(type, x, y, duration) {
    // Cap hazards to prevent performance issues
    if (this.hazards.length >= 15) {
      this.hazards.shift(); // Remove oldest
    }
    this.hazards.push({ type, x, y, life: duration, maxLife: duration });
  }
  
  update() {
    this.clouds.forEach(c => { c.x -= c.speed; if (c.x < -100) c.x = 1300; });
    this.hazards = this.hazards.filter(h => { h.life--; return h.life > 0; });
  }
  
  render(ctx, intensity = 0) {
    // Theme-based gradient
    let hue = this.theme === 'fire' ? 20 : this.theme === 'ice' ? 200 : 250;
    const grad = ctx.createLinearGradient(0, 0, 0, 700);
    grad.addColorStop(0, `hsl(${hue}, ${30 + intensity * 20}%, ${5 + intensity * 5}%)`);
    grad.addColorStop(1, `hsl(${hue + 20}, ${20 + intensity * 20}%, ${15 + intensity * 10}%)`);
    ctx.fillStyle = grad;
    ctx.fillRect(0, 0, 1200, 700);
    
    // Stars
    this.stars.forEach(s => {
      s.twinkle += 0.03;
      ctx.fillStyle = this.theme === 'fire' ? '#ffcc00' : this.theme === 'ice' ? '#aaffff' : '#fff';
      ctx.globalAlpha = (Math.sin(s.twinkle) + 1) / 2 * 0.8;
      ctx.beginPath(); ctx.arc(s.x, s.y, s.size, 0, Math.PI * 2); ctx.fill();
    });
    ctx.globalAlpha = 1;
    
    // Mountains with theme color
    this.layers.forEach((l, i) => {
      const themeHue = this.theme === 'fire' ? 15 + i * 5 : this.theme === 'ice' ? 195 + i * 3 : 240 + i * 2;
      ctx.fillStyle = `hsl(${themeHue}, ${20 + i * 5}%, ${8 + i * 5}%)`;
      ctx.beginPath();
      ctx.moveTo(0, 700);
      for (let x = 0; x <= 1200; x += 40) ctx.lineTo(x, l.y + Math.sin(x * 0.008 + frame * 0.001 * l.speed) * l.amp);
      ctx.lineTo(1200, 700);
      ctx.fill();
    });
    
    // Theme particles
    if (this.theme === 'fire' && frame % 3 === 0) {
      ctx.fillStyle = '#ff6b3580';
      for (let i = 0; i < 5; i++) {
        const x = Math.random() * 1200;
        ctx.beginPath(); ctx.arc(x, CFG.GROUND_Y - Math.random() * 100, 3 + Math.random() * 5, 0, Math.PI * 2); ctx.fill();
      }
    }
    if (this.theme === 'ice') {
      ctx.fillStyle = '#ffffff40';
      for (let i = 0; i < 20; i++) {
        const x = (i * 73 + frame * 0.5) % 1200;
        const y = (i * 41 + frame * 0.8) % 700;
        ctx.beginPath(); ctx.arc(x, y, 2, 0, Math.PI * 2); ctx.fill();
      }
    }
    
    // Hazards
    this.hazards.forEach(h => {
      const prog = h.life / h.maxLife;
      ctx.globalAlpha = prog;
      if (h.type === 'fire_patch') {
        const grad = ctx.createRadialGradient(h.x, h.y, 0, h.x, h.y, 60);
        grad.addColorStop(0, '#ff6b35'); grad.addColorStop(0.5, '#ff4500'); grad.addColorStop(1, 'transparent');
        ctx.fillStyle = grad;
        ctx.beginPath(); ctx.ellipse(h.x, h.y, 60, 20, 0, 0, Math.PI * 2); ctx.fill();
      }
      if (h.type === 'ice_pillar') {
        ctx.fillStyle = '#06b6d4';
        ctx.beginPath();
        ctx.moveTo(h.x - 20, CFG.GROUND_Y);
        ctx.lineTo(h.x - 10, CFG.GROUND_Y - 120 * prog);
        ctx.lineTo(h.x + 10, CFG.GROUND_Y - 120 * prog);
        ctx.lineTo(h.x + 20, CFG.GROUND_Y);
        ctx.fill();
      }
      if (h.type === 'void_rift') {
        ctx.strokeStyle = '#8b5cf6';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.ellipse(h.x, h.y, 40 * prog, 80 * prog, 0, 0, Math.PI * 2);
        ctx.stroke();
      }
      ctx.globalAlpha = 1;
    });
  }
}

// ============ SCREEN FX (FIXED - AUTO-RESET SLOWMO) ============
class ScreenFX {
  constructor() {
    this.shake = 0; this.shakeX = 0; this.shakeY = 0;
    this.tint = null; this.tintAlpha = 0;
    this.slowmo = 1; this.hitstop = 0;
    this.vignette = 0.4;
    // AUTO-RESET SLOWMO SYSTEM
    this.slowmoTarget = 1;
    this.slowmoDuration = 0;
    this.slowmoTimer = 0;
  }
  
  addShake(i) { this.shake = Math.max(this.shake, Math.min(i, 50)); }
  
  // NEW: Set slowmo with automatic reset - DISABLED
  setSlowmo(value, duration) {
    // DISABLED - slowmo was causing freezes
    this.slowmo = 1; // Always 1
  }
  
  // Force reset slowmo immediately
  resetSlowmo() {
    this.slowmo = 1;
    this.slowmoTarget = 1;
    this.slowmoDuration = 0;
    this.slowmoTimer = 0;
  }
  
  // Tint instead of flash - more subtle and reliable
  addTint(color, alpha = 0.3, duration = 8) {
    this.tint = color;
    this.tintAlpha = Math.min(alpha, 0.4);
    this.tintDuration = duration;
  }
  
  update() {
    // CRITICAL: Cap shake to prevent excessive values
    if (this.shake > 0) {
      this.shake = Math.min(this.shake, 50); // Max shake amplitude
      this.shakeX = (Math.random() - 0.5) * this.shake;
      this.shakeY = (Math.random() - 0.5) * this.shake;
      this.shake *= 0.8; // Faster decay
      if (this.shake < 1) {
        this.shake = 0;
        this.shakeX = 0;
        this.shakeY = 0;
      }
    } else {
      this.shakeX = 0;
      this.shakeY = 0;
    }
    
    if (this.tintAlpha > 0) {
      this.tintAlpha -= 0.06;
      if (this.tintAlpha < 0) this.tintAlpha = 0;
    }
    if (this.hitstop > 0) this.hitstop--;
    
    // AUTO-RESET SLOWMO - prevents permanent slowdown
    if (this.slowmoDuration > 0) {
      this.slowmoTimer++;
      if (this.slowmoTimer >= this.slowmoDuration) {
        this.slowmo = 1;
        this.slowmoDuration = 0;
        this.slowmoTimer = 0;
      }
    }
    // AGGRESSIVE safety: if slowmo is not 1 and no duration set, force reset quickly
    if (this.slowmo < 1.0 && this.slowmoDuration === 0) {
      this.slowmo = Math.min(1, this.slowmo + 0.1); // Very fast recovery
    }
    // Hard cap - slowmo should NEVER be below 0.2
    if (this.slowmo < 0.2) this.slowmo = 0.2;
  }
  
  pre(ctx) { ctx.save(); ctx.translate(this.shakeX, this.shakeY); }
  
  post(ctx) {
    // Subtle tint overlay (replaces problematic flash)
    if (this.tintAlpha > 0.01 && this.tint) {
      ctx.fillStyle = this.tint;
      ctx.globalAlpha = this.tintAlpha;
      ctx.fillRect(-50, -50, 1300, 800);
      ctx.globalAlpha = 1;
    }
    // Vignette
    const vigGrad = ctx.createRadialGradient(600, 350, 200, 600, 350, 700);
    vigGrad.addColorStop(0, 'transparent');
    vigGrad.addColorStop(1, `rgba(0,0,0,${this.vignette})`);
    ctx.fillStyle = vigGrad;
    ctx.fillRect(-50, -50, 1300, 800);
    ctx.restore();
  }
}

// ============ PARTICLES ============
class Particles {
  constructor() { this.list = []; }
  emit(x, y, cfg) {
    for (let i = 0; i < (cfg.count || 10); i++) {
      this.list.push({
        x, y,
        vx: (Math.random() - 0.5) * (cfg.spread || 5) + (cfg.dirX || 0),
        vy: (Math.random() - 0.5) * (cfg.spread || 5) + (cfg.dirY || 0),
        size: cfg.size || 5, color: cfg.color || '#fff',
        life: cfg.life || 30, maxLife: cfg.life || 30,
        gravity: cfg.gravity || 0, glow: cfg.glow || false,
      });
    }
  }
  update() {
    this.list = this.list.filter(p => {
      p.vx *= 0.98; p.vy *= 0.98; p.vy += p.gravity;
      p.x += p.vx; p.y += p.vy; p.life--;
      return p.life > 0;
    });
    // AGGRESSIVE cap particles to prevent memory growth
    if (this.list.length > 100) this.list.splice(0, this.list.length - 60);
  }
  render(ctx) {
    this.list.forEach(p => {
      const a = p.life / p.maxLife;
      const radius = Math.max(0.5, p.size * a);
      ctx.globalAlpha = a;
      if (p.glow) {
        const grad = ctx.createRadialGradient(p.x, p.y, 0, p.x, p.y, radius * 3);
        grad.addColorStop(0, p.color); grad.addColorStop(1, 'transparent');
        ctx.fillStyle = grad;
        ctx.beginPath(); ctx.arc(p.x, p.y, radius * 3, 0, Math.PI * 2); ctx.fill();
      }
      ctx.fillStyle = p.color;
      ctx.beginPath(); ctx.arc(p.x, p.y, radius, 0, Math.PI * 2); ctx.fill();
    });
    ctx.globalAlpha = 1;
  }
}

// ============ SPIRIT (PLAYER) ============
class Spirit {
  constructor(cls) {
    this.cls = cls;
    this.pulse = Math.random() * Math.PI * 2;
    this.float = Math.random() * Math.PI * 2;
    this.particles = [];
    this.trail = [];
    this.anim = { state: 'idle', timer: 0, maxTimer: 45 };
  }
  
  update(p) {
    this.pulse += 0.12;
    this.float += 0.08;
    this.trail.unshift({ x: p.x, y: p.y, life: 16 });
    if (this.trail.length > 12) this.trail.pop();
    this.trail = this.trail.filter(t => { t.life--; return t.life > 0; });
    
    if (frame % 2 === 0) {
      const e = this.cls.element;
      this.particles.push({
        x: p.x + (Math.random() - 0.5) * 35, y: p.y - 45 - Math.random() * 50,
        vx: (Math.random() - 0.5) * (e === 'fire' ? 3 : 1.5),
        vy: e === 'fire' ? -4 - Math.random() * 3 : (Math.random() - 0.5) * 2,
        size: e === 'fire' ? 6 + Math.random() * 10 : 3 + Math.random() * 6,
        life: e === 'fire' ? 22 : 35, type: e,
      });
    }
    this.particles = this.particles.filter(pt => {
      pt.x += pt.vx; pt.y += pt.vy;
      if (pt.type === 'fire') pt.vy -= 0.15;
      pt.life--;
      return pt.life > 0;
    });
    // Cap spirit particles
    if (this.particles.length > 100) this.particles.splice(0, this.particles.length - 80);
    
    if (this.anim.timer > 0) this.anim.timer--;
    else this.anim.state = 'idle';
  }
  
  setAnim(s, dur = 45) {
    this.anim.state = s;
    this.anim.timer = dur;
    this.anim.maxTimer = dur;
  }
  
  render(ctx, p) {
    const pulse = Math.sin(this.pulse) * 0.2 + 1;
    const floatY = Math.sin(this.float) * 6;
    const cls = this.cls;
    
    ctx.save();
    ctx.translate(p.x, p.y + floatY);
    ctx.scale(p.facing, 1);
    if (p.invuln > 0 && frame % 4 < 2) ctx.globalAlpha = 0.35;
    
    // Trail
    this.trail.forEach((t, i) => {
      const a = t.life / 16 * 0.4;
      const radius = Math.max(1, (1 - i / 12) * 28);
      ctx.fillStyle = cls.trail + Math.floor(Math.max(0, a * 255)).toString(16).padStart(2, '0');
      ctx.beginPath(); ctx.arc((t.x - p.x) * p.facing, t.y - p.y - floatY, radius, 0, Math.PI * 2); ctx.fill();
    });
    
    // Particles
    this.particles.forEach(pt => {
      const a = pt.life / 35;
      ctx.globalAlpha = a;
      if (pt.type === 'fire') {
        const grad = ctx.createRadialGradient((pt.x - p.x) * p.facing, pt.y - p.y - floatY, 0, (pt.x - p.x) * p.facing, pt.y - p.y - floatY, pt.size);
        grad.addColorStop(0, '#fff'); grad.addColorStop(0.3, cls.core); grad.addColorStop(1, cls.color + '00');
        ctx.fillStyle = grad;
      } else {
        ctx.fillStyle = cls.glow;
      }
      ctx.beginPath(); ctx.arc((pt.x - p.x) * p.facing, pt.y - p.y - floatY, pt.size * pulse, 0, Math.PI * 2); ctx.fill();
    });
    ctx.globalAlpha = 1;
    
    // Glow
    const glowSize = 85 * pulse;
    const glowGrad = ctx.createRadialGradient(0, -55, 0, 0, -55, glowSize);
    glowGrad.addColorStop(0, cls.glow + '80'); glowGrad.addColorStop(0.5, cls.color + '40'); glowGrad.addColorStop(1, 'transparent');
    ctx.fillStyle = glowGrad;
    ctx.beginPath(); ctx.arc(0, -55, glowSize, 0, Math.PI * 2); ctx.fill();
    
    // Core body
    const bodyGrad = ctx.createRadialGradient(0, -55, 0, 0, -55, 40);
    bodyGrad.addColorStop(0, '#fff'); bodyGrad.addColorStop(0.4, cls.glow); bodyGrad.addColorStop(1, cls.color);
    ctx.fillStyle = bodyGrad;
    ctx.beginPath(); ctx.arc(0, -55, 35, 0, Math.PI * 2); ctx.fill();
    
    // Eyes
    ctx.fillStyle = '#000';
    ctx.beginPath();
    ctx.ellipse(-12, -60, 6, 8, 0, 0, Math.PI * 2);
    ctx.ellipse(12, -60, 6, 8, 0, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = cls.element === 'fire' ? '#ff0' : '#fff';
    ctx.beginPath();
    ctx.arc(-12, -60, 3, 0, Math.PI * 2);
    ctx.arc(12, -60, 3, 0, Math.PI * 2);
    ctx.fill();
    
    // === WEAPON RENDERING ===
    if (p.weapon) {
      const w = p.weapon;
      const weaponX = 45; // To the side of the spirit
      const weaponY = -55;
      const bobY = Math.sin(this.pulse * 2) * 3;
      
      ctx.save();
      ctx.translate(weaponX, weaponY + bobY);
      
      // Weapon glow
      ctx.shadowColor = w.glow;
      ctx.shadowBlur = 15;
      ctx.fillStyle = w.color;
      ctx.strokeStyle = w.glow;
      ctx.lineWidth = 2;
      
      if (w.meleeMult > (w.rangedMult || 0)) {
        // Sword/blade shape
        ctx.beginPath();
        ctx.moveTo(0, -30);
        ctx.lineTo(-6, -10);
        ctx.lineTo(-4, -10);
        ctx.lineTo(-4, 15);
        ctx.lineTo(4, 15);
        ctx.lineTo(4, -10);
        ctx.lineTo(6, -10);
        ctx.closePath();
        ctx.fill();
        ctx.stroke();
      } else {
        // Staff/wand shape
        ctx.beginPath();
        ctx.roundRect(-3, -25, 6, 45, 2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(0, -30, 8, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();
      }
      ctx.shadowBlur = 0;
      ctx.restore();
    }
    
    // === SHIELD EFFECT (when invuln from pickup) ===
    if (p.invuln > 60) {
      ctx.strokeStyle = '#6366f1';
      ctx.lineWidth = 3;
      ctx.shadowColor = '#818cf8';
      ctx.shadowBlur = 20;
      ctx.beginPath();
      ctx.arc(0, -50, 55, 0, Math.PI * 2);
      ctx.stroke();
      ctx.shadowBlur = 0;
    }
    
    // === DAMAGE BOOST AURA ===
    if (p.damageBoost > 0) {
      const boostPulse = Math.sin(frame * 0.2) * 0.3 + 0.7;
      ctx.fillStyle = `rgba(251, 191, 36, ${boostPulse * 0.3})`;
      ctx.beginPath();
      ctx.arc(0, -55, 50 + boostPulse * 10, 0, Math.PI * 2);
      ctx.fill();
    }
    
    // Animation effects
    const maxT = this.anim.maxTimer || 45;
    const prog = Math.max(0, Math.min(1, this.anim.timer / maxT));
    
    if (this.anim.state === 'melee' && prog > 0) {
      const radius = Math.max(1, 130 * (1 - prog));
      ctx.strokeStyle = cls.glow; ctx.lineWidth = Math.max(2, 16 * prog);
      ctx.shadowColor = cls.glow; ctx.shadowBlur = 30;
      ctx.beginPath(); ctx.arc(85 * (1 - prog), -55, radius, -1.3, 1.3); ctx.stroke();
      ctx.shadowBlur = 0;
    }
    if (this.anim.state === 'ranged' && prog > 0) {
      const radius = Math.max(1, 45 * prog);
      ctx.fillStyle = cls.glow; ctx.shadowColor = cls.glow; ctx.shadowBlur = 35;
      ctx.beginPath(); ctx.arc(55, -55, radius, 0, Math.PI * 2); ctx.fill();
      ctx.fillStyle = '#fff';
      ctx.beginPath(); ctx.arc(55, -55, radius * 0.4, 0, Math.PI * 2); ctx.fill();
      ctx.shadowBlur = 0;
    }
    if (this.anim.state === 'special' && prog > 0) {
      for (let ring = 0; ring < 2; ring++) {
        for (let i = 0; i < 12; i++) {
          const a = (i / 12) * Math.PI * 2 + (1 - prog) * Math.PI * 10;
          const dist = (160 + ring * 60) * (1 - prog);
          const r = Math.max(2, (25 - ring * 8) * prog);
          ctx.fillStyle = ring === 0 ? cls.color : cls.glow;
          ctx.globalAlpha = prog * (ring === 0 ? 1 : 0.6);
          ctx.beginPath(); ctx.arc(Math.cos(a) * dist, -55 + Math.sin(a) * dist * 0.5, r, 0, Math.PI * 2); ctx.fill();
        }
      }
      ctx.globalAlpha = 1;
    }
    if (this.anim.state === 'ultimate' && prog > 0) {
      const size = Math.max(1, 220 * prog);
      ctx.strokeStyle = cls.glow; ctx.lineWidth = Math.max(2, 10 * prog);
      ctx.shadowColor = cls.glow; ctx.shadowBlur = 40;
      ctx.beginPath(); ctx.arc(0, -55, size, 0, Math.PI * 2); ctx.stroke();
      const ultGrad = ctx.createRadialGradient(0, -55, 0, 0, -55, size * 0.8);
      ultGrad.addColorStop(0, '#fff'); ultGrad.addColorStop(0.5, cls.glow + '80'); ultGrad.addColorStop(1, 'transparent');
      ctx.fillStyle = ultGrad;
      ctx.beginPath(); ctx.arc(0, -55, Math.max(1, size * 0.8), 0, Math.PI * 2); ctx.fill();
      ctx.shadowBlur = 0;
    }
    
    ctx.restore();
  }
}

// ============ UNIQUE BOSS RENDERERS ============
function renderVoidTitan(ctx, b, bossData, anim) {
  const pulse = Math.sin(frame * 0.05) * 0.1 + 1;
  const hover = Math.sin(frame * 0.03) * 8;
  
  ctx.save();
  ctx.translate(b.x, b.y + hover);
  ctx.scale(b.facing, 1);
  
  // Void aura
  const auraGrad = ctx.createRadialGradient(0, -120, 30, 0, -120, 200 * pulse);
  auraGrad.addColorStop(0, '#6366f180'); auraGrad.addColorStop(0.5, '#312e8140'); auraGrad.addColorStop(1, 'transparent');
  ctx.fillStyle = auraGrad;
  ctx.beginPath(); ctx.arc(0, -120, 200 * pulse, 0, Math.PI * 2); ctx.fill();
  
  // Dark tendrils
  ctx.strokeStyle = '#312e81';
  ctx.lineWidth = 8;
  for (let i = 0; i < 6; i++) {
    const angle = (i / 6) * Math.PI * 2 + frame * 0.01;
    const len = 80 + Math.sin(frame * 0.05 + i) * 30;
    ctx.beginPath();
    ctx.moveTo(0, -100);
    ctx.quadraticCurveTo(
      Math.cos(angle) * len * 0.5, -100 + Math.sin(angle) * len * 0.5,
      Math.cos(angle) * len, -100 + Math.sin(angle) * len
    );
    ctx.stroke();
  }
  
  // Body - massive dark form
  ctx.fillStyle = '#0f0f1f';
  ctx.beginPath();
  ctx.moveTo(-70, 0);
  ctx.lineTo(-90, -80);
  ctx.lineTo(-80, -160);
  ctx.lineTo(-40, -220);
  ctx.lineTo(0, -240);
  ctx.lineTo(40, -220);
  ctx.lineTo(80, -160);
  ctx.lineTo(90, -80);
  ctx.lineTo(70, 0);
  ctx.closePath();
  ctx.fill();
  
  // Inner void core
  const coreGrad = ctx.createRadialGradient(0, -130, 0, 0, -130, 60);
  coreGrad.addColorStop(0, '#6366f1'); coreGrad.addColorStop(0.5, '#312e81'); coreGrad.addColorStop(1, '#0f0f1f');
  ctx.fillStyle = coreGrad;
  ctx.beginPath(); ctx.arc(0, -130, 50, 0, Math.PI * 2); ctx.fill();
  
  // Eye (single cyclopean)
  const eyeGlow = b.enraged ? '#c026d3' : '#a5b4fc';
  ctx.fillStyle = eyeGlow;
  ctx.shadowColor = eyeGlow;
  ctx.shadowBlur = 30;
  ctx.beginPath();
  ctx.ellipse(0, -180, 25 * pulse, 15 * pulse, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = '#000';
  ctx.beginPath();
  ctx.ellipse(0, -180, 10, 10, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.shadowBlur = 0;
  
  // Floating runes
  ctx.strokeStyle = '#6366f1';
  ctx.lineWidth = 2;
  for (let i = 0; i < 4; i++) {
    const angle = (i / 4) * Math.PI * 2 + frame * 0.02;
    const dist = 100 + Math.sin(frame * 0.03 + i * 2) * 20;
    ctx.save();
    ctx.translate(Math.cos(angle) * dist, -130 + Math.sin(angle) * 50);
    ctx.rotate(frame * 0.02);
    ctx.strokeRect(-10, -10, 20, 20);
    ctx.restore();
  }
  
  ctx.restore();
}

function renderFlameWyrm(ctx, b, bossData, anim) {
  const slither = Math.sin(frame * 0.1) * 20;
  const coil = Math.sin(frame * 0.05) * 0.1;
  
  ctx.save();
  ctx.translate(b.x, b.y);
  ctx.scale(b.facing, 1);
  ctx.rotate(coil);
  
  // Fire trail
  for (let i = 0; i < 8; i++) {
    const t = (frame * 0.1 + i * 0.5) % (Math.PI * 2);
    ctx.fillStyle = `rgba(255, ${100 + i * 20}, 0, ${0.5 - i * 0.05})`;
    ctx.beginPath();
    ctx.arc(-30 - i * 25 + Math.sin(t) * 10, -60 + Math.cos(t) * 5, 20 - i * 2, 0, Math.PI * 2);
    ctx.fill();
  }
  
  // Serpent body segments
  const bodyColor = b.enraged ? '#fbbf24' : '#f97316';
  const segments = [
    { x: 0, y: -60, size: 50 },
    { x: -40, y: -50, size: 45 },
    { x: -85, y: -55, size: 40 },
    { x: -125, y: -65, size: 35 },
    { x: -160, y: -60, size: 30 },
  ];
  
  segments.forEach((seg, i) => {
    const yOff = Math.sin(frame * 0.1 + i * 0.8) * 10;
    ctx.fillStyle = i === 0 ? bodyColor : `hsl(25, 90%, ${50 - i * 5}%)`;
    ctx.beginPath();
    ctx.arc(seg.x, seg.y + yOff, seg.size, 0, Math.PI * 2);
    ctx.fill();
    
    // Scales pattern
    if (i > 0) {
      ctx.fillStyle = '#c2410c';
      for (let s = 0; s < 3; s++) {
        const angle = (s / 3) * Math.PI - Math.PI / 2;
        ctx.beginPath();
        ctx.arc(seg.x + Math.cos(angle) * seg.size * 0.6, seg.y + yOff + Math.sin(angle) * seg.size * 0.6, 5, 0, Math.PI * 2);
        ctx.fill();
      }
    }
  });
  
  // Head
  ctx.fillStyle = bodyColor;
  ctx.beginPath();
  ctx.ellipse(30, -60, 60, 40, 0.2, 0, Math.PI * 2);
  ctx.fill();
  
  // Jaw
  const jawOpen = anim.state === 'attack' ? 0.3 : 0.1;
  ctx.fillStyle = '#c2410c';
  ctx.save();
  ctx.translate(50, -40);
  ctx.rotate(jawOpen);
  ctx.beginPath();
  ctx.ellipse(10, 0, 30, 15, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.restore();
  
  // Eyes (reptilian)
  ctx.fillStyle = '#fbbf24';
  ctx.shadowColor = '#fbbf24';
  ctx.shadowBlur = 20;
  ctx.beginPath();
  ctx.ellipse(20, -80, 12, 8, 0.3, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = '#000';
  ctx.beginPath();
  ctx.ellipse(22, -80, 4, 8, 0.3, 0, Math.PI * 2);
  ctx.fill();
  ctx.shadowBlur = 0;
  
  // Fire breath hint
  if (anim.state === 'breath') {
    const breathGrad = ctx.createRadialGradient(80, -50, 0, 80, -50, 150);
    breathGrad.addColorStop(0, '#ff6b35'); breathGrad.addColorStop(0.5, '#ff450080'); breathGrad.addColorStop(1, 'transparent');
    ctx.fillStyle = breathGrad;
    ctx.beginPath();
    ctx.moveTo(60, -60);
    ctx.lineTo(200, -100);
    ctx.lineTo(200, 0);
    ctx.closePath();
    ctx.fill();
  }
  
  ctx.restore();
}

function renderFrostQueen(ctx, b, bossData, anim) {
  const regal = Math.sin(frame * 0.02) * 3;
  const iceShimmer = (frame % 60) / 60;
  
  ctx.save();
  ctx.translate(b.x, b.y + regal);
  ctx.scale(b.facing, 1);
  
  // Ice aura (reduced for performance)
  ctx.strokeStyle = '#06b6d480';
  ctx.lineWidth = 2;
  for (let i = 0; i < 2; i++) {
    const size = 100 + i * 50 + Math.sin(frame * 0.03 + i) * 15;
    ctx.beginPath();
    ctx.arc(0, -100, size, 0, Math.PI * 2);
    ctx.stroke();
  }
  
  // Flowing cape/dress
  ctx.fillStyle = '#0e7490';
  ctx.beginPath();
  ctx.moveTo(-50, -40);
  ctx.quadraticCurveTo(-80, 20, -60 + Math.sin(frame * 0.05) * 10, 0);
  ctx.lineTo(60 + Math.sin(frame * 0.05 + 1) * 10, 0);
  ctx.quadraticCurveTo(80, 20, 50, -40);
  ctx.closePath();
  ctx.fill();
  
  // Body
  ctx.fillStyle = '#06b6d4';
  ctx.beginPath();
  ctx.ellipse(0, -80, 35, 50, 0, 0, Math.PI * 2);
  ctx.fill();
  
  // Ice crystal details
  ctx.fillStyle = '#67e8f9';
  ctx.beginPath();
  ctx.moveTo(0, -130); ctx.lineTo(-15, -90); ctx.lineTo(15, -90); ctx.closePath();
  ctx.fill();
  ctx.beginPath();
  ctx.moveTo(-20, -100); ctx.lineTo(-35, -80); ctx.lineTo(-20, -60); ctx.closePath();
  ctx.fill();
  ctx.beginPath();
  ctx.moveTo(20, -100); ctx.lineTo(35, -80); ctx.lineTo(20, -60); ctx.closePath();
  ctx.fill();
  
  // Crown
  ctx.fillStyle = '#f0f9ff';
  ctx.beginPath();
  ctx.moveTo(-30, -160);
  ctx.lineTo(-20, -200);
  ctx.lineTo(-10, -170);
  ctx.lineTo(0, -210);
  ctx.lineTo(10, -170);
  ctx.lineTo(20, -200);
  ctx.lineTo(30, -160);
  ctx.closePath();
  ctx.fill();
  
  // Face
  ctx.fillStyle = '#cffafe';
  ctx.beginPath();
  ctx.ellipse(0, -150, 25, 30, 0, 0, Math.PI * 2);
  ctx.fill();
  
  // Eyes (cold, calculating)
  ctx.fillStyle = b.enraged ? '#f0f9ff' : '#0891b2';
  ctx.shadowColor = '#06b6d4';
  ctx.shadowBlur = 15;
  ctx.beginPath();
  ctx.ellipse(-10, -155, 5, 7, 0, 0, Math.PI * 2);
  ctx.ellipse(10, -155, 5, 7, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.shadowBlur = 0;
  
  // Ice scepter
  ctx.fillStyle = '#67e8f9';
  ctx.beginPath();
  ctx.roundRect(45, -140, 8, 100, 4);
  ctx.fill();
  ctx.fillStyle = '#f0f9ff';
  ctx.beginPath();
  ctx.moveTo(49, -140);
  ctx.lineTo(35, -170);
  ctx.lineTo(49, -180);
  ctx.lineTo(63, -170);
  ctx.closePath();
  ctx.fill();
  
  // Floating ice shards (reduced)
  for (let i = 0; i < 3; i++) {
    const angle = (i / 3) * Math.PI * 2 + frame * 0.015;
    const dist = 80 + Math.sin(frame * 0.02 + i * 2) * 15;
    ctx.save();
    ctx.translate(Math.cos(angle) * dist, -100 + Math.sin(angle) * 40);
    ctx.rotate(angle + frame * 0.02);
    ctx.fillStyle = '#67e8f9';
    ctx.beginPath();
    ctx.moveTo(0, -15); ctx.lineTo(-8, 0); ctx.lineTo(0, 15); ctx.lineTo(8, 0); ctx.closePath();
    ctx.fill();
    ctx.restore();
  }
  
  ctx.restore();
}

// ============ CREATE GAME ============
let bg, particles, screenFx, spirit, bossRenderer;

// ============ PLATFORM SYSTEM (SOLID - Player AND Boss) ============
const PLATFORMS = [
  { x: 180, y: 440, width: 200, height: 25, type: 'stone' },   // Left ground platform
  { x: 820, y: 440, width: 200, height: 25, type: 'stone' },   // Right ground platform  
  { x: 450, y: 340, width: 300, height: 25, type: 'metal' },   // Center mid platform
  { x: 250, y: 260, width: 150, height: 20, type: 'crystal' }, // Left high platform
  { x: 800, y: 260, width: 150, height: 20, type: 'crystal' }, // Right high platform
];

// Platform collision for any entity (player or boss)
function checkPlatformCollision(entity, prevY) {
  if (entity.vy < 0) return null; // Only when falling
  
  for (const plat of PLATFORMS) {
    if (entity.x >= plat.x - 20 && entity.x <= plat.x + plat.width + 20 &&
        entity.y >= plat.y && entity.y <= plat.y + plat.height + 10 &&
        prevY < plat.y) {
      return plat;
    }
  }
  return null;
}

// ============ WEAPON SYSTEM (Super Smash Bros Style) ============
const WEAPONS = {
  // Tier 1 - Basic (Common)
  wooden_sword: { tier: 1, name: 'Wooden Sword', meleeMult: 1.3, color: '#8B4513', glow: '#D2691E', effect: 'none' },
  fire_wand: { tier: 1, name: 'Fire Wand', rangedMult: 1.3, color: '#ff6b35', glow: '#fbbf24', effect: 'burn' },
  
  // Tier 2 - Medium (Uncommon)  
  steel_blade: { tier: 2, name: 'Steel Blade', meleeMult: 1.8, color: '#C0C0C0', glow: '#E8E8E8', effect: 'bleed' },
  crystal_staff: { tier: 2, name: 'Crystal Staff', rangedMult: 1.8, specialMult: 1.5, color: '#a78bfa', glow: '#c4b5fd', effect: 'mana_regen' },
  shadow_dagger: { tier: 2, name: 'Shadow Dagger', meleeMult: 1.5, speedMult: 1.4, color: '#10b981', glow: '#34d399', effect: 'lifesteal' },
  
  // Tier 3 - Legendary (Rare)
  inferno_blade: { tier: 3, name: 'Inferno Blade', meleeMult: 2.5, rangedMult: 2.0, color: '#ef4444', glow: '#fca5a5', element: 'fire', effect: 'explosion' },
  void_scepter: { tier: 3, name: 'Void Scepter', rangedMult: 2.5, specialMult: 2.0, color: '#6366f1', glow: '#818cf8', element: 'void', effect: 'slow_enemy' },
  divine_hammer: { tier: 3, name: 'Divine Hammer', meleeMult: 3.0, color: '#fbbf24', glow: '#fef3c7', element: 'holy', effect: 'stun' },
};

const WeaponSystem = {
  droppedWeapons: [],
  spawnTimer: 0,
  spawnInterval: 420, // 7 seconds at 60fps
  
  reset() {
    this.droppedWeapons = [];
    this.spawnTimer = 0;
    this.announcement = null;
  },
  
  update() {
    this.spawnTimer++;
    
    // Spawn weapons periodically (fall from sky)
    if (this.spawnTimer >= this.spawnInterval && this.droppedWeapons.length < 2) {
      this.spawnTimer = 0;
      this.spawnWeapon();
    }
    
    // Update falling weapons
    this.droppedWeapons = this.droppedWeapons.filter(w => {
      // Gravity while falling
      if (!w.landed) {
        w.vy += 0.5;
        w.y += w.vy;
        w.rotation += 0.1;
        
        // Check platform landing
        for (const plat of PLATFORMS) {
          if (w.x >= plat.x && w.x <= plat.x + plat.width && w.y >= plat.y - 15) {
            w.y = plat.y - 15;
            w.landed = true;
            w.vy = 0;
            break;
          }
        }
        
        // Ground landing
        if (w.y >= CFG.GROUND_Y - 15) {
          w.y = CFG.GROUND_Y - 15;
          w.landed = true;
          w.vy = 0;
        }
      }
      
      w.life--;
      w.floatY = w.landed ? Math.sin(w.life * 0.08) * 3 : 0;
      
      // Player pickup
      if (game && game.player) {
        const p = game.player;
        const dx = Math.abs(p.x - w.x);
        const dy = Math.abs((p.y - 40) - w.y);
        if (dx < 45 && dy < 45) {
          this.collectWeapon(w);
          return false;
        }
      }
      
      return w.life > 0;
    });
  },
  
  spawnWeapon() {
    // Weighted tier selection
    const roll = Math.random();
    let tier;
    if (roll < 0.55) tier = 1;      // 55% Tier 1
    else if (roll < 0.85) tier = 2; // 30% Tier 2
    else tier = 3;                   // 15% Tier 3
    
    // Get weapons of this tier
    const tierWeapons = Object.entries(WEAPONS).filter(([k, v]) => v.tier === tier);
    const [weaponKey, weaponData] = tierWeapons[Math.floor(Math.random() * tierWeapons.length)];
    
    // Spawn from top of screen
    const x = 150 + Math.random() * 900;
    
    this.droppedWeapons.push({
      key: weaponKey,
      data: weaponData,
      x, y: -50,
      vy: 0,
      rotation: 0,
      floatY: 0,
      landed: false,
      life: 720, // 12 seconds
    });
    
    // Announce spawn with dedicated announcement (not spawnDmgNum to avoid spam)
    WeaponSystem.announcement = { text: weaponData.name + '!', timer: 90, color: weaponData.glow };
    playSound(tier === 3 ? 'crit' : 'menu');
  },
  
  // Dedicated weapon announcement
  announcement: null,
  
  collectWeapon(weapon) {
    const p = game.player;
    p.weapon = weapon.data;
    p.weaponKey = weapon.key;
    p.weaponTimer = 900; // 15 seconds
    
    // Show pickup announcement
    WeaponSystem.announcement = { text: weapon.data.name + ' EQUIPPED!', timer: 60, color: weapon.data.glow };
    spawnEffect('weapon_collect', weapon.x, weapon.y, { color: weapon.data.glow, size: 80 });
    playSound('crit');
  },
  
  render(ctx) {
    this.droppedWeapons.forEach(w => {
      const alpha = Math.min(1, w.life / 60);
      ctx.globalAlpha = alpha;
      
      ctx.save();
      ctx.translate(w.x, w.y + w.floatY);
      ctx.rotate(w.rotation);
      
      // Glow based on tier
      ctx.shadowColor = w.data.glow;
      ctx.shadowBlur = w.data.tier * 10;
      
      // Weapon shape
      ctx.fillStyle = w.data.color;
      ctx.strokeStyle = w.data.glow;
      ctx.lineWidth = 2;
      
      if (w.key.includes('sword') || w.key.includes('blade') || w.key.includes('dagger')) {
        // Sword shape
        ctx.beginPath();
        ctx.moveTo(0, -25);
        ctx.lineTo(-8, -5);
        ctx.lineTo(-4, -5);
        ctx.lineTo(-4, 20);
        ctx.lineTo(4, 20);
        ctx.lineTo(4, -5);
        ctx.lineTo(8, -5);
        ctx.closePath();
        ctx.fill();
        ctx.stroke();
      } else if (w.key.includes('wand') || w.key.includes('staff') || w.key.includes('scepter')) {
        // Staff shape
        ctx.beginPath();
        ctx.roundRect(-4, -20, 8, 40, 2);
        ctx.fill();
        // Orb on top
        ctx.beginPath();
        ctx.arc(0, -25, 10, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();
      } else if (w.key.includes('hammer')) {
        // Hammer shape
        ctx.beginPath();
        ctx.roundRect(-4, -5, 8, 30, 2);
        ctx.fill();
        ctx.beginPath();
        ctx.roundRect(-15, -25, 30, 20, 3);
        ctx.fill();
        ctx.stroke();
      }
      
      ctx.restore();
      ctx.shadowBlur = 0;
      ctx.globalAlpha = 1;
    });
    
    // Render weapon announcement (centered, big text)
    if (this.announcement && this.announcement.timer > 0) {
      const ann = this.announcement;
      const alpha = Math.min(1, ann.timer / 30);
      const scale = 1 + (1 - alpha) * 0.3;
      
      ctx.save();
      ctx.globalAlpha = alpha;
      ctx.font = `bold ${36 * scale}px sans-serif`;
      ctx.textAlign = 'center';
      ctx.shadowColor = ann.color;
      ctx.shadowBlur = 20;
      ctx.strokeStyle = '#000';
      ctx.lineWidth = 4;
      ctx.strokeText(ann.text, 600, 150);
      ctx.fillStyle = ann.color;
      ctx.fillText(ann.text, 600, 150);
      ctx.restore();
      
      ann.timer--;
    }
  }
};

// ============ ITEM PICKUP SYSTEM (Enhanced) ============
const ItemSystem = {
  items: [],
  spawnTimer: 0,
  spawnInterval: 240, // 4 seconds at 60fps (faster spawns)
  
  reset() {
    this.items = [];
    this.spawnTimer = 0;
  },
  
  update() {
    this.spawnTimer++;
    
    // Spawn items periodically - allow more on screen
    if (this.spawnTimer >= this.spawnInterval && this.items.length < 5) {
      this.spawnTimer = 0;
      this.spawnItem();
    }
    
    // Update existing items
    this.items = this.items.filter(item => {
      // Falling animation
      if (!item.landed) {
        item.vy += 0.4;
        item.y += item.vy;
        
        // Platform landing
        for (const plat of PLATFORMS) {
          if (item.x >= plat.x && item.x <= plat.x + plat.width && item.y >= plat.y - 20) {
            item.y = plat.y - 20;
            item.landed = true;
            item.vy = 0;
            break;
          }
        }
        
        // Ground landing
        if (item.y >= CFG.GROUND_Y - 20) {
          item.y = CFG.GROUND_Y - 20;
          item.landed = true;
          item.vy = 0;
        }
      }
      
      item.life--;
      item.floatY = item.landed ? Math.sin(item.life * 0.1) * 5 : 0;
      
      // Check player pickup
      if (game && game.player) {
        const p = game.player;
        const dx = Math.abs(p.x - item.x);
        const dy = Math.abs((p.y - 40) - item.y);
        if (dx < 40 && dy < 40) {
          this.collectItem(item);
          return false;
        }
      }
      
      return item.life > 0;
    });
  },
  
  spawnItem() {
    // Weighted random item type - Knowledge pickups are common!
    const roll = Math.random();
    let type;
    if (roll < 0.20) type = 'health';       // 20%
    else if (roll < 0.35) type = 'mana';    // 15%
    else if (roll < 0.45) type = 'shield';  // 10%
    else if (roll < 0.55) type = 'damage';  // 10%
    else if (roll < 0.60) type = 'ultimate'; // 5%
    else type = 'knowledge';                 // 40% - KNOWLEDGE PICKUP! (more common)
    
    // Spawn from top (falls down)
    const x = 150 + Math.random() * 900;
    
    this.items.push({
      type, x, y: -30,
      vy: 0,
      floatY: 0,
      landed: false,
      life: 600, // 10 seconds
      color: type === 'health' ? '#22c55e' : type === 'mana' ? '#3b82f6' : 
             type === 'shield' ? '#f0f0f0' : type === 'damage' ? '#ef4444' : 
             type === 'ultimate' ? '#fbbf24' : '#06b6d4' // Knowledge = cyan
    });
  },
  
  collectItem(item) {
    const p = game.player;
    
    // Brief pause to see what was collected
    game.gamePaused = true;
    game.itemPauseTimer = 45; // 0.75 seconds pause
    game.itemCollected = item.type;
    
    // Grant invulnerability during and after item collection
    p.invuln = Math.max(p.invuln, 90);
    
    switch (item.type) {
      case 'health':
        const healAmt = Math.round(p.maxHp * 0.20);
        p.hp = Math.min(p.maxHp, p.hp + healAmt);
        spawnDmgNum(p.x, p.y - 80, '+' + healAmt + ' HP', 'heal');
        break;
      case 'mana':
        p.mana = Math.min(p.maxMana, p.mana + 40);
        spawnDmgNum(p.x, p.y - 80, '+40 MANA', 'heal');
        break;
      case 'shield':
        p.invuln = Math.max(p.invuln, 300); // 5 seconds invuln
        spawnDmgNum(p.x, p.y - 80, 'SHIELD!', 'parry');
        break;
      case 'damage':
        p.damageBoost = 240; // 4 seconds of 2x damage
        spawnDmgNum(p.x, p.y - 80, '2X DAMAGE!', 'crit');
        break;
      case 'ultimate':
        p.ultCharge = 100;
        spawnDmgNum(p.x, p.y - 80, 'ULT READY!', 'ult');
        screenFx.addTint('#fbbf24', 0.4);
        break;
      case 'knowledge':
        // Trigger knowledge challenge
        KnowledgeSystem.startChallenge();
        spawnDmgNum(p.x, p.y - 80, 'CHALLENGE!', 'special');
        break;
    }
    
    spawnEffect('item_collect', item.x, item.y, { color: item.color, size: 80 });
    playSound('crit');
    
    // Haptic feedback
    if (typeof Haptics !== 'undefined') Haptics.success();
  },
  
  render(ctx) {
    this.items.forEach(item => {
      const alpha = Math.min(1, item.life / 60); // Fade out in last second
      ctx.globalAlpha = alpha;
      
      // Glow
      ctx.shadowColor = item.color;
      ctx.shadowBlur = 15;
      
      // Item shape based on type
      ctx.fillStyle = item.color;
      const y = item.y + item.floatY;
      
      if (item.type === 'health') {
        // Heart shape
        ctx.beginPath();
        ctx.arc(item.x - 8, y - 5, 10, Math.PI, 0);
        ctx.arc(item.x + 8, y - 5, 10, Math.PI, 0);
        ctx.lineTo(item.x, y + 15);
        ctx.fill();
      } else if (item.type === 'mana') {
        // Diamond shape
        ctx.beginPath();
        ctx.moveTo(item.x, y - 15);
        ctx.lineTo(item.x + 12, y);
        ctx.lineTo(item.x, y + 15);
        ctx.lineTo(item.x - 12, y);
        ctx.closePath();
        ctx.fill();
      } else if (item.type === 'shield') {
        // Shield shape
        ctx.beginPath();
        ctx.moveTo(item.x - 12, y - 12);
        ctx.lineTo(item.x + 12, y - 12);
        ctx.lineTo(item.x + 12, y + 5);
        ctx.lineTo(item.x, y + 15);
        ctx.lineTo(item.x - 12, y + 5);
        ctx.closePath();
        ctx.fill();
      } else if (item.type === 'damage') {
        // Flame/star shape
        ctx.beginPath();
        for (let i = 0; i < 5; i++) {
          const angle = (i / 5) * Math.PI * 2 - Math.PI / 2;
          const r = i % 2 === 0 ? 14 : 7;
          const px = item.x + Math.cos(angle) * r;
          const py = y + Math.sin(angle) * r;
          if (i === 0) ctx.moveTo(px, py);
          else ctx.lineTo(px, py);
        }
        ctx.closePath();
        ctx.fill();
      } else if (item.type === 'ultimate') {
        // Lightning bolt
        ctx.beginPath();
        ctx.moveTo(item.x - 5, y - 15);
        ctx.lineTo(item.x + 8, y - 5);
        ctx.lineTo(item.x, y - 2);
        ctx.lineTo(item.x + 5, y + 15);
        ctx.lineTo(item.x - 8, y + 2);
        ctx.lineTo(item.x, y);
        ctx.closePath();
        ctx.fill();
      } else if (item.type === 'knowledge') {
        // Question mark "?" - KNOWLEDGE PICKUP
        ctx.font = 'bold 32px sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillStyle = '#06b6d4';
        ctx.fillText('?', item.x, y);
        // Glowing circle around it
        ctx.strokeStyle = '#06b6d4';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.arc(item.x, y, 20, 0, Math.PI * 2);
        ctx.stroke();
      }
      
      ctx.shadowBlur = 0;
      ctx.globalAlpha = 1;
    });
  }
};

// ============ KNOWLEDGE CHALLENGE SYSTEM ============
// Questions as pickups - player can still move while answering!
const KnowledgeSystem = {
  active: false,
  question: null,
  timer: 0,
  maxTime: 600, // 10 seconds
  selectedAnswer: -1,
  questionsAnswered: 0,      // Track total answered correctly
  requiredQuestions: 8,       // Must answer this many to defeat boss
  
  reset() {
    this.active = false;
    this.question = null;
    this.timer = 0;
    this.selectedAnswer = -1;
    this.questionsAnswered = 0;
  },
  
  canDefeatBoss() {
    return this.questionsAnswered >= this.requiredQuestions;
  },
  
  startChallenge() {
    // Get a random question from QuizSystem's pool
    this.question = QuizSystem.selectQuestion();
    this.active = true;
    this.timer = this.maxTime;
    this.selectedAnswer = -1;
    
    // === PAUSE GAME DURING KNOWLEDGE CHALLENGE ===
    if (game) {
      game.gamePaused = true;
      game.player.vx = 0;
      game.player.vy = 0;
      game.boss.vx = 0;
      game.boss.vy = 0;
    }
    
    playSound('menu');
  },
  
  submitAnswer(idx) {
    if (!this.active || this.selectedAnswer >= 0) return;
    
    this.selectedAnswer = idx;
    const correct = idx === this.question.correct;
    const p = game.player;
    
    if (correct) {
      // CORRECT! Power boost + count toward victory
      this.questionsAnswered++;
      p.damageBoost = Math.max(p.damageBoost, 300); // 5 seconds 2x damage
      p.mana = Math.min(p.maxMana, p.mana + 30);
      p.ultCharge = Math.min(100, p.ultCharge + 25);
      spawnDmgNum(p.x, p.y - 120, 'CORRECT! +1', 'crit');
      spawnEffect('hit', p.x, p.y - 60, { color: '#22c55e', size: 120 });
      screenFx.addTint('#22c55e', 0.3);
      playSound('crit');
      
      // Show progress
      spawnDmgNum(p.x, p.y - 160, this.questionsAnswered + '/' + this.requiredQuestions, 'heal');
      
      // Track for standards coverage
      if (this.question.standard) {
        QuizSystem.coveredStandards.add(this.question.standard);
      }
    } else {
      // WRONG - Player takes damage!
      const dmgAmt = Math.round(p.maxHp * 0.15); // 15% max HP damage
      p.hp = Math.max(1, p.hp - dmgAmt);
      game.stats.damageTaken += dmgAmt;
      spawnDmgNum(p.x, p.y - 100, '-' + dmgAmt, 'hurt');
      spawnEffect('hit', p.x, p.y - 60, { color: '#ef4444', size: 80 });
      screenFx.addTint('#ef4444', 0.3);
      screenFx.addShake(15);
      playSound('hurt');
    }
    
    // Close after short delay
    safeTimeout(() => {
      this.active = false;
      this.question = null;
      // Unpause game
      if (game) {
        game.gamePaused = false;
        // Grant brief invulnerability
        game.player.invuln = Math.max(game.player.invuln, 60);
      }
    }, 500);
  },
  
  update() {
    if (!this.active) return;
    
    this.timer--;
    if (this.timer <= 0 && this.selectedAnswer < 0) {
      // Time's up - counts as wrong, damage player!
      const p = game.player;
      const dmgAmt = Math.round(p.maxHp * 0.15);
      p.hp = Math.max(1, p.hp - dmgAmt);
      game.stats.damageTaken += dmgAmt;
      spawnDmgNum(p.x, p.y - 100, 'TIME UP! -' + dmgAmt, 'hurt');
      screenFx.addShake(10);
      playSound('hurt');
      this.active = false;
      this.question = null;
      // Unpause game
      if (game) {
        game.gamePaused = false;
        game.player.invuln = Math.max(game.player.invuln, 60);
      }
    }
  },
  
  render(ctx) {
    if (!this.active || !this.question) return;
    
    const q = this.question;
    
    // Small panel in top-right corner (doesn't cover gameplay)
    const panelX = 700;
    const panelY = 100;
    const panelW = 480;
    const panelH = 280;
    
    // Panel background (semi-transparent)
    ctx.fillStyle = 'rgba(20, 20, 40, 0.9)';
    ctx.strokeStyle = '#06b6d4';
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.roundRect(panelX, panelY, panelW, panelH, 12);
    ctx.fill();
    ctx.stroke();
    
    // "KNOWLEDGE CHALLENGE" header
    ctx.fillStyle = '#06b6d4';
    ctx.font = 'bold 18px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText('‚ö° KNOWLEDGE CHALLENGE ‚ö°', panelX + panelW/2, panelY + 25);
    
    // Timer bar
    const timerPct = this.timer / this.maxTime;
    ctx.fillStyle = '#1a1a2e';
    ctx.fillRect(panelX + 20, panelY + 35, panelW - 40, 8);
    ctx.fillStyle = timerPct > 0.3 ? '#22c55e' : '#ef4444';
    ctx.fillRect(panelX + 20, panelY + 35, (panelW - 40) * timerPct, 8);
    
    // Question text (smaller)
    ctx.fillStyle = '#fff';
    ctx.font = '16px sans-serif';
    ctx.textAlign = 'center';
    
    // Word wrap question
    const words = q.q.split(' ');
    let line = '';
    let lineY = panelY + 70;
    for (const word of words) {
      const testLine = line + word + ' ';
      if (ctx.measureText(testLine).width > panelW - 40) {
        ctx.fillText(line.trim(), panelX + panelW/2, lineY);
        line = word + ' ';
        lineY += 22;
      } else {
        line = testLine;
      }
    }
    ctx.fillText(line.trim(), panelX + panelW/2, lineY);
    
    // Answer buttons (use 1,2,3,4 keys)
    const labels = ['1', '2', '3', '4'];
    const btnStartY = panelY + 130;
    
    q.a.forEach((ans, i) => {
      const btnY = btnStartY + i * 36;
      let bgColor = 'rgba(50, 50, 80, 0.8)';
      let borderColor = '#4b5563';
      
      if (this.selectedAnswer === i) {
        bgColor = i === q.correct ? 'rgba(34, 197, 94, 0.6)' : 'rgba(239, 68, 68, 0.6)';
        borderColor = i === q.correct ? '#22c55e' : '#ef4444';
      }
      
      ctx.fillStyle = bgColor;
      ctx.strokeStyle = borderColor;
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.roundRect(panelX + 15, btnY, panelW - 30, 32, 6);
      ctx.fill();
      ctx.stroke();
      
      // Key hint
      ctx.fillStyle = '#06b6d4';
      ctx.font = 'bold 14px sans-serif';
      ctx.textAlign = 'left';
      ctx.fillText('[' + labels[i] + ']', panelX + 25, btnY + 21);
      
      // Answer text
      ctx.fillStyle = '#fff';
      ctx.font = '14px sans-serif';
      ctx.fillText(ans.substring(0, 50), panelX + 55, btnY + 21);
    });
    
    // Hint at bottom
    ctx.fillStyle = '#888';
    ctx.font = '12px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText('Press 1-4 to answer ‚Ä¢ Keep fighting!', panelX + panelW/2, panelY + panelH - 10);
  },
  
  handleKey(key) {
    if (!this.active) return false;
    
    if (key === '1') { this.submitAnswer(0); return true; }
    if (key === '2') { this.submitAnswer(1); return true; }
    if (key === '3') { this.submitAnswer(2); return true; }
    if (key === '4') { this.submitAnswer(3); return true; }
    return false;
  }
};

function createGame(clsKey, bossKey, diff) {
  const cls = CLASSES[clsKey];
  const bossData = BOSSES[bossKey];
  const mult = CFG.DIFFICULTY[diff];
  
  // Show tutorial for first-time mobile users
  if (typeof Tutorial !== 'undefined' && !Tutorial.shown) {
    const isMobile = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);
    if (isMobile) {
      Tutorial.show();
    }
  }
  
  bg = new ParallaxBG();
  bg.setTheme(bossKey);
  particles = new Particles();
  screenFx = new ScreenFX();
  spirit = new Spirit(cls);
  
  // Reset all systems
  QuizSystem.reset();
  HPGates.reset();
  ItemSystem.reset();
  WeaponSystem.reset();
  PhaseManager.reset();
  KnowledgeSystem.reset();
  if (typeof TierSystem !== 'undefined') TierSystem.reset();
  if (typeof MinionSystem !== 'undefined') MinionSystem.reset();
  if (typeof ExecutionSystem !== 'undefined') ExecutionSystem.reset();
  if (typeof StudyMode !== 'undefined') StudyMode.reset();
  clearAllTimeouts();
  
  // Select boss renderer
  bossRenderer = bossKey === 'FLAME_WYRM' ? renderFlameWyrm :
                 bossKey === 'FROST_QUEEN' ? renderFrostQueen : renderVoidTitan;
  
  const maxHp = Math.round(bossData.hp * mult.bossHp);
  
  return {
    player: {
      x: 200, y: CFG.GROUND_Y, vx: 0, vy: 0,
      hp: cls.hp, maxHp: cls.hp, mana: cls.mana, maxMana: cls.mana,
      facing: 1, grounded: true, airJumps: CFG.AIR_JUMPS,
      attackTimer: 0, specialCD: 0, ultCharge: 0,
      invuln: 0, combo: 0, comboTimer: 0,
      class: clsKey, cls, classKey: clsKey, dashCD: 0, stagger: 0,
      parryWindow: 0, slowedTimer: 0, slowAmount: 1,
      damageBoost: 0, // For damage pickup
      weapon: null, weaponKey: null, weaponTimer: 0, // Weapon system
      onPlatform: null, // Current platform player is on
      
      // === ADVANCED MOVEMENT ===
      coyoteTimer: 0,          // Coyote time counter
      jumpBuffered: false,     // Jump input buffered
      jumpBufferTimer: 0,      // Buffer timer
      wasGrounded: true,       // Was grounded last frame
      jumpHeld: false,         // Is jump button held
      variableJumpUsed: false, // Has variable jump cut been applied
      
      // Wall mechanics
      wallSliding: false,      // Currently wall sliding
      wallDir: 0,              // Direction of wall (-1 left, 1 right)
      wallJumpTimer: 0,        // Prevents air control after wall jump
      touchingWall: false,     // Currently touching a wall
      
      // Ground pound
      groundPounding: false,   // Currently ground pounding
      groundPoundReady: true,  // Can use ground pound
      
      // Roll
      rolling: false,          // Currently rolling
      rollTimer: 0,            // Roll duration
      rollDir: 1,              // Roll direction
      rollBuffered: false,     // Roll input buffered for landing
      
      // === COMBO SYSTEM ===
      comboChain: [],          // Current combo sequence
      comboTimer: 0,           // Time to next combo input
      comboHits: 0,            // Hits in current combo
      attackCharging: false,   // Charging attack
      chargeTimer: 0,          // Charge duration
      chargeKey: null,         // Which attack is charging
      lastAttackType: null,    // 'light', 'heavy', 'launcher', 'sweep'
      
      // === PARRY REWARDS ===
      parryCritWindow: 0,      // Frames of crit opportunity after parry
      perfectParry: false,     // Was last parry perfect timing
      
      // === ELEMENTAL ===
      burnTimer: 0,            // Burning DOT
      freezeTimer: 0,          // Frozen/slowed
      voidDrain: 0,            // Void drain DOT
      
      // === JUGGLE ===
      juggling: false,         // Currently juggling enemy
      juggleHeight: 0,         // How high enemy is juggled
    },
    boss: {
      x: 900, y: CFG.GROUND_Y, vx: 0, vy: 0,
      hp: maxHp, maxHp,
      posture: 0, facing: -1, attackTimer: 60,
      stagger: 0, critical: 0, enraged: false, invuln: 0,
      state: 'idle', stateTimer: 0, attackState: null,
      phase: 0, comboCount: 0, diffMult: mult, data: bossData, key: bossKey,
      // Boss-specific state
      breathTimer: 0, dashTarget: 0, summonCD: 0, barrierHP: 0,
      // Monster Hunter aggression model
      baseAttackRate: 60, // Frames between attacks at 100% HP
      attackCooldown: 0,
      lastPlayerAttackTime: 0, // For punish system
      grounded: true, onPlatform: null, // Boss can use platforms too
      
      // === BOSS ENHANCEMENTS ===
      recoveryFrames: 0,       // Punish window after attacks
      currentPattern: null,    // Current attack pattern
      patternStep: 0,          // Step in pattern
      phaseTransition: false,  // In phase transition cinematic
      telegraphTimer: 0,       // Warning before attack
      telegraphType: null,     // Type of telegraph
      minions: [],             // Spawned minions
      
      // === ELEMENTAL STATUS ===
      burning: 0,              // Burning DOT timer
      frozen: 0,               // Frozen/slowed timer
      voidMarked: 0,           // Void mark (extra damage)
      
      // === JUGGLE STATE ===
      airborne: false,         // Currently juggled
      juggleTimer: 0,          // Time left in juggle state
    },
    
    // === GAME STATE ===
    anim: { state: 'idle', timer: 0 },
    projectiles: [],
    dmgNums: [],
    effects: [],
    gameTime: 0,
    victory: false, gameOver: false,
    stats: { dmg: 0, hits: 0, combo: 0, damageTaken: 0, parries: 0, perfectParries: 0 },
    difficulty: diff,
    
    // === NEW SYSTEMS ===
    minions: [],               // Active minions
    hazards: [],               // Environmental hazards
    trails: [],                // Attack trails for visuals
    gamePaused: false,         // Pause state for quiz/items
  };
}

// ============ HELPERS ============
// Effect spawn tracking for rate limiting
let lastEffectSpawnTime = 0;
const MIN_EFFECT_INTERVAL = 32; // Minimum 32ms between non-important effect spawns

function spawnEffect(type, x, y, cfg = {}) {
  // HARD CAP - Skip if too many effects already
  if (game.effects.length >= 40) return;
  
  // Rate limit effect spawning (except for important effects)
  const now = performance.now();
  const importantEffects = ['hit', 'break', 'land'];
  if (!importantEffects.includes(type) && now - lastEffectSpawnTime < MIN_EFFECT_INTERVAL) {
    return; // Skip this effect to prevent spam
  }
  lastEffectSpawnTime = now;
  
  // Shorter default life for effects
  const life = Math.min(cfg.life || 40, 50);
  game.effects.push({ type, x, y, ...cfg, life, maxLife: life });
}

function spawnDmgNum(x, y, val, type) {
  game.dmgNums.push({
    x: x + (Math.random() - 0.5) * 30, y, val, type,
    life: 100, vy: -4,
    scale: ['crit', 'break', 'ult'].includes(type) ? 1.5 : 1
  });
}

function spawnProjectile(x, y, vx, vy, dmg, owner, cfg = {}) {
  game.projectiles.push({
    x, y, vx, vy, dmg, owner,
    size: cfg.size || 20, color: cfg.color || '#fff',
    life: cfg.life || 130, trail: [],
    homing: cfg.homing || false, element: cfg.element || null,
  });
}

// ============ DAMAGE ============
// ============ QUIZ-LOCKED HP SYSTEM ============
// Boss HP cannot drop below certain thresholds until quiz questions answered
const HPGates = {
  // Segments: boss HP cannot go below these until quiz answered
  thresholds: [0.80, 0.60, 0.40, 0.20, 0.0],
  questionsPerGate: 2,
  currentGate: 0,
  questionsAnsweredAtGate: 0,
  gateUnlocked: [true, false, false, false, false], // First segment always unlocked
  
  reset() {
    this.currentGate = 0;
    this.questionsAnsweredAtGate = 0;
    this.gateUnlocked = [true, false, false, false, false];
  },
  
  // Check if boss HP can go below a threshold
  canDamageBelow(hpPercent) {
    for (let i = 0; i < this.thresholds.length; i++) {
      if (hpPercent <= this.thresholds[i] && !this.gateUnlocked[i]) {
        return false; // Blocked by quiz gate
      }
    }
    return true;
  },
  
  // Get the minimum HP boss can have right now
  getMinHP(maxHP) {
    for (let i = this.thresholds.length - 1; i >= 0; i--) {
      if (!this.gateUnlocked[i]) {
        return Math.ceil(maxHP * this.thresholds[i]);
      }
    }
    return 0; // All gates unlocked
  },
  
  // Called when quiz answered correctly
  onCorrectAnswer() {
    this.questionsAnsweredAtGate++;
    // Check if current gate should unlock
    for (let i = 0; i < this.gateUnlocked.length; i++) {
      if (!this.gateUnlocked[i]) {
        if (this.questionsAnsweredAtGate >= this.questionsPerGate) {
          this.gateUnlocked[i] = true;
          this.questionsAnsweredAtGate = 0;
          return i; // Return which gate unlocked
        }
        break;
      }
    }
    return -1;
  },
  
  // Check if victory is possible
  canVictory() {
    // All gates must be unlocked AND all standards covered
    const allGatesOpen = this.gateUnlocked.every(g => g);
    const allStandardsCovered = QuizSystem.allStandardsCovered();
    return allGatesOpen && allStandardsCovered;
  },
  
  // Get current blocked gate info
  getBlockedGate() {
    for (let i = 0; i < this.gateUnlocked.length; i++) {
      if (!this.gateUnlocked[i]) {
        return {
          index: i,
          threshold: this.thresholds[i],
          questionsNeeded: this.questionsPerGate - this.questionsAnsweredAtGate
        };
      }
    }
    return null;
  }
};

function damageBoss(dmg, isCrit = false, isSpecial = false) {
  const p = game.player, b = game.boss;
  if (b.invuln > 0) { spawnDmgNum(b.x, b.y - 150, 'IMMUNE!', 'block'); return; }
  
  let mult = p.cls.damage;
  if (isCrit) mult *= 2.5;
  if (b.critical > 0) mult *= 1.5;
  if (p.damageBoost > 0) mult *= 2;
  let finalDmg = Math.round(dmg * mult);
  
  // SIMPLIFIED: Just cap damage, no HP gates
  const maxDamage = Math.ceil(b.maxHp * 0.02); // 2% max per hit for longer battles
  finalDmg = Math.min(finalDmg, maxDamage);
  
  b.hp = Math.max(0, b.hp - finalDmg);
  
  // ===== WEAPON SPECIAL EFFECTS =====
  if (p.weapon && p.weapon.effect) {
    switch (p.weapon.effect) {
      case 'burn':
        // Fire DOT - boss takes extra damage over time
        if (!b.burnTimer) b.burnTimer = 0;
        b.burnTimer = 90; // 1.5 seconds
        b.burnDmg = Math.round(finalDmg * 0.1);
        break;
      case 'bleed':
        // Bleed - increased posture damage
        b.posture += finalDmg * 0.3; // Extra posture
        spawnDmgNum(b.x + 30, b.y - 100, 'BLEED', 'crit');
        break;
      case 'mana_regen':
        // Restore mana on hit
        p.mana = Math.min(p.maxMana, p.mana + 5);
        break;
      case 'lifesteal':
        // Heal on hit
        const heal = Math.round(finalDmg * 0.15);
        p.hp = Math.min(p.maxHp, p.hp + heal);
        if (heal > 0) spawnDmgNum(p.x, p.y - 60, '+' + heal, 'heal');
        break;
      case 'explosion':
        // AOE burst effect
        spawnEffect('hit', b.x, b.y - 80, { color: '#ff6b35', size: 150 });
        screenFx.addShake(20);
        break;
      case 'slow_enemy':
        // Slow boss briefly
        if (!b.slowTimer) b.slowTimer = 0;
        b.slowTimer = 60;
        break;
      case 'stun':
        // Chance to stun
        if (Math.random() < 0.15) {
          b.stateTimer = Math.max(b.stateTimer, 30);
          spawnDmgNum(b.x, b.y - 160, 'STUN!', 'break');
        }
        break;
    }
  }
  
  b.posture = Math.min(400, b.posture + finalDmg * 0.35);
  game.anim.state = 'hurt'; game.anim.timer = 15;
  
  game.stats.dmg += finalDmg;
  game.stats.hits++;
  p.combo++;
  p.comboTimer = 120;
  game.stats.combo = Math.max(game.stats.combo, p.combo);
  p.ultCharge = Math.min(100, p.ultCharge + (isSpecial ? 30 : isCrit ? 18 : 10));
  
  if (finalDmg > 0) {
    spawnDmgNum(b.x, b.y - 120, finalDmg, isCrit ? 'crit' : isSpecial ? 'special' : 'normal');
    screenFx.addShake(isSpecial ? 25 : isCrit ? 18 : 10);
    screenFx.hitstop = isSpecial ? 8 : isCrit ? 5 : 3;
    playSound(isCrit ? 'crit' : isSpecial ? 'special' : 'hit');
  }
  
  // Posture break - ENABLES EXECUTION MOVE
  if (b.posture >= 400 && b.critical <= 0) {
    b.critical = 240; // Extended window for execution
    b.posture = 0; 
    b.state = 'stagger'; 
    b.stateTimer = 90;
    b.executionReady = true; // Can be executed
    game.anim.state = 'stagger'; game.anim.timer = 60;
    spawnDmgNum(b.x, b.y - 180, 'BREAK!', 'break');
    spawnDmgNum(b.x, b.y - 220, 'EXECUTE!', 'crit');
    screenFx.addShake(30);
    playSound('special');
    
    // Show execution prompt on mobile
    if (typeof TouchControls !== 'undefined' && TouchControls.isMobile) {
      game.showExecutePrompt = true;
    }
  }
  
  // Enrage check - no effects
  if (!b.enraged && b.hp < b.maxHp * 0.3) {
    b.enraged = true;
    spawnDmgNum(b.x, b.y - 180, 'ENRAGED!', 'break');
    playSound('phase');
  }
  
  // Victory - REQUIRES ALL QUESTIONS ANSWERED
  if (b.hp <= 0) {
    if (KnowledgeSystem.canDefeatBoss()) {
      // Victory!
      game.victory = true;
      game.victoryTimer = 0;
      killCam = { x: b.x, y: b.y, timer: 120 };
      playSound('special');
      clearAllTimeouts();
    } else {
      // Can't win yet - need more questions!
      b.hp = 1; // Keep boss alive at 1 HP
      const remaining = KnowledgeSystem.requiredQuestions - KnowledgeSystem.questionsAnswered;
      spawnDmgNum(b.x, b.y - 150, 'ANSWER ' + remaining + ' MORE!', 'block');
      spawnDmgNum(b.x, b.y - 200, 'COLLECT ?', 'special');
      screenFx.addTint('#06b6d4', 0.3);
      playSound('hurt');
    }
  }
}

// ============ EXECUTION MOVE SYSTEM ============
const ExecutionSystem = {
  active: false,
  timer: 0,
  phase: 'idle', // 'windup', 'strike', 'aftermath'
  damage: 0,
  
  canExecute() {
    if (!game || !game.boss) return false;
    return game.boss.executionReady && game.boss.critical > 0 && game.boss.state === 'stagger';
  },
  
  startExecution() {
    if (!this.canExecute()) return false;
    
    const p = game.player;
    const b = game.boss;
    const cls = p.cls;
    
    this.active = true;
    this.phase = 'windup';
    this.timer = 0;
    
    // Calculate massive damage (20-30% of boss max HP)
    this.damage = Math.round(b.maxHp * (0.20 + (p.ultCharge / 100) * 0.10));
    
    // Use ultimate charge if available for bonus
    const hadUlt = p.ultCharge >= 100;
    if (hadUlt) {
      this.damage = Math.round(this.damage * 1.5);
      p.ultCharge = 0;
    }
    
    // Freeze game during execution
    game.gamePaused = true;
    b.executionReady = false;
    game.showExecutePrompt = false;
    
    // Player dash to boss
    p.x = b.x - p.facing * 80;
    
    // Cinematic effects
    screenFx.addTint(cls.color, 0.4);
    
    playSound('special');
    if (typeof Haptics !== 'undefined') Haptics.heavy();
    
    return true;
  },
  
  update() {
    if (!this.active) return;
    
    this.timer++;
    const p = game.player;
    const b = game.boss;
    const cls = p.cls;
    
    switch (this.phase) {
      case 'windup':
        // Dramatic pause before strike
        if (this.timer > 30) {
          this.phase = 'strike';
          this.timer = 0;
        }
        break;
        
      case 'strike':
        // The big hit
        if (this.timer === 1) {
          // Deal massive damage
          b.hp = Math.max(0, b.hp - this.damage);
          game.stats.dmg += this.damage;
          
          // Visual explosion
          screenFx.shake = 40;
          screenFx.hitstop = 15;
          
          // Spawn lots of effects
          for (let i = 0; i < 8; i++) {
            const angle = (i / 8) * Math.PI * 2;
            spawnEffect('hit', b.x + Math.cos(angle) * 50, b.y - 80 + Math.sin(angle) * 30, { 
              color: cls.color, 
              size: 40 + Math.random() * 30 
            });
          }
          
          spawnDmgNum(b.x, b.y - 150, this.damage, 'crit');
          spawnDmgNum(b.x, b.y - 200, 'EXECUTION!', 'break');
          
          playSound('crit');
          if (typeof Haptics !== 'undefined') Haptics.heavy();
        }
        
        if (this.timer > 45) {
          this.phase = 'aftermath';
          this.timer = 0;
        }
        break;
        
      case 'aftermath':
        // Recovery
        if (this.timer > 30) {
          this.active = false;
          game.gamePaused = false;
          b.critical = 0;
          b.state = 'idle';
          b.stateTimer = 90; // Boss recovery
          
          // Grant player invuln
          p.invuln = 60;
        }
        break;
    }
  },
  
  render(ctx) {
    if (!this.active) return;
    
    const p = game.player;
    const b = game.boss;
    const cls = p.cls;
    
    // Dark overlay
    ctx.fillStyle = 'rgba(0,0,0,0.6)';
    ctx.fillRect(0, 0, 1200, 700);
    
    // Spotlight on action
    const grad = ctx.createRadialGradient(b.x, b.y - 60, 0, b.x, b.y - 60, 200);
    grad.addColorStop(0, cls.color + '40');
    grad.addColorStop(1, 'transparent');
    ctx.fillStyle = grad;
    ctx.fillRect(0, 0, 1200, 700);
    
    // Phase-specific effects
    if (this.phase === 'windup') {
      // Charging effect
      const chargeSize = 20 + this.timer * 2;
      ctx.strokeStyle = cls.color;
      ctx.lineWidth = 3;
      ctx.globalAlpha = 0.5 + Math.sin(this.timer * 0.3) * 0.3;
      ctx.beginPath();
      ctx.arc(p.x, p.y - 60, chargeSize, 0, Math.PI * 2);
      ctx.stroke();
      ctx.globalAlpha = 1;
      
      // Text
      ctx.fillStyle = cls.color;
      ctx.font = 'bold 24px sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText('EXECUTING...', 600, 100);
    }
    
    if (this.phase === 'strike') {
      // Impact lines
      ctx.strokeStyle = cls.color;
      ctx.lineWidth = 4;
      for (let i = 0; i < 12; i++) {
        const angle = (i / 12) * Math.PI * 2;
        const inner = 60;
        const outer = 60 + this.timer * 8;
        ctx.beginPath();
        ctx.moveTo(b.x + Math.cos(angle) * inner, b.y - 80 + Math.sin(angle) * inner);
        ctx.lineTo(b.x + Math.cos(angle) * outer, b.y - 80 + Math.sin(angle) * outer);
        ctx.stroke();
      }
    }
  },
  
  reset() {
    this.active = false;
    this.timer = 0;
    this.phase = 'idle';
    this.damage = 0;
  }
};

function damagePlayer(dmg, ignoreInvuln = false) {
  const p = game.player;
  if ((p.invuln > 0 || p.stagger > 0) && !ignoreInvuln) return;
  
  // Parry check
  if (p.parryWindow > 0) {
    // Perfect parry = parry in first 5 frames
    const isPerfect = p.parryWindow > 10;
    
    if (isPerfect) {
      spawnDmgNum(p.x, p.y - 80, 'PERFECT!', 'crit');
      p.perfectParry = true;
      p.parryCritWindow = CFG.PARRY_CRIT_WINDOW * 1.5; // Longer crit window
      p.ultCharge = Math.min(100, p.ultCharge + 40);
      screenFx.hitstop = CFG.HITSTOP_HEAVY;
      game.stats.perfectParries = (game.stats.perfectParries || 0) + 1;
      
      // Stagger boss on perfect parry
      if (game.boss && game.boss.stagger <= 0) {
        game.boss.stagger = 30;
        game.boss.posture += 30;
      }
    } else {
      spawnDmgNum(p.x, p.y - 80, 'PARRY!', 'parry');
      p.parryCritWindow = CFG.PARRY_CRIT_WINDOW;
      p.ultCharge = Math.min(100, p.ultCharge + 25);
    }
    
    game.stats.parries = (game.stats.parries || 0) + 1;
    spirit.setAnim('parry', 35);
    screenFx.addTint('#ffffff', 0.3);
    screenFx.shake = 5;
    
    // Counter-attack visual
    spawnEffect('parry_flash', p.x, p.y - 60, { color: '#fff', size: 80 });
    playSound('parry');
    
    // Haptic feedback
    if (typeof Haptics !== 'undefined') {
      isPerfect ? Haptics.heavy() : Haptics.medium();
    }
    
    return;
  }
  
  const finalDmg = Math.round(dmg * game.boss.diffMult.bossDmg);
  p.hp = Math.max(0, p.hp - finalDmg);
  p.invuln = 70;
  p.combo = 0;
  // Reset parry crit window when hit
  p.parryCritWindow = 0;
  game.stats.damageTaken += finalDmg;
  
  spawnEffect('hit', p.x, p.y - 60, { color: '#ef4444', size: 75 });
  spawnDmgNum(p.x, p.y - 85, finalDmg, 'hurt');
  screenFx.addShake(20);
  screenFx.addTint('#ff0000', 0.25);
  screenFx.vignette = 0.6;
  setTimeout(() => { if (screenFx) screenFx.vignette = 0.4; }, 300);
  playSound('hurt');
  
  // Haptic feedback for damage
  if (typeof Haptics !== 'undefined') Haptics.heavy();
  
  if (p.hp <= 0) {
    game.gameOver = true;
    game.gameOverTimer = 0;
    screenFx.addShake(35);
    screenFx.setSlowmo(0.5, 60);
    playSound('hurt');
  }
}

// ============ PLAYER ATTACKS ============
function doMelee() {
  const p = game.player, b = game.boss, cls = p.cls;
  if (p.attackTimer > 0 || p.stagger > 0) return;
  
  // Parry crit bonus
  const parryCrit = p.parryCritWindow > 0;
  const critMult = parryCrit ? CFG.PARRY_CRIT_MULT : 1;
  
  p.attackTimer = 22;
  spirit.setAnim('melee', 40);
  
  // Hit stop for impact
  screenFx.hitstop = CFG.HITSTOP_LIGHT;
  
  const dist = Math.abs(p.x - b.x);
  const hit = dist < cls.melee.range && b.hp > 0;
  
  // Weapon multiplier
  const weaponMult = p.weapon?.meleeMult || 1;
  const baseDmg = cls.melee.dmg * weaponMult * critMult;
  
  // Attack trail effect
  spawnTrail(p.x, p.y - 60, p.facing, cls.color);
  
  // ===== CLASS-SPECIFIC MELEE - DISTINCT MECHANICS =====
  if (cls.element === 'fire') {
    // INFERNO: BLAZING COMBO - hits harder with each consecutive hit
    if (!p.meleeCombo) p.meleeCombo = 0;
    p.meleeCombo = Math.min(3, p.meleeCombo + 1);
    p.meleeComboTimer = 60; // Reset combo if no attack for 1 second
    
    const comboDmg = baseDmg * (1 + p.meleeCombo * 0.3); // Up to 90% more damage
    const comboSize = 60 + p.meleeCombo * 25;
    
    spawnEffect('fire_punch', p.x + p.facing * 60, p.y - 70, { color: '#ff6b35', facing: p.facing, size: comboSize });
    particles.emit(p.x + p.facing * 50, p.y - 60, { count: 3 + p.meleeCombo * 2, spread: 4, color: '#ff6b35', life: 20, dirY: -2 });
    
    if (hit) {
      damageBoss(comboDmg, p.meleeCombo >= 3 || Math.random() < 0.2 || parryCrit);
      if (p.meleeCombo >= 3) {
        spawnDmgNum(b.x, b.y - 160, 'INFERNO!', 'crit');
        screenFx.addTint('#ff6b35', 0.2);
        screenFx.hitstop = CFG.HITSTOP_HEAVY;
      }
      // Apply burn (fire DOT)
      if (!b.burning) b.burning = 0;
      b.burning = Math.max(b.burning, 120);
    }
    playSound('fire');
    
  } else if (cls.element === 'crystal') {
    // CRYSTAL: ARCANE BLADE - returns mana on hit, chance for double hit
    spawnEffect('crystal_slash', p.x + p.facing * 50, p.y - 70, { color: '#a78bfa', facing: p.facing, size: 80 });
    particles.emit(p.x + p.facing * 60, p.y - 70, { count: 6, spread: 5, color: '#c4b5fd', life: 25, dirX: p.facing * 3 });
    
    if (hit) {
      damageBoss(baseDmg, Math.random() < 0.22 || parryCrit);
      p.mana = Math.min(p.maxMana, p.mana + 3); // Mana return
      
      // 25% chance for arcane echo (double hit)
      if (Math.random() < 0.25) {
        safeTimeout(() => {
          if (!game || !game.boss || game.boss.hp <= 0) return;
          damageBoss(baseDmg * 0.5, false);
          spawnEffect('hit', b.x, b.y - 80, { color: '#c4b5fd', size: 50 });
          spawnDmgNum(b.x + 20, b.y - 140, 'ECHO', 'special');
        }, 150);
      }
    }
    playSound('hit');
    
  } else {
    // SHADOW: PHANTOM TRIPLE-STRIKE - 3 rapid hits with backstab bonus
    const behind = (p.x > b.x && b.facing > 0) || (p.x < b.x && b.facing < 0);
    const backstabMult = behind ? cls.melee.backstab : 1;
    
    // Visual: 3 slashes at different positions
    spawnEffect('shadow_strike', p.x + p.facing * 40, p.y - 85, { color: '#34d399', facing: p.facing });
    spawnEffect('shadow_strike', p.x + p.facing * 55, p.y - 65, { color: '#10b981', facing: p.facing });
    spawnEffect('shadow_strike', p.x + p.facing * 45, p.y - 45, { color: '#059669', facing: p.facing });
    
    if (hit) {
      // Apply void drain (drain DOT)
      if (!b.voidMarked) b.voidMarked = 0;
      b.voidMarked = Math.max(b.voidMarked, 180);
      
      // 3 separate damage instances for satisfying hit feedback
      damageBoss(baseDmg * 0.4 * backstabMult, behind || parryCrit);
      safeTimeout(() => {
        if (!game || !game.boss || game.boss.hp <= 0) return;
        damageBoss(baseDmg * 0.3 * backstabMult, false);
      }, 50);
      safeTimeout(() => {
        if (!game || !game.boss || game.boss.hp <= 0) return;
        damageBoss(baseDmg * 0.3 * backstabMult, false);
      }, 100);
      
      if (behind) {
        spawnDmgNum(b.x, b.y - 160, 'BACKSTAB!', 'crit');
        p.invuln = Math.max(p.invuln, 20); // Brief invuln on backstab
      }
    }
    playSound('dash');
  }
  
  // Hit minions too
  if (typeof MinionSystem !== 'undefined') {
    MinionSystem.checkPlayerHit(p.x + p.facing * 60, p.y, cls.melee.range, baseDmg * 0.7);
  }
}

// === LAUNCHER ATTACK (Up + Attack in air) ===
function doLauncher(charged = false) {
  const p = game.player, b = game.boss, cls = p.cls;
  if (p.attackTimer > 0 || p.stagger > 0) return;
  
  const parryCrit = p.parryCritWindow > 0;
  const critMult = parryCrit ? CFG.PARRY_CRIT_MULT : 1;
  const chargeMult = charged ? CFG.CHARGE_DAMAGE_MULT : 1;
  
  p.attackTimer = 30;
  spirit.setAnim('melee', 50);
  
  const dist = Math.abs(p.x - b.x);
  const hit = dist < cls.melee.range * 1.2 && b.hp > 0;
  
  const baseDmg = cls.melee.dmg * 0.8 * critMult * chargeMult;
  
  // Upward slash effect
  spawnEffect('launcher', p.x + p.facing * 40, p.y - 80, { 
    color: cls.color, 
    facing: p.facing,
    size: charged ? 100 : 70
  });
  
  if (hit && b.invuln <= 0) {
    damageBoss(baseDmg, charged || parryCrit);
    
    // Launch boss into air (juggle state)
    if (!b.airborne && b.stagger <= 0) {
      b.airborne = true;
      b.juggleTimer = 90; // 1.5 seconds of juggle time
      b.vy = -CFG.LAUNCHER_FORCE;
      b.grounded = false;
      spawnDmgNum(b.x, b.y - 140, 'LAUNCH!', 'special');
      screenFx.hitstop = CFG.HITSTOP_HEAVY;
      
      // Player gets slight upward boost
      p.vy = -10;
    }
  }
  
  playSound('special');
}

// === SWEEP ATTACK (Down + Attack on ground) ===
function doSweep(charged = false) {
  const p = game.player, b = game.boss, cls = p.cls;
  if (p.attackTimer > 0 || p.stagger > 0 || !p.grounded) return;
  
  const parryCrit = p.parryCritWindow > 0;
  const critMult = parryCrit ? CFG.PARRY_CRIT_MULT : 1;
  const chargeMult = charged ? CFG.CHARGE_DAMAGE_MULT : 1;
  
  p.attackTimer = 35;
  spirit.setAnim('melee', 55);
  
  // Sweep has wider range
  const dist = Math.abs(p.x - b.x);
  const hit = dist < cls.melee.range * 1.5 && b.hp > 0;
  
  const baseDmg = cls.melee.dmg * 0.6 * critMult * chargeMult;
  
  // Low sweep effect
  spawnEffect('sweep', p.x + p.facing * 60, p.y - 20, { 
    color: cls.color, 
    facing: p.facing,
    size: charged ? 150 : 100
  });
  
  // Ground particles
  for (let i = 0; i < 8; i++) {
    particles.emit(p.x + p.facing * (20 + i * 15), p.y, { 
      count: 2, spread: 1, color: '#888', life: 20, dirY: -3 
    });
  }
  
  if (hit && b.invuln <= 0) {
    damageBoss(baseDmg, charged || parryCrit);
    
    // Sweep trips boss (brief stagger if not airborne)
    if (!b.airborne && b.stagger <= 0) {
      b.stagger = charged ? 45 : 25;
      spawnDmgNum(b.x, b.y - 100, 'TRIPPED!', 'block');
    }
    
    // Apply elemental slow (ice effect)
    if (cls.element === 'crystal') {
      if (!b.frozen) b.frozen = 0;
      b.frozen = Math.max(b.frozen, 90);
    }
  }
  
  playSound('hit');
}

// === HEAVY MELEE (Fully charged attack) ===
function doHeavyMelee() {
  const p = game.player, b = game.boss, cls = p.cls;
  if (p.attackTimer > 0 || p.stagger > 0) return;
  
  const parryCrit = p.parryCritWindow > 0;
  const critMult = parryCrit ? CFG.PARRY_CRIT_MULT : 1;
  
  p.attackTimer = 40;
  spirit.setAnim('melee', 60);
  
  const dist = Math.abs(p.x - b.x);
  const hit = dist < cls.melee.range * 1.3 && b.hp > 0;
  
  const baseDmg = cls.melee.dmg * CFG.CHARGE_DAMAGE_MULT * critMult;
  
  // Big impact effect
  spawnEffect('heavy_hit', p.x + p.facing * 70, p.y - 60, { 
    color: cls.color, 
    facing: p.facing,
    size: 120
  });
  
  // Screen shake
  screenFx.shake = 12;
  screenFx.hitstop = CFG.HITSTOP_CRIT;
  
  // Anime-style impact lines
  for (let i = 0; i < 6; i++) {
    const angle = (Math.PI / 6) * i - Math.PI / 3;
    spawnEffect('impact_line', 
      p.x + p.facing * 70 + Math.cos(angle) * 30, 
      p.y - 60 + Math.sin(angle) * 30, 
      { color: '#fff', angle: angle }
    );
  }
  
  if (hit && b.invuln <= 0) {
    damageBoss(baseDmg, true); // Always crit
    
    // Execution check - if boss is staggered, deal massive damage
    if (b.critical > 0) {
      const execDmg = baseDmg * 0.5;
      safeTimeout(() => {
        if (!game || !game.boss || game.boss.hp <= 0) return;
        damageBoss(execDmg, true);
        spawnDmgNum(b.x, b.y - 180, 'EXECUTE!', 'crit');
        screenFx.shake = 20;
        screenFx.addTint(cls.color, 0.4);
      }, 100);
    }
    
    // Knockback
    b.vx = p.facing * 15;
    b.stagger = Math.max(b.stagger, 20);
    
    spawnDmgNum(b.x, b.y - 160, 'HEAVY!', 'crit');
  }
  
  playSound('crit');
}

// === ATTACK TRAIL EFFECT ===
function spawnTrail(x, y, facing, color) {
  if (!game.trails) game.trails = [];
  game.trails.push({
    x, y, facing, color,
    life: CFG.TRAIL_LENGTH,
    points: []
  });
}

function doRanged() {
  const p = game.player, cls = p.cls;
  if (p.attackTimer > 0 || p.stagger > 0 || p.mana < cls.ranged.cost) return;
  p.mana -= cls.ranged.cost;
  p.attackTimer = 14;
  spirit.setAnim('ranged', 35);
  
  // Weapon multiplier
  const weaponMult = p.weapon?.rangedMult || 1;
  const baseDmg = cls.ranged.dmg * weaponMult;
  
  if (cls.element === 'fire') {
    // INFERNO: Large fireball with flame trail
    spawnProjectile(p.x + p.facing * 50, p.y - 65, p.facing * cls.ranged.speed, 0, baseDmg, 'player', 
      { color: '#ff6b35', element: 'fire', size: 28, trail: true });
    spawnEffect('fire_launch', p.x + p.facing * 30, p.y - 65, { color: '#fbbf24', size: 45 });
    playSound('fire');
    
  } else if (cls.element === 'crystal') {
    // CRYSTAL: Triple crystal shard spread with sparkles
    for (let i = -1; i <= 1; i++) {
      spawnProjectile(p.x + p.facing * 50, p.y - 65 + i * 15, p.facing * cls.ranged.speed, i * 2, 
        baseDmg * 0.5, 'player', { color: '#a78bfa', element: 'crystal', size: 18 });
    }
    spawnEffect('crystal_burst', p.x + p.facing * 30, p.y - 65, { color: '#c4b5fd', size: 40 });
    playSound('ranged');
    
  } else {
    // SHADOW: Phantom kunai (fast, slight homing)
    spawnProjectile(p.x + p.facing * 50, p.y - 65, p.facing * cls.ranged.speed * 1.3, 0, baseDmg, 'player', 
      { color: '#34d399', element: 'shadow', size: 15, homing: true });
    spawnEffect('shadow_throw', p.x, p.y - 65, { color: '#10b981', facing: p.facing });
    playSound('dash');
  }
}

function doSpecial() {
  const p = game.player, b = game.boss, cls = p.cls;
  if (p.attackTimer > 0 || p.stagger > 0 || p.specialCD > 0 || p.mana < 35) return;
  p.mana -= 35; p.specialCD = 110; p.attackTimer = 35;
  spirit.setAnim('special', 55);
  
  const dist = Math.abs(p.x - b.x);
  
  // Weapon multiplier for special
  const weaponMult = p.weapon?.specialMult || 1;
  const baseDmg = cls.special.dmg * weaponMult;
  
  // ===== CLASS-SPECIFIC SPECIAL ATTACKS =====
  if (cls.element === 'fire') {
    // INFERNO SPECIAL: GROUND POUND - AOE fire wave
    spawnEffect('hit', p.x, p.y - 20, { color: '#ff6b35', size: 150 });
    particles.emit(p.x, p.y - 30, { count: 15, spread: 12, color: '#ff6b35', life: 25, dirY: -3 });
    screenFx.addTint('#ff6b35', 0.3);
    screenFx.addShake(25);
    
    // Fire wave travels outward
    bg.addHazard('fire_patch', p.x - 80, CFG.GROUND_Y, 120);
    bg.addHazard('fire_patch', p.x + 80, CFG.GROUND_Y, 120);
    
    if (dist < cls.special.range && b.hp > 0) {
      damageBoss(baseDmg, false, true);
      // Burn effect
      b.burnTimer = 120;
      b.burnDmg = Math.round(baseDmg * 0.08);
      spawnDmgNum(b.x, b.y - 140, 'BURN!', 'crit');
    }
    playSound('fire');
    
  } else if (cls.element === 'crystal') {
    // CRYSTAL SPECIAL: ARCANE PRISON - traps boss briefly + multi-hit
    spawnEffect('hit', b.x, b.y - 80, { color: '#a78bfa', size: 120 });
    particles.emit(b.x, b.y - 80, { count: 12, spread: 8, color: '#c4b5fd', life: 30 });
    screenFx.addTint('#a78bfa', 0.25);
    
    if (dist < cls.special.range + 100 && b.hp > 0) {
      // Boss briefly slowed
      b.slowTimer = 45;
      
      // Multi-hit crystal barrage
      const hits = cls.special.hits || 6;
      for (let i = 0; i < hits; i++) {
        safeTimeout(() => {
          if (!game || !game.boss || game.boss.hp <= 0) return;
          damageBoss(baseDmg / hits, i === hits - 1, true);
          spawnEffect('hit', b.x + (Math.random() - 0.5) * 60, b.y - 80 + (Math.random() - 0.5) * 40, 
            { color: '#c4b5fd', size: 40 });
        }, i * 80);
      }
      spawnDmgNum(b.x, b.y - 160, 'PRISON!', 'special');
    }
    playSound('hit');
    
  } else {
    // SHADOW SPECIAL: SHADOW DASH - phases through enemy with damage
    p.invuln = 50;
    
    // Dash toward boss
    const dashDist = Math.min(dist + 100, 400);
    p.vx = p.facing * 45;
    
    spawnEffect('hit', p.x, p.y - 60, { color: '#10b981', size: 80 });
    particles.emit(p.x, p.y - 50, { count: 10, spread: 8, color: '#34d399', life: 20, dirX: -p.facing * 5 });
    screenFx.addTint('#10b981', 0.2);
    
    // Leave shadow afterimages
    for (let i = 1; i <= 3; i++) {
      safeTimeout(() => {
        if (!game) return;
        spawnEffect('shadow_strike', p.x - p.facing * i * 40, p.y - 60, { color: '#10b981', facing: p.facing });
      }, i * 40);
    }
    
    if (dist < cls.special.range + 150 && b.hp > 0) {
      damageBoss(baseDmg, true, true);
      // Mark for death - next attack crits
      p.shadowMark = 90;
      spawnDmgNum(b.x, b.y - 160, 'MARKED!', 'crit');
    }
    playSound('dash');
  }
}

function doUltimate() {
  const p = game.player, b = game.boss, cls = p.cls;
  if (p.attackTimer > 0 || p.ultCharge < 100 || p.mana < 55) return;
  p.mana -= 55; p.ultCharge = 0; p.attackTimer = 65;
  spirit.setAnim('ultimate', 85);
  
  // ===== CLASS-SPECIFIC ULTIMATE ATTACKS =====
  if (cls.element === 'fire') {
    // INFERNO ULTIMATE: METEOR STRIKE - massive AOE + burn field
    spawnEffect('hit', b.x, b.y - 80, { color: '#ff6b35', size: 250 });
    particles.emit(b.x, b.y - 80, { count: 25, spread: 15, color: '#ff6b35', life: 40 });
    screenFx.addTint('#ff6b35', 0.5);
    screenFx.addShake(50);
    
    // Create fire field across arena
    for (let x = 200; x < 1000; x += 150) {
      bg.addHazard('fire_patch', x, CFG.GROUND_Y, 240);
    }
    
    if (b.hp > 0) {
      damageBoss(cls.ultimate.dmg, true, true);
      // Massive burn
      b.burnTimer = 180;
      b.burnDmg = Math.round(cls.ultimate.dmg * 0.05);
      spawnDmgNum(b.x, b.y - 180, 'INFERNO!', 'ult');
    }
    playSound('fire');
    
  } else if (cls.element === 'crystal') {
    // CRYSTAL ULTIMATE: ARCANE ANNIHILATION - beam of pure arcane energy
    spawnEffect('hit', b.x, b.y - 80, { color: '#a78bfa', size: 200 });
    particles.emit(b.x, b.y - 80, { count: 20, spread: 12, color: '#c4b5fd', life: 35 });
    screenFx.addTint('#a78bfa', 0.5);
    screenFx.addShake(45);
    
    // Multi-hit beam
    const hits = 8;
    for (let i = 0; i < hits; i++) {
      safeTimeout(() => {
        if (!game || !game.boss || game.boss.hp <= 0) return;
        const dmg = Math.round(cls.ultimate.dmg / hits);
        damageBoss(dmg, i === hits - 1, true);
        spawnEffect('hit', b.x + (Math.random() - 0.5) * 80, b.y - 80 + (Math.random() - 0.5) * 60, 
          { color: '#c4b5fd', size: 60 });
        // Full mana restore on last hit
        if (i === hits - 1) {
          p.mana = p.maxMana;
          spawnDmgNum(p.x, p.y - 80, 'MANA FULL!', 'heal');
        }
      }, i * 100);
    }
    spawnDmgNum(b.x, b.y - 180, 'ANNIHILATION!', 'ult');
    playSound('special');
    
  } else {
    // SHADOW ULTIMATE: THOUSAND CUTS - rapid multi-hit assassination
    screenFx.addTint('#10b981', 0.5);
    p.invuln = 120; // Long invuln during ultimate
    screenFx.addShake(40);
    
    // Teleport around boss dealing rapid hits
    const cuts = 12;
    for (let i = 0; i < cuts; i++) {
      safeTimeout(() => {
        if (!game || !game.boss || game.boss.hp <= 0) return;
        const angle = (i / cuts) * Math.PI * 2;
        const hitX = b.x + Math.cos(angle) * 80;
        const hitY = b.y - 80 + Math.sin(angle) * 40;
        
        spawnEffect('shadow_strike', hitX, hitY, { color: '#34d399', facing: Math.cos(angle) > 0 ? 1 : -1 });
        damageBoss(Math.round(cls.ultimate.dmg / cuts), i === cuts - 1, true);
        
        // Final hit is guaranteed crit
        if (i === cuts - 1) {
          p.x = b.x - b.facing * 100; // Appear behind boss
          p.facing = b.facing;
          spawnDmgNum(b.x, b.y - 180, 'THOUSAND CUTS!', 'ult');
          screenFx.addShake(30);
        }
      }, i * 60);
    }
    playSound('dash');
  }
}

// ============ UNIQUE BOSS AI ============
function updateBossAI() {
  const p = game.player, b = game.boss;
  if (b.critical > 0 || game.victory || game.gameOver) {
    if (b.critical > 0) b.critical--;
    return;
  }
  
  const dx = p.x - b.x;
  b.facing = dx > 0 ? 1 : -1;
  const dist = Math.abs(dx);
  
  b.stateTimer--;
  if (b.invuln > 0) b.invuln--;
  if (b.summonCD > 0) b.summonCD--;
  
  // === RECOVERY FRAMES (punish window for player) ===
  if (b.recoveryFrames > 0) {
    b.recoveryFrames--;
    // Boss is vulnerable during recovery
    if (b.recoveryFrames <= 0) {
      b.state = 'idle';
      b.stateTimer = 15;
    }
    return; // Don't act during recovery
  }
  
  // === TELEGRAPH WARNING ===
  if (b.telegraphTimer > 0) {
    b.telegraphTimer--;
    // Show warning effect
    if (b.telegraphTimer > 0 && frame % 10 === 0) {
      const warningColor = b.telegraphType === 'melee' ? '#ef4444' : 
                          b.telegraphType === 'ranged' ? '#f97316' : '#fbbf24';
      spawnEffect('telegraph', b.x, b.y - 150, { 
        color: warningColor, 
        type: b.telegraphType,
        size: 40 
      });
    }
  }
  
  // === FROZEN SLOWDOWN ===
  const frozenMult = b.frozen > 0 ? 0.5 : 1;
  
  // === JUGGLE STATE ===
  if (b.airborne) {
    // Reduced gravity while juggled
    b.vy = (b.vy || 0) + CFG.GRAVITY * CFG.JUGGLE_GRAVITY;
    b.y += b.vy;
    
    // Land
    if (b.y >= CFG.GROUND_Y) {
      b.y = CFG.GROUND_Y;
      b.vy = 0;
      b.airborne = false;
      b.grounded = true;
      b.stagger = 30; // Brief stagger on landing
      spawnEffect('land', b.x, b.y, { color: b.data.color });
    }
    return; // Can't act while juggled
  }
  
  // Phase check - SIMPLIFIED: Just update phase, no effects
  const hpPct = b.hp / b.maxHp;
  const phases = b.data.phases;
  for (let i = phases.length - 1; i >= 0; i--) {
    if (hpPct <= phases[i].hp && b.phase !== i) {
      // Phase transition!
      const oldPhase = b.phase;
      b.phase = i;
      
      // Trigger phase transition if significant change
      if (i > oldPhase && PhaseManager.canTransition()) {
        triggerPhaseTransition(b, phases[i]);
      }
      break;
    }
  }
  
  const phase = phases[b.phase];
  const baseAggression = phase.aggression;
  
  // ======= ENRAGE CHECK =======
  if (hpPct <= 0.25 && !b.enraged) {
    b.enraged = true;
    spawnDmgNum(b.x, b.y - 150, 'ENRAGED!', 'crit');
    spawnEffect('enrage', b.x, b.y - 80, { color: b.data.enrageColor, size: 150 });
    screenFx.addTint(b.data.enrageColor, 0.3);
    screenFx.shake = 20;
    playSound('crit');
  }
  
  // ======= MONSTER HUNTER AGGRESSION MODEL =======
  const hpFactor = 1 - hpPct;
  const aggression = baseAggression * (1 + hpFactor * 0.8) * (b.enraged ? 1.4 : 1);
  
  // Calculate dynamic attack rate
  const baseAttackRate = b.baseAttackRate || 60;
  b.currentAttackRate = Math.max(15, Math.round(baseAttackRate / aggression));
  
  const speedMult = b.data.speed * b.diffMult.bossSpeed * (b.enraged ? 1.3 : 1) * frozenMult;
  
  // ======= PUNISH SYSTEM =======
  if (b.lastPlayerAttackTime > 0) {
    b.lastPlayerAttackTime--;
    if (b.lastPlayerAttackTime === 0 && dist < 300 && b.state === 'idle') {
      b.state = 'approach';
      b.stateTimer = 15;
      b.attackCooldown = 0;
    }
  }
  
  // Boss-specific AI
  if (b.key === 'VOID_TITAN') updateVoidTitanAI(p, b, phase, dist, speedMult, aggression);
  else if (b.key === 'FLAME_WYRM') updateFlameWyrmAI(p, b, phase, dist, speedMult, aggression);
  else if (b.key === 'FROST_QUEEN') updateFrostQueenAI(p, b, phase, dist, speedMult, aggression);
  
  // GLOBAL SAFETY: Force stagger recovery if stuck
  if (b.state === 'stagger' && b.stateTimer <= 0) {
    b.state = 'idle';
    b.stateTimer = 30;
  }
  
  // GLOBAL SAFETY: Force any stuck state to idle after too long
  if (b.stateTimer < -100) {
    console.warn('Boss stuck in state:', b.state, '- forcing idle');
    b.state = 'idle';
    b.stateTimer = 30;
  }
  
  // Keep in bounds
  b.x = Math.max(120, Math.min(1080, b.x));
  
  // Posture decay
  if (b.critical <= 0 && b.state !== 'stagger') {
    b.posture = Math.max(0, b.posture - 0.5 * screenFx.slowmo);
  }
}

function updateVoidTitanAI(p, b, phase, dist, speedMult, aggression) {
  const attacks = phase.attacks;
  
  // PROACTIVE ATTACK TIMER - boss attacks on its own schedule
  if (!b.attackCooldown) b.attackCooldown = 0;
  b.attackCooldown -= screenFx.slowmo;
  
  // BOSS MOVEMENT - Apply gravity and movement
  if (!b.vy) b.vy = 0;
  if (!b.grounded) {
    b.vy += 0.8; // Gravity
    b.y += b.vy * screenFx.slowmo;
    if (b.y >= CFG.GROUND_Y) {
      b.y = CFG.GROUND_Y;
      b.vy = 0;
      b.grounded = true;
      screenFx.addShake(15);
      spawnEffect('land', b.x, b.y, { color: '#6366f1', size: 80 });
    }
  }
  
  switch (b.state) {
    case 'idle':
      // Proactive attack decision - don't wait for player
      if (b.stateTimer <= 0 || b.attackCooldown <= 0) {
        b.attackCooldown = 30 + Math.random() * 25; // Attack faster: 30-55 frames
        
        // Weight attacks by distance and aggression
        const closeRange = dist < 250;
        const midRange = dist >= 250 && dist < 500;
        const farRange = dist >= 500;
        
        // Add JUMP attack when player is above or far
        const playerAbove = p.y < b.y - 100;
        
        if (playerAbove && Math.random() < 0.5) {
          // Jump toward player
          b.state = 'jump_attack'; b.stateTimer = 60;
          b.vy = -18;
          b.grounded = false;
        } else if (closeRange) {
          // Close range - melee attacks
          if (attacks.includes('void_combo') && Math.random() < 0.5 * aggression) {
            b.state = 'void_combo'; b.stateTimer = 75; b.comboCount = 0;
          } else {
            b.state = 'void_slash'; b.stateTimer = 70;
          }
        } else if (midRange) {
          // Mid range - ranged attacks or charge
          if (Math.random() < 0.35) {
            b.state = 'charge'; b.stateTimer = 50; // New charge attack
          } else if (attacks.includes('dark_orbs') && Math.random() < 0.5) {
            b.state = 'dark_orbs'; b.stateTimer = 65;
          } else if (attacks.includes('gravity_well') && Math.random() < 0.4) {
            b.state = 'gravity_well'; b.stateTimer = 60;
          } else {
            b.state = 'approach'; b.stateTimer = 35;
          }
        } else {
          // Far range - gap closers
          if (attacks.includes('singularity') && Math.random() < 0.4 * aggression) {
            b.state = 'singularity'; b.stateTimer = 60;
          } else if (Math.random() < 0.5) {
            b.state = 'charge'; b.stateTimer = 50;
          } else {
            b.state = 'approach'; b.stateTimer = 40;
          }
        }
      }
      // Idle movement - pace back and forth
      if (Math.random() < 0.02) b.facing *= -1;
      b.x += b.facing * 1.5 * speedMult * screenFx.slowmo;
      break;
      
    case 'approach':
      // Faster, more aggressive approach
      b.x += b.facing * 5 * speedMult * screenFx.slowmo;
      if (dist < 180) { 
        b.state = 'idle'; b.stateTimer = 3;
        b.attackCooldown = 0;
      } else if (b.stateTimer <= 0) { 
        b.state = 'idle'; b.stateTimer = 8; 
      }
      break;
      
    case 'charge':
      // Fast charge at player
      if (b.stateTimer > 30) {
        // Wind up
        spawnEffect('void_charge', b.x, b.y - 100, { color: '#6366f1', size: 50, life: 5 });
      } else {
        // Charge!
        b.x += b.facing * 12 * speedMult * screenFx.slowmo;
        if (dist < 100 && p.invuln <= 0) {
          damagePlayer(b.data.damage * 1.2);
          screenFx.addShake(25);
        }
      }
      if (b.stateTimer <= 0) { b.state = 'idle'; b.stateTimer = 30; }
      break;
      
    case 'jump_attack':
      // Air attack
      b.x += b.facing * 4 * speedMult * screenFx.slowmo;
      if (b.grounded && b.stateTimer < 40) {
        // Land damage
        if (dist < 150 && p.invuln <= 0) {
          damagePlayer(b.data.damage);
        }
        spawnEffect('void_slam', b.x, b.y, { color: '#6366f1', size: 150 });
        screenFx.addShake(30);
        b.state = 'idle'; b.stateTimer = 25;
      }
      if (b.stateTimer <= 0) { b.state = 'idle'; b.stateTimer = 20; }
      break;
      
    case 'void_slash':
      if (b.stateTimer === 35) {
        game.anim.state = 'attack'; game.anim.timer = 25;
        playSound('void');
      }
      if (b.stateTimer === 8) {
        if (dist < 200 && p.invuln <= 0) damagePlayer(b.data.damage);
        spawnEffect('void_slash', b.x + b.facing * 100, b.y - 100, { color: '#6366f1', facing: b.facing, size: 2 });
      }
      if (b.stateTimer <= 0) { b.state = 'idle'; b.stateTimer = 25; }
      break;
      
    case 'gravity_well':
      // Warning effect - spawn every 8 frames instead of every frame
      if (b.stateTimer > 50 && b.stateTimer % 8 === 0) {
        spawnEffect('hit', b.x, b.y - 100, { color: '#312e81', size: 40 });
      }
      if (b.stateTimer === 50) {
        playSound('void');
      }
      if (b.stateTimer < 50 && b.stateTimer > 10) {
        // Pull player toward boss
        const pullForce = 3 * (1 - dist / 400);
        p.vx += (b.x > p.x ? 1 : -1) * pullForce * screenFx.slowmo;
        if (dist < 80 && p.invuln <= 0) damagePlayer(b.data.damage * 0.5);
      }
      if (b.stateTimer <= 0) { b.state = 'idle'; b.stateTimer = 50; }
      break;
      
    case 'dark_orbs':
      if (b.stateTimer === 60) {
        for (let i = 0; i < 5; i++) {
          const angle = (i / 5) * Math.PI * 2;
          spawnProjectile(b.x, b.y - 100, Math.cos(angle) * 4, Math.sin(angle) * 4, b.data.damage * 0.6, 'boss', { color: '#6366f1', size: 25, homing: true, life: 200 });
        }
        playSound('void');
      }
      if (b.stateTimer <= 0) { b.state = 'idle'; b.stateTimer = 60; }
      break;
      
    case 'singularity':
      // Warning effect - spawn every 10 frames instead of every frame
      if (b.stateTimer > 70 && b.stateTimer % 10 === 0) {
        spawnEffect('hit', b.x, b.y - 100, { color: '#c026d3', size: 50 });
      }
      if (b.stateTimer === 70) {
        playSound('void');
      }
      if (b.stateTimer === 20) {
        // Big damage in area
        if (dist < 400 && p.invuln <= 0) damagePlayer(b.data.damage * 2);
        spawnEffect('singularity', b.x, b.y - 100, { color: '#c026d3', size: 400, life: 60 });
        screenFx.addShake(45);
      }
      if (b.stateTimer <= 0) { b.state = 'idle'; b.stateTimer = 70; }
      break;
      
    case 'void_combo':
      if (b.stateTimer % 30 === 20 && b.comboCount < 3) {
        game.anim.state = 'attack'; game.anim.timer = 20;
        safeTimeout(() => {
          if (b.critical > 0) return;
          if (Math.abs(p.x - b.x) < 180 && p.invuln <= 0) damagePlayer(b.data.damage * 0.8);
          spawnEffect('void_slash', b.x + b.facing * 90, b.y - 100, { color: '#6366f1', facing: b.facing, size: 1.5 });
        }, 150);
        b.comboCount++;
        playSound('void');
      }
      if (b.stateTimer <= 0) { b.state = 'idle'; b.stateTimer = 60; }
      break;
      
    case 'phase_change':
      // Just wait, then go idle
      if (b.stateTimer <= 0) { 
        b.state = 'idle'; 
        b.stateTimer = 20;
        PhaseManager.endTransition();
      }
      break;
      
    case 'stagger':
      // CRITICAL: Handle stagger state - boss is stunned
      if (b.stateTimer <= 0) {
        b.state = 'idle';
        b.stateTimer = 30;
      }
      break;
      
    default:
      // SAFETY: Any unknown state goes to idle
      b.state = 'idle';
      b.stateTimer = 20;
      break;
  }
}

function updateFlameWyrmAI(p, b, phase, dist, speedMult, aggression) {
  const attacks = phase.attacks;
  
  // Proactive attack timer for Wyrm - attacks frequently
  if (!b.attackCooldown) b.attackCooldown = 0;
  b.attackCooldown -= screenFx.slowmo;
  
  // WYRM MOVEMENT - Apply gravity (wyrm can jump too!)
  if (!b.vy) b.vy = 0;
  if (!b.grounded) {
    b.vy += 0.9; // Heavier gravity for wyrm
    b.y += b.vy * screenFx.slowmo;
    if (b.y >= CFG.GROUND_Y) {
      b.y = CFG.GROUND_Y;
      b.vy = 0;
      b.grounded = true;
      screenFx.addShake(20);
      spawnEffect('land', b.x, b.y, { color: '#f97316', size: 100 });
    }
  }
  
  switch (b.state) {
    case 'idle':
      // Flame Wyrm is aggressive - attacks constantly
      if (b.stateTimer <= 0 || b.attackCooldown <= 0) {
        b.attackCooldown = 20 + Math.random() * 15; // Very fast attack rate
        const roll = Math.random();
        
        // Add jump attack when player is above
        const playerAbove = p.y < b.y - 80;
        
        if (playerAbove && roll < 0.4) {
          b.state = 'leap_attack'; b.stateTimer = 50;
          b.vy = -20;
          b.grounded = false;
        } else if (dist < 150) {
          // Close range - bite attacks
          if (attacks.includes('bite_combo') && roll < 0.45 * aggression) {
            b.state = 'bite_combo'; b.stateTimer = 60; b.comboCount = 0;
          } else if (attacks.includes('tail_sweep') && roll < 0.35) {
            b.state = 'tail_sweep'; b.stateTimer = 50;
          } else {
            b.state = 'bite'; b.stateTimer = 28;
          }
        } else if (dist < 400) {
          // Mid range - breath or dash
          if (attacks.includes('fire_breath') && roll < 0.4) {
            b.state = 'fire_breath'; b.stateTimer = 70; b.breathTimer = 0;
          } else if (attacks.includes('flame_dash')) {
            b.state = 'flame_dash'; b.stateTimer = 40; b.dashTarget = p.x;
          } else if (attacks.includes('eruption') && roll < 0.4) {
            b.state = 'eruption'; b.stateTimer = 55;
          } else {
            b.state = 'slither'; b.stateTimer = 25;
          }
        } else {
          // Far range - gap close aggressively
          if (attacks.includes('flame_dash')) {
            b.state = 'flame_dash'; b.stateTimer = 40; b.dashTarget = p.x;
          } else if (attacks.includes('eruption') && roll < 0.5) {
            b.state = 'eruption'; b.stateTimer = 55;
          } else {
            b.state = 'slither'; b.stateTimer = 30;
          }
        }
      }
      // Aggressive idle movement
      b.x += b.facing * 3 * speedMult * screenFx.slowmo;
      if (Math.random() < 0.03) b.facing *= -1;
      break;
      
    case 'slither':
      // Very fast darting movement - Wyrm is fast
      b.x += b.facing * 10 * speedMult * screenFx.slowmo;
      if (dist < 130) { 
        b.state = 'idle'; b.stateTimer = 2; 
        b.attackCooldown = 0;
      } else if (b.stateTimer <= 0) { 
        b.state = 'idle'; b.stateTimer = 5; 
      }
      break;
      
    case 'leap_attack':
      // Leap at player
      b.x += b.facing * 6 * speedMult * screenFx.slowmo;
      if (b.grounded && b.stateTimer < 35) {
        if (dist < 130 && p.invuln <= 0) {
          damagePlayer(b.data.damage);
        }
        spawnEffect('fire_pillar', b.x, b.y, { color: '#f97316', size: 100 });
        screenFx.addShake(25);
        b.state = 'idle'; b.stateTimer = 20;
      }
      if (b.stateTimer <= 0) { b.state = 'idle'; b.stateTimer = 15; }
      break;
      
    case 'bite':
      if (b.stateTimer === 20) {
        game.anim.state = 'attack'; game.anim.timer = 15;
        playSound('fire');
      }
      if (b.stateTimer === 10) {
        if (dist < 150 && p.invuln <= 0) damagePlayer(b.data.damage * 0.8);
        spawnEffect('hit', b.x + b.facing * 80, b.y - 60, { color: '#f97316' });
      }
      if (b.stateTimer <= 0) { b.state = 'idle'; b.stateTimer = 20; }
      break;
      
    case 'bite_combo':
      if (b.stateTimer % 15 === 10 && b.comboCount < 5) {
        game.anim.state = 'attack'; game.anim.timer = 10;
        safeTimeout(() => {
          if (b.critical > 0) return;
          if (Math.abs(p.x - b.x) < 150 && p.invuln <= 0) damagePlayer(b.data.damage * 0.6);
          spawnEffect('hit', b.x + b.facing * 70, b.y - 60, { color: '#f97316' });
        }, 80);
        b.comboCount++;
        playSound('fire');
      }
      if (b.stateTimer <= 0) { b.state = 'idle'; b.stateTimer = 40; }
      break;
      
    case 'fire_breath':
      game.anim.state = 'breath'; game.anim.timer = 5;
      b.breathTimer++;
      if (b.breathTimer % 5 === 0) {
        // Continuous fire
        const breathDist = 350;
        if (dist < breathDist && Math.abs(p.y - b.y) < 100 && p.invuln <= 0) {
          if ((b.facing === 1 && p.x > b.x) || (b.facing === -1 && p.x < b.x)) {
            damagePlayer(b.data.damage * 0.4);
          }
        }
        // Fire particles
        for (let i = 0; i < 3; i++) {
          spawnProjectile(b.x + b.facing * 80, b.y - 50, b.facing * (15 + Math.random() * 5), (Math.random() - 0.5) * 5, 0, 'visual', { color: '#ff6b35', size: 15, life: 30 });
        }
        bg.addHazard('fire_patch', b.x + b.facing * (150 + Math.random() * 200), CFG.GROUND_Y, 180);
      }
      if (b.stateTimer <= 0) { b.state = 'idle'; b.stateTimer = 40; }
      break;
      
    case 'flame_dash':
      if (b.stateTimer > 30) {
        // Wind up - spawn warning every 8 frames instead of every frame
        if (b.stateTimer % 8 === 0) {
          spawnEffect('hit', b.x, b.y - 60, { color: '#f97316', size: 40 });
        }
      } else {
        // Dash!
        const dashDir = b.dashTarget > b.x ? 1 : -1;
        b.x += dashDir * 25 * screenFx.slowmo;
        if (Math.abs(p.x - b.x) < 60 && p.invuln <= 0) damagePlayer(b.data.damage * 1.2);
        // Spawn fire trail every 3 frames instead of every frame
        if (b.stateTimer % 3 === 0) {
          spawnEffect('hit', b.x - dashDir * 30, b.y - 60, { color: '#f97316', life: 15 });
        }
      }
      if (b.stateTimer <= 0) { b.state = 'idle'; b.stateTimer = 30; }
      break;
      
    case 'tail_sweep':
      if (b.stateTimer === 35) {
        game.anim.state = 'attack'; game.anim.timer = 25;
        playSound('fire');
      }
      if (b.stateTimer === 15) {
        // Wide sweep behind and in front
        if (dist < 250 && p.invuln <= 0) damagePlayer(b.data.damage);
        spawnEffect('tail_sweep', b.x, b.y - 40, { color: '#f97316', size: 250 });
        screenFx.addShake(25);
      }
      if (b.stateTimer <= 0) { b.state = 'idle'; b.stateTimer = 35; }
      break;
      
    case 'eruption':
      if (b.stateTimer === 60) {
        playSound('fire');
        // Spawn warning markers
        for (let i = 0; i < 6; i++) {
          const ex = 150 + i * 150;
          spawnEffect('hit', ex, CFG.GROUND_Y - 20, { color: '#ff4500', size: 50 });
        }
      }
      if (b.stateTimer === 20) {
        // Eruptions!
        for (let i = 0; i < 6; i++) {
          const ex = 150 + i * 150;
          spawnEffect('eruption', ex, CFG.GROUND_Y - 60, { color: '#f97316', size: 120 });
          bg.addHazard('fire_patch', ex, CFG.GROUND_Y, 240);
          if (Math.abs(p.x - ex) < 60 && p.invuln <= 0) damagePlayer(b.data.damage * 1.5);
        }
        screenFx.addShake(40);
      }
      if (b.stateTimer <= 0) { b.state = 'idle'; b.stateTimer = 50; }
      break;
      
    case 'phase_change':
      if (b.stateTimer <= 0) { 
        b.state = 'idle'; 
        b.stateTimer = 20;
        PhaseManager.endTransition();
      }
      break;
      
    case 'stagger':
      // CRITICAL: Handle stagger state - boss is stunned
      if (b.stateTimer <= 0) {
        b.state = 'idle';
        b.stateTimer = 30;
      }
      break;
      
    default:
      // SAFETY: Any unknown state goes to idle
      b.state = 'idle';
      b.stateTimer = 20;
      break;
  }
}

function updateFrostQueenAI(p, b, phase, dist, speedMult, aggression) {
  const attacks = phase.attacks;
  
  // Proactive attack timer - Frost Queen is tactical but relentless
  if (!b.attackCooldown) b.attackCooldown = 0;
  b.attackCooldown -= screenFx.slowmo;
  
  // FROST QUEEN FLOATING - She hovers and can move vertically
  if (!b.floatY) b.floatY = 0;
  b.floatY = Math.sin(frame * 0.03) * 15; // Gentle hover
  
  switch (b.state) {
    case 'idle':
      // Frost Queen attacks strategically but frequently
      if (b.stateTimer <= 0 || b.attackCooldown <= 0) {
        b.attackCooldown = 28 + Math.random() * 20; // Faster attack rate
        const roll = Math.random();
        
        // Prioritize barrier if low and vulnerable
        if (attacks.includes('frost_barrier') && b.barrierHP <= 0 && roll < 0.3 * aggression) {
          b.state = 'frost_barrier'; b.stateTimer = 35;
        } 
        // Close range - ice combos or ice dash
        else if (dist < 200) {
          if (roll < 0.3) {
            b.state = 'ice_dash'; b.stateTimer = 40;
          } else if (attacks.includes('ice_combo') && roll < 0.5) {
            b.state = 'ice_combo'; b.stateTimer = 60; b.comboCount = 0;
          } else if (attacks.includes('ice_pillars')) {
            b.state = 'ice_pillars'; b.stateTimer = 65;
          } else {
            b.state = 'ice_lance'; b.stateTimer = 45;
          }
        }
        // Mid range - zone control
        else if (dist < 450) {
          if (attacks.includes('blizzard') && roll < 0.35 * aggression) {
            b.state = 'blizzard'; b.stateTimer = 150;
          } else if (attacks.includes('ice_pillars') && roll < 0.4) {
            b.state = 'ice_pillars'; b.stateTimer = 65;
          } else if (attacks.includes('ice_lance')) {
            b.state = 'ice_lance'; b.stateTimer = 45;
          } else if (attacks.includes('absolute_zero') && roll < 0.25 * aggression) {
            b.state = 'absolute_zero'; b.stateTimer = 120;
          } else {
            b.state = 'glide'; b.stateTimer = 30;
          }
        }
        // Far range - ranged attacks or close gap
        else {
          if (roll < 0.3) {
            b.state = 'ice_dash'; b.stateTimer = 50;
          } else if (attacks.includes('blizzard') && roll < 0.4) {
            b.state = 'blizzard'; b.stateTimer = 150;
          } else if (attacks.includes('absolute_zero') && roll < 0.3 * aggression) {
            b.state = 'absolute_zero'; b.stateTimer = 120;
          } else if (attacks.includes('ice_lance')) {
            b.state = 'ice_lance'; b.stateTimer = 45;
          } else {
            b.state = 'glide'; b.stateTimer = 35;
          }
        }
      }
      // Elegant idle movement
      b.x += b.facing * 2 * speedMult * screenFx.slowmo;
      if (Math.random() < 0.02) b.facing *= -1;
      break;
      
    case 'glide':
      // Elegant but purposeful movement toward player
      const targetDir = p.x > b.x ? 1 : -1;
      b.x += targetDir * 7 * speedMult * screenFx.slowmo;
      if (dist < 180) { 
        b.state = 'idle'; b.stateTimer = 3;
        b.attackCooldown = 0;
      } else if (b.stateTimer <= 0) { 
        b.state = 'idle'; b.stateTimer = 8; 
      }
      break;
      
    case 'ice_dash':
      // Quick dash leaving ice trail
      if (b.stateTimer > 25) {
        // Wind up - only spawn effect every 8 frames
        if (b.stateTimer % 8 === 0) {
          spawnEffect('frost_charge', b.x, b.y - 100, { color: '#06b6d4', size: 40, life: 8 });
        }
      } else {
        // Dash!
        b.x += b.facing * 15 * speedMult * screenFx.slowmo;
        // Leave ice trail - less frequently
        if (b.stateTimer % 8 === 0) {
          bg.addHazard('ice_patch', b.x, CFG.GROUND_Y, 90);
        }
        if (dist < 80 && p.invuln <= 0) {
          damagePlayer(b.data.damage);
          p.slowedTimer = 120;
          p.slowAmount = 0.6;
        }
      }
      if (b.stateTimer <= 0) { b.state = 'idle'; b.stateTimer = 25; }
      break;
      
    case 'ice_lance':
      if (b.stateTimer === 30) {
        game.anim.state = 'attack'; game.anim.timer = 25;
        // Precise projectile
        const angle = Math.atan2((p.y - 60) - (b.y - 100), p.x - b.x);
        spawnProjectile(b.x, b.y - 100, Math.cos(angle) * 18, Math.sin(angle) * 18, b.data.damage, 'boss', { color: '#06b6d4', size: 20, element: 'ice' });
        playSound('freeze');
      }
      if (b.stateTimer <= 0) { b.state = 'idle'; b.stateTimer = 30; }
      break;
      
    case 'frost_barrier':
      if (b.stateTimer === 20) {
        b.barrierHP = 200;
        spawnEffect('hit', b.x, b.y - 100, { color: '#67e8f9', size: 80 }); // Simple hit effect instead
        playSound('freeze');
      }
      if (b.stateTimer <= 0) { b.state = 'idle'; b.stateTimer = 20; }
      break;
      
    case 'blizzard':
      // Continuous slow effect
      if (p.slowedTimer <= 0) {
        p.slowedTimer = 240;
        p.slowAmount = 0.5;
        spawnDmgNum(p.x, p.y - 100, 'SLOWED!', 'block');
      }
      // Damage over time
      if (b.stateTimer % 30 === 0 && p.invuln <= 0) {
        damagePlayer(b.data.damage * 0.2);
      }
      // Visual - reduced spawn rate (every 15 frames instead of 5) and shorter life
      if (b.stateTimer % 15 === 0) {
        spawnProjectile(Math.random() * 1200, -50, (Math.random() - 0.5) * 3, 8 + Math.random() * 4, 0, 'visual', { color: '#cffafe', size: 8, life: 40 });
      }
      if (b.stateTimer <= 0) { b.state = 'idle'; b.stateTimer = 60; }
      break;
      
    case 'ice_pillars':
      if (b.stateTimer === 45) {
        playSound('freeze');
        // Spawn at player position and nearby
        const positions = [p.x - 100, p.x, p.x + 100, p.x + 200];
        positions.forEach((px, i) => {
          safeTimeout(() => {
            bg.addHazard('ice_pillar', px, CFG.GROUND_Y, 180);
            spawnEffect('ice_pillar', px, CFG.GROUND_Y - 60, { color: '#06b6d4', life: 30 });
            if (Math.abs(p.x - px) < 40 && p.invuln <= 0) damagePlayer(b.data.damage * 1.2);
            screenFx.addShake(15);
          }, i * 100);
        });
      }
      if (b.stateTimer <= 0) { b.state = 'idle'; b.stateTimer = 40; }
      break;
      
    case 'ice_combo':
      if (b.stateTimer % 25 === 15 && b.comboCount < 4) {
        game.anim.state = 'attack'; game.anim.timer = 20;
        safeTimeout(() => {
          if (b.critical > 0) return;
          if (Math.abs(p.x - b.x) < 160 && p.invuln <= 0) damagePlayer(b.data.damage * 0.7);
          spawnEffect('ice_slash', b.x + b.facing * 80, b.y - 100, { color: '#06b6d4', facing: b.facing });
        }, 120);
        b.comboCount++;
        playSound('freeze');
      }
      if (b.stateTimer <= 0) { b.state = 'idle'; b.stateTimer = 50; }
      break;
      
    case 'absolute_zero':
      // Warning effect - spawn only every 10 frames, not every frame!
      if (b.stateTimer > 60 && b.stateTimer % 10 === 0) {
        spawnEffect('hit', 600, CFG.GROUND_Y - 100, { color: '#f0f9ff', size: 60 });
      }
      if (b.stateTimer === 60) {
        playSound('freeze');
      }
      if (b.stateTimer === 20) {
        // Freeze center of arena
        const centerDist = Math.abs(p.x - 600);
        if (centerDist < 300 && p.invuln <= 0) {
          damagePlayer(b.data.damage * 2.5);
          p.stagger = 60; // Frozen
          spawnDmgNum(p.x, p.y - 100, 'FROZEN!', 'break');
        }
        spawnEffect('absolute_zero', 600, CFG.GROUND_Y - 100, { color: '#f0f9ff', size: 300, life: 60 });
        screenFx.addShake(50);
        screenFx.addTint('#cffafe', 0.4);
      }
      if (b.stateTimer <= 0) { b.state = 'idle'; b.stateTimer = 70; }
      break;
      
    case 'phase_change':
      if (b.stateTimer <= 0) { 
        b.state = 'idle'; 
        b.stateTimer = 20;
        PhaseManager.endTransition();
      }
      break;
      
    case 'stagger':
      // CRITICAL: Handle stagger state - boss is stunned
      if (b.stateTimer <= 0) {
        b.state = 'idle';
        b.stateTimer = 30;
      }
      break;
      
    default:
      // SAFETY: Any unknown state goes to idle
      console.warn('Frost Queen unknown state:', b.state);
      b.state = 'idle';
      b.stateTimer = 20;
      break;
  }
}

// ============ SAFE TIMEOUT SYSTEM ============
// Prevents orphaned callbacks that cause crashes
const activeTimeouts = new Set();

function safeTimeout(fn, delay) {
  const id = setTimeout(() => {
    activeTimeouts.delete(id);
    // Only execute if game is still valid
    if (game && state === 'game' && !game.victory && !game.gameOver) {
      fn();
    }
  }, delay);
  activeTimeouts.add(id);
  return id;
}

function clearAllTimeouts() {
  activeTimeouts.forEach(id => clearTimeout(id));
  activeTimeouts.clear();
}

// ============ PHASE TRANSITION MANAGER ============
// Prevents overlapping transitions and effect spam
const PhaseManager = {
  isTransitioning: false,
  lastTransitionTime: 0,
  minTransitionGap: 500, // Minimum 500ms between phase transitions
  
  canTransition() {
    const now = Date.now();
    if (this.isTransitioning) return false;
    if (now - this.lastTransitionTime < this.minTransitionGap) return false;
    return true;
  },
  
  startTransition() {
    if (!this.canTransition()) return false;
    this.isTransitioning = true;
    this.lastTransitionTime = Date.now();
    return true;
  },
  
  endTransition() {
    this.isTransitioning = false;
    screenFx.resetSlowmo();
  },
  
  reset() {
    this.isTransitioning = false;
    this.lastTransitionTime = 0;
  }
};

// ============ UPDATE ============
function update() {
  frame++;
  if (state !== 'game' || !game || isPaused) return;
  
  // ENHANCED: Update TierSystem UI and V cooldown
  if (typeof TierSystem !== 'undefined') {
    TierSystem.updateVCooldown();
    TierSystem.updateUI();
  }
  
  // === GAME PAUSED FOR QUIZ/ITEM ===
  if (game.gamePaused) {
    // Handle item collection pause
    if (game.itemPauseTimer && game.itemPauseTimer > 0) {
      game.itemPauseTimer--;
      if (game.itemPauseTimer <= 0) {
        game.gamePaused = false;
        game.itemCollected = null;
      }
    }
    
    // Only update quiz systems and visual effects during pause
    QuizSystem.update();
    KnowledgeSystem.update();
    screenFx.update();
    // Still render damage numbers and effects (frozen in place)
    game.effects = game.effects.filter(e => { e.life--; return e.life > 0; });
    game.dmgNums = game.dmgNums.filter(dn => { dn.life--; return dn.life > 0; });
    return;
  }
  
  const p = game.player, b = game.boss;
  
  // SIMPLIFIED: Just decrement hitstop
  if (screenFx.hitstop > 0) { 
    screenFx.hitstop--; 
    return; 
  }
  const dt = 1; // FIXED dt instead of slowmo
  
  if (game.victory || game.gameOver) {
    screenFx.update(); particles.update();
    if (killCam) { killCam.timer--; if (killCam.timer <= 0) killCam = null; }
    return;
  }
  
  // === BOSS JUGGLE STATE ===
  if (b.airborne) {
    b.juggleTimer--;
    if (b.juggleTimer <= 0 || b.grounded) {
      b.airborne = false;
      b.juggleTimer = 0;
    }
  }
  
  // === ELEMENTAL DOT EFFECTS ===
  // Fire burn - damage over time
  if (b.burning > 0) {
    b.burning--;
    if (frame % 20 === 0) {
      const burnDmg = 5;
      b.hp -= burnDmg;
      game.stats.dmg += burnDmg;
      spawnDmgNum(b.x + (Math.random() - 0.5) * 40, b.y - 80, burnDmg, 'fire');
      spawnEffect('spark', b.x + (Math.random() - 0.5) * 60, b.y - 50, { color: '#ff6b35' });
    }
  }
  
  // Ice freeze - slowed
  if (b.frozen > 0) {
    b.frozen--;
    // Visual frost effect
    if (frame % 30 === 0) {
      spawnEffect('spark', b.x + (Math.random() - 0.5) * 80, b.y - 60, { color: '#67e8f9' });
    }
  }
  
  // Void drain - drain mana/posture
  if (b.voidMarked > 0) {
    b.voidMarked--;
    if (frame % 15 === 0) {
      const drainDmg = 3;
      b.hp -= drainDmg;
      b.posture += 2; // Build posture faster
      game.stats.dmg += drainDmg;
      // Heal player slightly
      p.hp = Math.min(p.maxHp, p.hp + 1);
      spawnEffect('spark', b.x + (Math.random() - 0.5) * 50, b.y - 70, { color: '#10b981' });
    }
  }
  
  // QUIZ SYSTEM - RE-ENABLED with 30-second intervals
  QuizSystem.combatTimer++;
  
  // Cooldown after quiz ends
  if (QuizSystem.postQuizCooldown > 0) {
    QuizSystem.postQuizCooldown--;
  }
  
  const bossHpPct = b.hp / b.maxHp;
  
  // Check boss HP thresholds for quiz triggers
  let shouldTriggerQuiz = false;
  for (const threshold of QuizSystem.bossHPTriggers) {
    if (bossHpPct <= threshold && !QuizSystem.bossHPTriggered.has(threshold)) {
      QuizSystem.bossHPTriggered.add(threshold);
      shouldTriggerQuiz = true;
      break;
    }
  }
  
  // Time-based trigger (every 30 seconds)
  if (QuizSystem.combatTimer >= QuizSystem.questionInterval) {
    QuizSystem.combatTimer = 0;
    shouldTriggerQuiz = true;
  }
  
  // Check if we should trigger a quiz
  if (shouldTriggerQuiz && !game.victory && !game.gameOver && !QuizSystem.active && QuizSystem.postQuizCooldown <= 0) {
    // Don't exceed max questions
    if (QuizSystem.questionsAskedThisGame.length < QuizSystem.maxQuestionsPerBattle) {
      QuizSystem.startQuestion();
    }
  }
  
  game.gameTime++;
  bg.update();
  particles.update();
  screenFx.update();
  spirit.update(p);
  
  // Slow effect
  if (p.slowedTimer > 0) { p.slowedTimer--; }
  else { p.slowAmount = 1; }
  
  // === ADVANCED MOVEMENT SYSTEM ===
  let mx = 0;
  if (keys['a'] || keys['arrowleft']) mx = -1;
  if (keys['d'] || keys['arrowright']) mx = 1;
  const jumpKey = keys[' '] || keys['w'] || keys['arrowup'];
  const downKey = keys['s'] || keys['arrowdown'];
  
  // Track grounded state change for coyote time
  const wasGroundedLastFrame = p.wasGrounded;
  p.wasGrounded = p.grounded;
  
  // === COYOTE TIME ===
  if (wasGroundedLastFrame && !p.grounded && p.vy >= 0) {
    // Just left ground (falling, not jumping)
    p.coyoteTimer = CFG.COYOTE_TIME;
  }
  if (p.coyoteTimer > 0) p.coyoteTimer--;
  if (p.grounded) p.coyoteTimer = 0;
  
  // === JUMP BUFFERING ===
  if (jumpKey && !keys._jump) {
    p.jumpBuffered = true;
    p.jumpBufferTimer = CFG.JUMP_BUFFER;
  }
  if (p.jumpBufferTimer > 0) p.jumpBufferTimer--;
  if (p.jumpBufferTimer <= 0) p.jumpBuffered = false;
  
  // === ROLL BUFFERING ===
  if ((keys['shift'] || keys['l']) && !p.grounded && p.vy > 5) {
    p.rollBuffered = true;
  }
  
  // === WALL DETECTION ===
  p.touchingWall = false;
  p.wallDir = 0;
  const WALL_LEFT = 60;
  const WALL_RIGHT = 1140;
  if (p.x <= WALL_LEFT + 20 && mx < 0) {
    p.touchingWall = true;
    p.wallDir = -1;
  } else if (p.x >= WALL_RIGHT - 20 && mx > 0) {
    p.touchingWall = true;
    p.wallDir = 1;
  }
  
  // === WALL SLIDE ===
  if (p.touchingWall && !p.grounded && p.vy > 0 && mx === p.wallDir) {
    p.wallSliding = true;
    p.vy = Math.min(p.vy, CFG.WALL_SLIDE_SPEED);
    // Wall slide particles
    if (frame % 5 === 0) {
      spawnEffect('spark', p.x + p.wallDir * 15, p.y - 40, { color: '#888' });
    }
  } else {
    p.wallSliding = false;
  }
  
  // === ROLLING ===
  if (p.rolling) {
    p.rollTimer--;
    p.vx = p.rollDir * CFG.ROLL_SPEED;
    p.invuln = Math.max(p.invuln, 2);
    if (p.rollTimer <= 0) {
      p.rolling = false;
    }
  }
  
  // === GROUND POUND ===
  if (p.groundPounding) {
    p.vy = CFG.GROUND_POUND_SPEED;
    p.vx *= 0.5;
    // Trail effect
    if (frame % 2 === 0) {
      spawnEffect('spark', p.x, p.y - 30, { color: p.cls.color });
    }
  }
  
  // === MOVEMENT (with air control) ===
  if (p.attackTimer <= 0 && p.stagger <= 0 && !p.rolling && !p.groundPounding && p.wallJumpTimer <= 0) {
    const control = p.grounded ? 1 : CFG.AIR_CONTROL;
    p.vx += (mx * CFG.PLAYER_SPEED * p.cls.speed * p.slowAmount * control - p.vx) * 0.26 * control * dt;
    if (mx) p.facing = mx;
  }
  
  // Wall jump timer (prevents immediate air control after wall jump)
  if (p.wallJumpTimer > 0) p.wallJumpTimer--;
  
  if (p.stagger > 0) { p.stagger -= dt; p.vx *= 0.84; }
  
  // === DASH (can cancel attacks) ===
  if ((keys['shift'] || keys['l']) && p.dashCD <= 0 && !keys._dash && p.stagger <= 0 && !p.rolling && !p.groundPounding) {
    keys._dash = true; 
    p.dashCD = 38; 
    p.vx = p.facing * CFG.DASH_SPEED; 
    p.invuln = 22;
    // Cancel attack animation
    if (p.attackTimer > 0) {
      p.attackTimer = 0;
      p.attackCharging = false;
    }
    spawnEffect('dash', p.x, p.y - 60, { color: p.cls.color, facing: p.facing });
    // Motion blur trail
    for (let i = 0; i < 5; i++) {
      spawnEffect('afterimage', p.x - p.facing * i * 20, p.y, { color: p.cls.color, alpha: 0.3 - i * 0.05 });
    }
    playSound('dash');
  }
  if (!keys['shift'] && !keys['l']) keys._dash = false;
  
  // === JUMP (with coyote time, buffering, and variable height) ===
  const canJump = p.grounded || p.coyoteTimer > 0 || p.wallSliding;
  const shouldJump = (jumpKey && !keys._jump) || (p.jumpBuffered && p.grounded);
  
  if (shouldJump && p.stagger <= 0 && !p.groundPounding) {
    if (p.wallSliding) {
      // Wall jump
      keys._jump = true;
      p.jumpBuffered = false;
      p.vy = -CFG.WALL_JUMP_FORCE_Y;
      p.vx = -p.wallDir * CFG.WALL_JUMP_FORCE_X;
      p.facing = -p.wallDir;
      p.wallJumpTimer = 12; // Brief no-control period
      p.grounded = false;
      p.coyoteTimer = 0;
      p.variableJumpUsed = false;
      spawnEffect('walljump', p.x, p.y - 40, { color: p.cls.color });
      playSound('jump');
    } else if (canJump) {
      // Normal/coyote jump
      keys._jump = true;
      p.jumpBuffered = false;
      p.vy = -CFG.JUMP_FORCE;
      p.grounded = false;
      p.coyoteTimer = 0;
      p.variableJumpUsed = false;
      p.groundPoundReady = true;
      spawnEffect('land', p.x, p.y, { color: p.cls.color });
      playSound('jump');
    } else if (p.airJumps > 0) {
      // Air jump
      keys._jump = true;
      p.jumpBuffered = false;
      p.airJumps--;
      p.vy = -CFG.JUMP_FORCE * 0.94;
      p.variableJumpUsed = false;
      p.groundPoundReady = true;
      spawnEffect('doublejump', p.x, p.y, { color: p.cls.color });
      playSound('jump');
    }
  }
  
  // === VARIABLE JUMP HEIGHT ===
  if (!jumpKey && p.vy < 0 && !p.variableJumpUsed) {
    // Released jump button while rising - cut jump short
    p.vy *= CFG.VARIABLE_JUMP_CUT;
    p.variableJumpUsed = true;
  }
  
  if (!jumpKey) keys._jump = false;
  
  // === GROUND POUND ===
  if (downKey && !p.grounded && !p.groundPounding && p.groundPoundReady && p.attackTimer <= 0) {
    if (keys['z'] || keys['j']) {
      // Down + Attack = Ground Pound
      p.groundPounding = true;
      p.groundPoundReady = false;
      p.vy = 0;
      // Brief hang time
      setTimeout(() => {
        if (p.groundPounding) p.vy = CFG.GROUND_POUND_SPEED;
      }, 100);
      playSound('special');
    }
  }
  
  // === PARRY (with crit reward) ===
  if ((keys['q'] || keys['u']) && !keys._parry && p.parryWindow <= 0) {
    keys._parry = true; 
    p.parryWindow = 15;
    p.perfectParry = false;
  }
  if (!keys['q'] && !keys['u']) keys._parry = false;
  
  // Decrement parry crit window
  if (p.parryCritWindow > 0) p.parryCritWindow--;
  
  // === COMBO SYSTEM ===
  const attackPressed = keys['z'] || keys['j'];
  const rangedPressed = keys['x'] || keys['k'];
  const upHeld = keys['w'] || keys['arrowup'];
  const downHeld = downKey;
  
  // Attack charging
  if (attackPressed && !keys._z && p.attackTimer <= 0 && p.stagger <= 0) {
    if (!p.attackCharging) {
      p.attackCharging = true;
      p.chargeTimer = 0;
      p.chargeKey = 'melee';
    }
  }
  
  if (p.attackCharging && p.chargeKey === 'melee') {
    p.chargeTimer++;
    // Visual feedback for charging
    if (p.chargeTimer > 10 && frame % 5 === 0) {
      const chargeLevel = Math.min(1, p.chargeTimer / CFG.CHARGE_TIME);
      spawnEffect('charge', p.x, p.y - 60, { 
        color: p.cls.color, 
        size: 20 + chargeLevel * 30 
      });
    }
  }
  
  // Release charged attack or tap attack
  if (!attackPressed && p.attackCharging && p.chargeKey === 'melee') {
    p.attackCharging = false;
    const fullyCharged = p.chargeTimer >= CFG.CHARGE_TIME;
    
    if (upHeld && !p.grounded) {
      // Up + Attack in air = Launcher
      doLauncher(fullyCharged);
    } else if (downHeld && p.grounded) {
      // Down + Attack on ground = Sweep
      doSweep(fullyCharged);
    } else if (fullyCharged) {
      // Fully charged heavy attack
      doHeavyMelee();
    } else {
      // Normal melee (combo chain)
      doMelee();
    }
    keys._z = true;
  }
  
  if (!attackPressed) keys._z = false;
  
  if (rangedPressed && !keys._x) { keys._x = true; doRanged(); }
  if (!rangedPressed) keys._x = false;
  if ((keys['c'] || keys['i']) && !keys._c) { keys._c = true; doSpecial(); }
  if (!keys['c'] && !keys['i']) keys._c = false;
  if ((keys['v'] || keys['o']) && !keys._v) { 
    keys._v = true; 
    // Check for execution first
    if (typeof ExecutionSystem !== 'undefined' && ExecutionSystem.canExecute()) {
      ExecutionSystem.startExecution();
    } else {
      doUltimate(); 
    }
  }
  if (!keys['v'] && !keys['o']) keys._v = false;
  
  // === PHYSICS ===
  // Gravity (reduced while juggling)
  const grav = (game.boss && game.boss.airborne) ? CFG.GRAVITY * CFG.JUGGLE_GRAVITY : CFG.GRAVITY;
  if (!p.groundPounding) {
    p.vy += grav * dt;
  }
  
  p.x += p.vx * dt; 
  p.y += p.vy * dt;
  if (!p.rolling) p.vx *= 0.84;
  
  // Platform collision - MORE FORGIVING
  let onPlatform = false;
  if (p.vy >= 0 && !p.groundPounding) { // Only check when falling or stationary
    for (const plat of PLATFORMS) {
      const onPlatX = p.x >= plat.x - 15 && p.x <= plat.x + plat.width + 15;
      const nearPlatY = p.y >= plat.y - 5 && p.y <= plat.y + 25;
      const wasFalling = p.y - p.vy >= plat.y - 30;
      
      if (onPlatX && nearPlatY && wasFalling) {
        p.y = plat.y;
        p.vy = 0;
        p.grounded = true;
        p.airJumps = CFG.AIR_JUMPS;
        p.currentPlatform = plat;
        onPlatform = true;
        
        // Roll on landing if buffered
        if (p.rollBuffered) {
          p.rollBuffered = false;
          p.rolling = true;
          p.rollTimer = CFG.ROLL_INVULN;
          p.rollDir = p.facing;
          p.invuln = CFG.ROLL_INVULN;
          spawnEffect('roll', p.x, p.y, { color: p.cls.color });
          playSound('dash');
        }
        break;
      }
    }
  }
  
  // Stay on platform if standing on it
  if (!onPlatform && p.currentPlatform && p.grounded) {
    const plat = p.currentPlatform;
    if (p.x >= plat.x - 15 && p.x <= plat.x + plat.width + 15) {
      p.y = plat.y;
      onPlatform = true;
    } else {
      p.currentPlatform = null;
    }
  }
  
  // Ground collision
  if (p.y >= CFG.GROUND_Y) {
    // Ground pound impact
    if (p.groundPounding) {
      p.groundPounding = false;
      screenFx.shake = 15;
      screenFx.hitstop = CFG.HITSTOP_HEAVY;
      playSound('crit');
      spawnEffect('groundpound', p.x, CFG.GROUND_Y, { color: p.cls.color });
      
      // Damage boss if nearby
      if (game.boss && Math.abs(p.x - game.boss.x) < 200 && game.boss.invuln <= 0) {
        const dmg = CFG.GROUND_POUND_DAMAGE * (p.parryCritWindow > 0 ? CFG.PARRY_CRIT_MULT : 1);
        game.boss.hp -= dmg;
        game.stats.dmg += dmg;
        spawnDmgNum(game.boss.x, game.boss.y - 100, Math.round(dmg), 'special');
      }
    }
    
    p.y = CFG.GROUND_Y;
    if (p.vy > 10) spawnEffect('land', p.x, p.y, { color: p.cls.color });
    
    // Roll on landing if buffered
    if (p.rollBuffered && p.vy > 5) {
      p.rollBuffered = false;
      p.rolling = true;
      p.rollTimer = CFG.ROLL_INVULN;
      p.rollDir = p.facing;
      p.invuln = CFG.ROLL_INVULN;
      spawnEffect('roll', p.x, p.y, { color: p.cls.color });
      playSound('dash');
    }
    
    p.vy = 0; 
    p.grounded = true; 
    p.airJumps = CFG.AIR_JUMPS;
    p.groundPoundReady = true;
  }
  
  // Fall through platform (hold down)
  if (onPlatform && downKey && !p.groundPounding) {
    p.y += 10;
    p.grounded = false;
    p.currentPlatform = null;
  }
  
  p.x = Math.max(60, Math.min(1140, p.x));
  
  // Timers
  if (p.attackTimer > 0) p.attackTimer -= dt;
  if (p.specialCD > 0) p.specialCD -= dt;
  if (p.invuln > 0) p.invuln -= dt;
  if (p.dashCD > 0) p.dashCD -= dt;
  if (p.parryWindow > 0) p.parryWindow -= dt;
  if (p.comboTimer > 0) p.comboTimer -= dt;
  else p.combo = 0;
  // Inferno melee combo timer
  if (p.meleeComboTimer > 0) p.meleeComboTimer -= dt;
  else if (p.meleeCombo > 0) p.meleeCombo = 0;
  // Shadow mark timer (next attack crits)
  if (p.shadowMark > 0) p.shadowMark -= dt;
  if (p.damageBoost > 0) p.damageBoost -= dt; // Damage boost from pickup
  if (p.weaponTimer > 0) p.weaponTimer -= dt; // Weapon duration
  if (p.weaponTimer <= 0 && p.weapon) {
    p.weapon = null;
    p.weaponKey = null;
    spawnDmgNum(p.x, p.y - 80, 'WEAPON EXPIRED', 'block');
  }
  p.mana = Math.min(p.maxMana, p.mana + 0.38 * dt);
  
  // Update item and weapon systems
  ItemSystem.update();
  WeaponSystem.update();
  KnowledgeSystem.update();
  
  // Update minions
  if (typeof MinionSystem !== 'undefined') {
    MinionSystem.update();
  }
  
  // Update execution system
  if (typeof ExecutionSystem !== 'undefined') {
    ExecutionSystem.update();
  }
  
  // Hazard damage
  bg.hazards.forEach(h => {
    if (h.type === 'fire_patch' && Math.abs(p.x - h.x) < 50 && p.y > CFG.GROUND_Y - 30 && p.invuln <= 0 && h.life % 30 === 0) {
      damagePlayer(3);
    }
  });
  
  updateBossAI();
  
  // ===== WEAPON EFFECT TICKS =====
  // Burn DOT
  if (b.burnTimer > 0) {
    b.burnTimer--;
    if (b.burnTimer % 30 === 0 && b.burnDmg > 0) {
      b.hp = Math.max(1, b.hp - b.burnDmg);
      spawnDmgNum(b.x + (Math.random() - 0.5) * 40, b.y - 100, b.burnDmg, 'burn');
    }
  }
  // Slow effect
  if (b.slowTimer > 0) {
    b.slowTimer--;
  }
  
  // Projectiles
  game.projectiles = game.projectiles.filter(proj => {
    proj.trail.unshift({ x: proj.x, y: proj.y });
    if (proj.trail.length > 8) proj.trail.pop();
    
    // Homing
    if (proj.homing && proj.owner === 'boss') {
      const angle = Math.atan2((p.y - 60) - proj.y, p.x - proj.x);
      proj.vx += Math.cos(angle) * 0.3;
      proj.vy += Math.sin(angle) * 0.3;
      const speed = Math.sqrt(proj.vx * proj.vx + proj.vy * proj.vy);
      if (speed > 8) {
        proj.vx = (proj.vx / speed) * 8;
        proj.vy = (proj.vy / speed) * 8;
      }
    }
    
    proj.x += proj.vx * dt;
    proj.y += proj.vy * dt;
    proj.life -= dt;
    
    if (proj.owner === 'player' && b.hp > 0) {
      if (Math.abs(proj.x - b.x) < 72 && Math.abs(proj.y - (b.y - 100)) < 110) {
        spawnEffect('hit', proj.x, proj.y, { color: proj.color, size: 60 });
        particles.emit(proj.x, proj.y, { count: 10, spread: 8, color: proj.color, life: 20, glow: true });
        damageBoss(proj.dmg || 50, Math.random() < 0.2);
        return false;
      }
    }
    if (proj.owner === 'boss' && p.invuln <= 0 && p.stagger <= 0) {
      if (Math.abs(proj.x - p.x) < 52 && Math.abs(proj.y - (p.y - 60)) < 72) {
        damagePlayer(proj.dmg);
        spawnEffect('hit', proj.x, proj.y, { color: proj.color, size: 55 });
        return false;
      }
    }
    
    return proj.life > 0 && proj.x > -70 && proj.x < 1270 && proj.y < 750;
  });
  
  // Effects - with VERY AGGRESSIVE cap
  game.effects = game.effects.filter(e => { e.life--; return e.life > 0; });
  if (game.effects.length > 40) game.effects.splice(0, game.effects.length - 25);
  
  // Damage numbers - with cap
  game.dmgNums = game.dmgNums.filter(dn => {
    dn.y += dn.vy * dt;
    dn.vy += 0.16 * dt;
    dn.life -= dt;
    return dn.life > 0;
  });
  if (game.dmgNums.length > 15) game.dmgNums.splice(0, game.dmgNums.length - 8);
  
  // Projectiles cap - more aggressive
  if (game.projectiles.length > 30) game.projectiles.splice(0, game.projectiles.length - 20);
  
  // Particles cap
  if (particles && particles.list && particles.list.length > 80) {
    particles.list.splice(0, particles.list.length - 40);
  }
}

// ============ RENDER ============
function render() {
  // CRITICAL: Clear the ENTIRE canvas (accounting for DPR)
  ctx.setTransform(1, 0, 0, 1, 0, 0);
  ctx.clearRect(0, 0, canvas.width, canvas.height); // Use actual canvas size
  ctx.scale(dpr, dpr); // Re-apply DPR scaling
  
  if (state === 'menu') { renderMenu(); return; }
  if (state === 'charSelect') { renderCharSelect(); return; }
  if (state === 'diffSelect') { renderDiffSelect(); return; }
  if (state === 'bossSelect') { renderBossSelect(); return; }
  if (!game) return;
  
  const p = game.player, b = game.boss;
  
  // Reset canvas state
  ctx.globalAlpha = 1;
  ctx.shadowBlur = 0;
  
  screenFx.pre(ctx);
  
  // CRITICAL: Wrap ALL rendering in try/finally to ensure screenFx.post() ALWAYS runs
  try {
  bg.render(ctx, 1 - b.hp / b.maxHp);
  
  // Ground
  const groundHue = b.key === 'FLAME_WYRM' ? 15 : b.key === 'FROST_QUEEN' ? 200 : 250;
  ctx.fillStyle = `hsl(${groundHue}, 30%, 15%)`;
  ctx.fillRect(0, CFG.GROUND_Y, 1200, 120);
  const groundGrad = ctx.createLinearGradient(0, CFG.GROUND_Y, 0, CFG.GROUND_Y + 8);
  groundGrad.addColorStop(0, `hsl(${groundHue}, 40%, 25%)`);
  groundGrad.addColorStop(1, `hsl(${groundHue}, 30%, 15%)`);
  ctx.fillStyle = groundGrad;
  ctx.fillRect(0, CFG.GROUND_Y, 1200, 8);
  
  // Platforms (SOLID - highly visible)
  PLATFORMS.forEach(plat => {
    // Platform shadow
    ctx.fillStyle = 'rgba(0,0,0,0.6)';
    ctx.fillRect(plat.x + 6, plat.y + 6, plat.width, plat.height);
    
    // Platform body based on type - BRIGHTER COLORS
    let bodyColor, topColor, glowColor, borderColor;
    if (plat.type === 'stone') {
      bodyColor = '#5a6475';
      topColor = '#8899aa';
      glowColor = '#b8c8d8';
      borderColor = '#9aa8b8';
    } else if (plat.type === 'metal') {
      bodyColor = '#4a5260';
      topColor = '#7a8490';
      glowColor = '#a0aab8';
      borderColor = '#8a94a0';
    } else if (plat.type === 'crystal') {
      bodyColor = '#7577f8';
      topColor = '#9598ff';
      glowColor = '#b8baff';
      borderColor = '#a5a8ff';
    } else {
      bodyColor = `hsl(${groundHue}, 40%, 40%)`;
      topColor = `hsl(${groundHue}, 45%, 55%)`;
      glowColor = `hsl(${groundHue}, 50%, 65%)`;
      borderColor = `hsl(${groundHue}, 45%, 50%)`;
    }
    
    // Main body (solid fill - no transparency)
    const platGrad = ctx.createLinearGradient(plat.x, plat.y, plat.x, plat.y + plat.height);
    platGrad.addColorStop(0, topColor);
    platGrad.addColorStop(0.5, bodyColor);
    platGrad.addColorStop(1, '#2a2a4e');
    ctx.fillStyle = platGrad;
    ctx.beginPath();
    ctx.roundRect(plat.x, plat.y, plat.width, plat.height, 4);
    ctx.fill();
    
    // Platform border (thicker)
    ctx.strokeStyle = borderColor;
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.roundRect(plat.x, plat.y, plat.width, plat.height, 4);
    ctx.stroke();
    
    // Top edge highlight (brighter)
    ctx.fillStyle = glowColor;
    ctx.fillRect(plat.x + 2, plat.y, plat.width - 4, 4);
    
    // Glow effect for crystal platforms
    if (plat.type === 'crystal') {
      ctx.shadowColor = glowColor;
      ctx.shadowBlur = 20;
      ctx.fillStyle = glowColor;
      ctx.fillRect(plat.x, plat.y, plat.width, 3);
      ctx.shadowBlur = 0;
    }
    
    // Surface detail lines
    ctx.strokeStyle = topColor + '60';
    ctx.lineWidth = 1;
    for (let i = 1; i < 4; i++) {
      const lineX = plat.x + (plat.width / 4) * i;
      ctx.beginPath();
      ctx.moveTo(lineX, plat.y + 4);
      ctx.lineTo(lineX, plat.y + plat.height - 2);
      ctx.stroke();
    }
  });
  
  // Items
  ItemSystem.render(ctx);
  
  // Weapons
  WeaponSystem.render(ctx);
  
  // Minions
  if (typeof MinionSystem !== 'undefined') {
    MinionSystem.render(ctx);
  }
  
  // Boss
  bossRenderer(ctx, b, b.data, game.anim);
  
  // Player
  spirit.render(ctx, p);
  
  // Projectiles
  game.projectiles.forEach(proj => {
    if (proj.owner === 'visual') {
      ctx.fillStyle = proj.color;
      ctx.globalAlpha = proj.life / 30;
      ctx.beginPath(); ctx.arc(proj.x, proj.y, proj.size, 0, Math.PI * 2); ctx.fill();
      ctx.globalAlpha = 1;
      return;
    }
    
    if (proj.trail.length > 1) {
      ctx.strokeStyle = proj.color + '70';
      ctx.lineWidth = proj.size * 0.7;
      ctx.lineCap = 'round';
      ctx.beginPath();
      ctx.moveTo(proj.x, proj.y);
      proj.trail.forEach(pt => ctx.lineTo(pt.x, pt.y));
      ctx.stroke();
    }
    const glowGrad = ctx.createRadialGradient(proj.x, proj.y, 0, proj.x, proj.y, proj.size * 2.8);
    glowGrad.addColorStop(0, proj.color);
    glowGrad.addColorStop(0.5, proj.color + '98');
    glowGrad.addColorStop(1, 'transparent');
    ctx.fillStyle = glowGrad;
    ctx.beginPath(); ctx.arc(proj.x, proj.y, proj.size * 2.8, 0, Math.PI * 2); ctx.fill();
    ctx.fillStyle = '#fff';
    ctx.beginPath(); ctx.arc(proj.x, proj.y, proj.size * 0.48, 0, Math.PI * 2); ctx.fill();
  });
  
  // Particles
  particles.render(ctx);
  
  // Effects - WITH AGGRESSIVE FRAME BUDGET SYSTEM
  const effectsStartTime = performance.now();
  const MAX_EFFECTS_TIME = 8; // Reduced to 8ms for effects
  let effectsRendered = 0;
  
  // Sort effects so important ones render first
  const sortedEffects = game.effects.slice().sort((a, b) => {
    const importantTypes = ['hit', 'break', 'phase_burst'];
    const aImportant = importantTypes.includes(a.type) ? 0 : 1;
    const bImportant = importantTypes.includes(b.type) ? 0 : 1;
    return aImportant - bImportant;
  });
  
  sortedEffects.forEach(e => {
    // Frame budget check - skip if taking too long
    if (performance.now() - effectsStartTime > MAX_EFFECTS_TIME && effectsRendered > 8) {
      return; // Skip this effect to maintain framerate
    }
    effectsRendered++;
    
    const prog = Math.max(0, Math.min(1, 1 - e.life / e.maxLife));
    
    // Skip effects with invalid progress
    if (isNaN(prog) || prog < 0 || prog > 1) {
      return;
    }
    
    // ALWAYS use save/restore to prevent canvas state corruption
    ctx.save();
    ctx.globalAlpha = Math.max(0.01, 1 - prog); // Min 0.01 to avoid 0 alpha issues
    
    try {
      // === GENERIC EFFECTS ===
      if (['hit', 'break', 'enrage'].includes(e.type)) {
        const size = Math.max(1, (e.size || 75) * (0.5 + prog * 0.6));
        const grad = ctx.createRadialGradient(e.x, e.y, 0, e.x, e.y, size);
        grad.addColorStop(0, '#fff');
        grad.addColorStop(0.3, e.color);
        grad.addColorStop(1, 'transparent');
        ctx.fillStyle = grad;
        ctx.beginPath(); ctx.arc(e.x, e.y, size, 0, Math.PI * 2); ctx.fill();
        ctx.restore();
        return; // Early return after restore
      }
    
    // === INFERNO CLASS EFFECTS (Fire/Orange) ===
    if (e.type === 'fire_punch') {
      // Blazing fist - flame burst with streaks
      const facing = e.facing || 1;
      ctx.translate(e.x, e.y);
      ctx.scale(facing, 1);
      // Flame core
      const flameGrad = ctx.createRadialGradient(0, 0, 0, 0, 0, 60 * (1 - prog * 0.5));
      flameGrad.addColorStop(0, '#fff');
      flameGrad.addColorStop(0.3, '#fbbf24');
      flameGrad.addColorStop(0.6, '#ff6b35');
      flameGrad.addColorStop(1, 'transparent');
      ctx.fillStyle = flameGrad;
      ctx.beginPath(); ctx.arc(0, 0, 60 * (1 - prog * 0.5), 0, Math.PI * 2); ctx.fill();
      // Flame streaks
      for (let i = 0; i < 5; i++) {
        const angle = -0.8 + i * 0.4 + (Math.random() - 0.5) * 0.2;
        const len = 40 + Math.random() * 30;
        ctx.strokeStyle = i % 2 === 0 ? '#ff6b35' : '#fbbf24';
        ctx.lineWidth = 4 * (1 - prog);
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(Math.cos(angle) * len * prog, Math.sin(angle) * len * prog);
        ctx.stroke();
      }
      // Note: ctx.restore() is now handled at end of forEach loop
    }
    
    if (e.type === 'fire_launch') {
      // Fireball spawn - expanding ring with sparks
      const size = (e.size || 40) * (0.5 + prog);
      ctx.strokeStyle = '#fbbf24';
      ctx.lineWidth = 3 * (1 - prog);
      ctx.beginPath(); ctx.arc(e.x, e.y, size, 0, Math.PI * 2); ctx.stroke();
      // Inner glow
      const grad = ctx.createRadialGradient(e.x, e.y, 0, e.x, e.y, size * 0.6);
      grad.addColorStop(0, '#fff8');
      grad.addColorStop(1, 'transparent');
      ctx.fillStyle = grad;
      ctx.beginPath(); ctx.arc(e.x, e.y, size * 0.6, 0, Math.PI * 2); ctx.fill();
    }
    
    if (e.type === 'fire_pillar') {
      // Erupting fire column
      const height = (e.size || 120) * (1 - prog * 0.3);
      const width = 40 + 20 * Math.sin(prog * Math.PI);
      // Pillar gradient
      const grad = ctx.createLinearGradient(e.x, e.y, e.x, e.y - height);
      grad.addColorStop(0, '#ff6b35');
      grad.addColorStop(0.5, '#fbbf24');
      grad.addColorStop(1, '#fff8');
      ctx.fillStyle = grad;
      ctx.beginPath();
      ctx.moveTo(e.x - width/2, e.y);
      ctx.quadraticCurveTo(e.x - width/3, e.y - height/2, e.x - 5, e.y - height);
      ctx.quadraticCurveTo(e.x + width/3, e.y - height/2, e.x + width/2, e.y);
      ctx.fill();
      // Base glow
      ctx.fillStyle = '#ff6b3580';
      ctx.beginPath(); ctx.ellipse(e.x, e.y, width, 15, 0, 0, Math.PI * 2); ctx.fill();
    }
    
    if (e.type === 'meteor_charge') {
      // Charging meteor - swirling fire
      const size = (e.size || 150) * (0.3 + prog * 0.7);
      for (let i = 0; i < 8; i++) {
        const angle = (i / 8) * Math.PI * 2 + prog * Math.PI * 4;
        const dist = size * 0.6 * (1 - prog * 0.5);
        ctx.fillStyle = i % 2 === 0 ? '#ff6b35' : '#fbbf24';
        ctx.beginPath();
        ctx.arc(e.x + Math.cos(angle) * dist, e.y + Math.sin(angle) * dist, 15 * (1 - prog * 0.5), 0, Math.PI * 2);
        ctx.fill();
      }
      // Center core
      const coreGrad = ctx.createRadialGradient(e.x, e.y, 0, e.x, e.y, size * 0.4);
      coreGrad.addColorStop(0, '#fff');
      coreGrad.addColorStop(0.5, '#fbbf24');
      coreGrad.addColorStop(1, '#ff6b3580');
      ctx.fillStyle = coreGrad;
      ctx.beginPath(); ctx.arc(e.x, e.y, size * 0.4, 0, Math.PI * 2); ctx.fill();
    }
    
    if (e.type === 'meteor_impact') {
      // Huge fire explosion
      const size = (e.size || 350) * prog;
      // Multiple explosion rings
      for (let ring = 0; ring < 3; ring++) {
        const ringSize = size * (0.4 + ring * 0.3) * (1 - prog * 0.3);
        const ringAlpha = (1 - prog) * (1 - ring * 0.25);
        ctx.globalAlpha = ringAlpha;
        const grad = ctx.createRadialGradient(e.x, e.y, 0, e.x, e.y, ringSize);
        grad.addColorStop(0, ring === 0 ? '#fff' : '#fbbf24');
        grad.addColorStop(0.4, '#ff6b35');
        grad.addColorStop(1, 'transparent');
        ctx.fillStyle = grad;
        ctx.beginPath(); ctx.arc(e.x, e.y, ringSize, 0, Math.PI * 2); ctx.fill();
      }
      ctx.globalAlpha = 1 - prog;
    }
    
    if (e.type === 'fire_shockwave') {
      // Expanding ring of fire on ground
      const size = (e.size || 500) * prog;
      ctx.strokeStyle = '#ff6b35';
      ctx.lineWidth = 20 * (1 - prog);
      ctx.beginPath(); ctx.ellipse(e.x, e.y, size, size * 0.3, 0, 0, Math.PI * 2); ctx.stroke();
      ctx.strokeStyle = '#fbbf24';
      ctx.lineWidth = 10 * (1 - prog);
      ctx.beginPath(); ctx.ellipse(e.x, e.y, size * 0.8, size * 0.24, 0, 0, Math.PI * 2); ctx.stroke();
    }
    
    if (e.type === 'inferno_spin') {
      // Spinning fire wheel
      for (let i = 0; i < 8; i++) {
        const angle = (i / 8) * Math.PI * 2 + prog * Math.PI * 6;
        const dist = (e.size || 150) * (0.3 + prog * 0.7);
        const flameSize = 25 * (1 - prog * 0.4);
        // Flame tongue shape
        ctx.save();
        ctx.translate(e.x + Math.cos(angle) * dist, e.y + Math.sin(angle) * dist * 0.5);
        ctx.rotate(angle + Math.PI/2);
        const flameGrad = ctx.createLinearGradient(0, -flameSize, 0, flameSize);
        flameGrad.addColorStop(0, '#fff');
        flameGrad.addColorStop(0.3, '#fbbf24');
        flameGrad.addColorStop(1, '#ff6b3500');
        ctx.fillStyle = flameGrad;
        ctx.beginPath();
        ctx.moveTo(-flameSize/2, flameSize);
        ctx.quadraticCurveTo(0, 0, flameSize/2, flameSize);
        ctx.quadraticCurveTo(0, -flameSize, -flameSize/2, flameSize);
        ctx.fill();
        ctx.restore();
      }
    }
    
    // === CRYSTAL CLASS EFFECTS (Purple/Arcane) ===
    if (e.type === 'crystal_slash') {
      // Crystalline arc with shards
      const facing = e.facing || 1;
      const size = (e.size || 70) * (0.5 + prog * 0.5);
      ctx.save();
      ctx.translate(e.x, e.y);
      ctx.scale(facing, 1);
      // Main arc
      ctx.strokeStyle = '#c4b5fd';
      ctx.lineWidth = 6 * (1 - prog);
      ctx.shadowColor = '#a78bfa';
      ctx.shadowBlur = 15;
      ctx.beginPath();
      ctx.arc(0, 0, size, -1, 1);
      ctx.stroke();
      // Crystal shards along arc
      for (let i = 0; i < 5; i++) {
        const shardAngle = -0.8 + i * 0.4;
        const sx = Math.cos(shardAngle) * size;
        const sy = Math.sin(shardAngle) * size;
        ctx.fillStyle = '#a78bfa';
        ctx.beginPath();
        ctx.moveTo(sx, sy - 8);
        ctx.lineTo(sx + 4, sy);
        ctx.lineTo(sx, sy + 8);
        ctx.lineTo(sx - 4, sy);
        ctx.closePath();
        ctx.fill();
      }
      ctx.shadowBlur = 0;
      ctx.restore();
    }
    
    if (e.type === 'crystal_burst') {
      // Shard explosion outward
      for (let i = 0; i < 6; i++) {
        const angle = (i / 6) * Math.PI * 2;
        const dist = (e.size || 35) * prog * 2;
        ctx.fillStyle = i % 2 === 0 ? '#a78bfa' : '#c4b5fd';
        ctx.save();
        ctx.translate(e.x + Math.cos(angle) * dist, e.y + Math.sin(angle) * dist);
        ctx.rotate(angle);
        ctx.beginPath();
        ctx.moveTo(0, -6);
        ctx.lineTo(12, 0);
        ctx.lineTo(0, 6);
        ctx.lineTo(-4, 0);
        ctx.closePath();
        ctx.fill();
        ctx.restore();
      }
    }
    
    if (e.type === 'crystal_rain') {
      // Falling crystal from sky
      const fallY = e.y + (e.targetY - e.y) * prog;
      ctx.fillStyle = '#a78bfa';
      ctx.shadowColor = '#c4b5fd';
      ctx.shadowBlur = 10;
      ctx.save();
      ctx.translate(e.x, fallY);
      ctx.rotate(prog * Math.PI);
      ctx.beginPath();
      ctx.moveTo(0, -20);
      ctx.lineTo(8, 0);
      ctx.lineTo(0, 20);
      ctx.lineTo(-8, 0);
      ctx.closePath();
      ctx.fill();
      ctx.restore();
      ctx.shadowBlur = 0;
      // Trail
      ctx.strokeStyle = '#a78bfa60';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(e.x, e.y);
      ctx.lineTo(e.x, fallY);
      ctx.stroke();
    }
    
    if (e.type === 'crystal_impact') {
      // Ground impact - radiating crystals
      const size = (e.size || 60) * prog;
      for (let i = 0; i < 5; i++) {
        const angle = -Math.PI + (i / 4) * Math.PI;
        const height = 30 + i * 10;
        ctx.fillStyle = i % 2 === 0 ? '#a78bfa' : '#c4b5fd';
        ctx.save();
        ctx.translate(e.x + Math.cos(angle) * size * 0.5, e.y);
        ctx.beginPath();
        ctx.moveTo(-5, 0);
        ctx.lineTo(0, -height * (1 - prog * 0.3));
        ctx.lineTo(5, 0);
        ctx.closePath();
        ctx.fill();
        ctx.restore();
      }
    }
    
    if (e.type === 'arcane_charge') {
      // Purple energy gathering - orbiting runes
      const size = (e.size || 180) * (1 - prog * 0.5);
      // Outer ring
      ctx.strokeStyle = '#a78bfa';
      ctx.lineWidth = 3;
      ctx.beginPath(); ctx.arc(e.x, e.y, size * 0.8, 0, Math.PI * 2); ctx.stroke();
      // Orbiting symbols
      for (let i = 0; i < 6; i++) {
        const angle = (i / 6) * Math.PI * 2 - prog * Math.PI * 3;
        const ox = e.x + Math.cos(angle) * size * 0.6;
        const oy = e.y + Math.sin(angle) * size * 0.6;
        ctx.fillStyle = '#c4b5fd';
        ctx.font = 'bold 16px sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText('‚óá', ox, oy + 5);
      }
      // Center glow
      const coreGrad = ctx.createRadialGradient(e.x, e.y, 0, e.x, e.y, size * 0.3);
      coreGrad.addColorStop(0, '#fff');
      coreGrad.addColorStop(0.5, '#c4b5fd');
      coreGrad.addColorStop(1, 'transparent');
      ctx.fillStyle = coreGrad;
      ctx.beginPath(); ctx.arc(e.x, e.y, size * 0.3, 0, Math.PI * 2); ctx.fill();
    }
    
    if (e.type === 'crystal_prison') {
      // Encasing crystal walls
      const size = (e.size || 200) * (0.5 + prog * 0.5);
      // Crystal pillars forming around target
      for (let i = 0; i < 8; i++) {
        const angle = (i / 8) * Math.PI * 2;
        const px = e.x + Math.cos(angle) * size * 0.4;
        const py = e.y + 40;
        const height = 120 * prog;
        ctx.fillStyle = i % 2 === 0 ? '#a78bfa90' : '#c4b5fd90';
        ctx.beginPath();
        ctx.moveTo(px - 10, py);
        ctx.lineTo(px - 5, py - height);
        ctx.lineTo(px + 5, py - height);
        ctx.lineTo(px + 10, py);
        ctx.closePath();
        ctx.fill();
      }
      // Connecting lines
      ctx.strokeStyle = '#a78bfa40';
      ctx.lineWidth = 2;
      for (let i = 0; i < 8; i++) {
        const angle1 = (i / 8) * Math.PI * 2;
        const angle2 = ((i + 1) / 8) * Math.PI * 2;
        ctx.beginPath();
        ctx.moveTo(e.x + Math.cos(angle1) * size * 0.4, e.y + 40 - 120 * prog);
        ctx.lineTo(e.x + Math.cos(angle2) * size * 0.4, e.y + 40 - 120 * prog);
        ctx.stroke();
      }
    }
    
    if (e.type === 'crystal_explosion') {
      // Shattering prison - shards flying
      const size = (e.size || 400) * prog;
      // Flash
      if (prog < 0.2) {
        ctx.fillStyle = `rgba(255,255,255,${(0.2 - prog) * 5})`;
        ctx.fillRect(0, 0, 1200, 700);
      }
      // Flying shards
      for (let i = 0; i < 16; i++) {
        const angle = (i / 16) * Math.PI * 2;
        const dist = size * (0.3 + prog * 0.7);
        ctx.fillStyle = i % 3 === 0 ? '#a78bfa' : i % 3 === 1 ? '#c4b5fd' : '#fff';
        ctx.save();
        ctx.translate(e.x + Math.cos(angle) * dist, e.y + Math.sin(angle) * dist * 0.6);
        ctx.rotate(angle + prog * Math.PI * 2);
        ctx.beginPath();
        ctx.moveTo(0, -12);
        ctx.lineTo(6, 0);
        ctx.lineTo(0, 12);
        ctx.lineTo(-6, 0);
        ctx.closePath();
        ctx.fill();
        ctx.restore();
      }
    }
    
    // === SHADOW CLASS EFFECTS (Green/Stealth) ===
    if (e.type === 'shadow_strike') {
      // Quick slash mark
      const facing = e.facing || 1;
      ctx.save();
      ctx.translate(e.x, e.y);
      ctx.scale(facing, 1);
      ctx.strokeStyle = e.color;
      ctx.lineWidth = 4 * (1 - prog);
      ctx.lineCap = 'round';
      ctx.shadowColor = e.color;
      ctx.shadowBlur = 8;
      ctx.beginPath();
      ctx.moveTo(-25, -15);
      ctx.lineTo(25, 15);
      ctx.stroke();
      ctx.shadowBlur = 0;
      ctx.restore();
    }
    
    if (e.type === 'shadow_throw') {
      // Kunai launch effect
      const facing = e.facing || 1;
      // Blur trail
      for (let i = 0; i < 3; i++) {
        ctx.fillStyle = e.color + Math.floor((1 - i * 0.3) * 100).toString(16).padStart(2, '0');
        ctx.save();
        ctx.translate(e.x - facing * i * 20, e.y);
        ctx.scale(facing, 1);
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(20, -5);
        ctx.lineTo(20, 5);
        ctx.closePath();
        ctx.fill();
        ctx.restore();
      }
    }
    
    if (e.type === 'shadow_trail') {
      // Long dash trail
      const facing = e.facing || 1;
      const length = (e.length || 400) * prog;
      const grad = ctx.createLinearGradient(e.x, e.y, e.x + facing * length, e.y);
      grad.addColorStop(0, e.color + '00');
      grad.addColorStop(0.5, e.color + '80');
      grad.addColorStop(1, e.color + '00');
      ctx.fillStyle = grad;
      ctx.fillRect(e.x, e.y - 30, facing * length, 60);
    }
    
    if (e.type === 'shadow_afterimage') {
      // Fading ghost silhouette
      ctx.globalAlpha = (e.alpha || 1) * (1 - prog);
      ctx.fillStyle = e.color;
      // Simple humanoid shape
      ctx.beginPath();
      ctx.ellipse(e.x, e.y - 20, 15, 25, 0, 0, Math.PI * 2); // body
      ctx.fill();
      ctx.beginPath();
      ctx.arc(e.x, e.y - 55, 12, 0, Math.PI * 2); // head
      ctx.fill();
    }
    
    if (e.type === 'shadow_mark') {
      // Death mark on target
      const size = (e.size || 100) * (0.5 + prog * 0.5);
      ctx.strokeStyle = e.color;
      ctx.lineWidth = 3 * (1 - prog);
      ctx.shadowColor = e.color;
      ctx.shadowBlur = 15;
      // X mark
      ctx.beginPath();
      ctx.moveTo(e.x - size/2, e.y - size/2);
      ctx.lineTo(e.x + size/2, e.y + size/2);
      ctx.moveTo(e.x + size/2, e.y - size/2);
      ctx.lineTo(e.x - size/2, e.y + size/2);
      ctx.stroke();
      // Circle
      ctx.beginPath();
      ctx.arc(e.x, e.y, size * 0.6, 0, Math.PI * 2);
      ctx.stroke();
      ctx.shadowBlur = 0;
    }
    
    if (e.type === 'shadow_vanish') {
      // Disappearing smoke puff
      const size = (e.size || 100) * (0.5 + prog);
      for (let i = 0; i < 6; i++) {
        const angle = (i / 6) * Math.PI * 2;
        const dist = size * 0.5 * prog;
        const puffSize = 20 * (1 - prog * 0.5);
        ctx.fillStyle = `rgba(52, 211, 153, ${0.4 * (1 - prog)})`;
        ctx.beginPath();
        ctx.arc(e.x + Math.cos(angle) * dist, e.y + Math.sin(angle) * dist, puffSize, 0, Math.PI * 2);
        ctx.fill();
      }
    }
    
    if (e.type === 'phantom_strike') {
      // Incoming strike line
      const dx = e.targetX - e.x;
      const dy = e.targetY - e.y;
      const len = Math.sqrt(dx * dx + dy * dy);
      const currentLen = len * prog;
      ctx.strokeStyle = e.color;
      ctx.lineWidth = 3 * (1 - prog);
      ctx.shadowColor = e.color;
      ctx.shadowBlur = 10;
      ctx.beginPath();
      ctx.moveTo(e.x, e.y);
      ctx.lineTo(e.x + (dx / len) * currentLen, e.y + (dy / len) * currentLen);
      ctx.stroke();
      ctx.shadowBlur = 0;
    }
    
    if (e.type === 'shadow_slash') {
      // Blade arc at angle
      const size = (e.size || 80) * prog;
      const angle = e.angle || 0;
      ctx.strokeStyle = e.color;
      ctx.lineWidth = 5 * (1 - prog);
      ctx.shadowColor = e.color;
      ctx.shadowBlur = 10;
      ctx.beginPath();
      ctx.arc(e.x, e.y, size, angle - 0.8, angle + 0.8);
      ctx.stroke();
      ctx.shadowBlur = 0;
    }
    
    if (e.type === 'death_mark') {
      // Final mark - dramatic symbol
      const size = (e.size || 250) * (0.3 + prog * 0.7);
      // Outer ring
      ctx.strokeStyle = e.color;
      ctx.lineWidth = 4 * (1 - prog);
      ctx.shadowColor = e.color;
      ctx.shadowBlur = 20;
      ctx.beginPath();
      ctx.arc(e.x, e.y, size * 0.8, 0, Math.PI * 2);
      ctx.stroke();
      // Inner pattern
      for (let i = 0; i < 6; i++) {
        const angle = (i / 6) * Math.PI * 2;
        ctx.beginPath();
        ctx.moveTo(e.x, e.y);
        ctx.lineTo(e.x + Math.cos(angle) * size * 0.7, e.y + Math.sin(angle) * size * 0.7);
        ctx.stroke();
      }
      // Center
      ctx.fillStyle = e.color;
      ctx.beginPath();
      ctx.arc(e.x, e.y, 15 * (1 - prog), 0, Math.PI * 2);
      ctx.fill();
      ctx.shadowBlur = 0;
    }
    
    // === CINEMATIC PHASE TRANSITION EFFECTS ===
    if (e.type === 'phase_energy') {
      // Orbiting energy particles during phase change
      const angle = (e.angle || 0) + prog * Math.PI * 4;
      const radius = 80 + prog * 60;
      const px = e.x + Math.cos(angle) * radius * (1 - prog);
      const py = e.y + Math.sin(angle) * radius * (1 - prog);
      const size = (e.size || 40) * (1 - prog * 0.5);
      
      ctx.shadowColor = e.color;
      ctx.shadowBlur = 30;
      const grad = ctx.createRadialGradient(px, py, 0, px, py, size);
      grad.addColorStop(0, '#fff');
      grad.addColorStop(0.3, e.color);
      grad.addColorStop(1, 'transparent');
      ctx.fillStyle = grad;
      ctx.beginPath();
      ctx.arc(px, py, size, 0, Math.PI * 2);
      ctx.fill();
      ctx.shadowBlur = 0;
    }
    
    if (e.type === 'phase_burst') {
      // Simplified phase burst - just expanding rings
      const size = (e.size || 200) * (0.2 + prog * 0.8);
      
      // Single expanding ring
      ctx.strokeStyle = e.color;
      ctx.lineWidth = Math.max(1, 6 * (1 - prog));
      ctx.globalAlpha = (1 - prog) * 0.8;
      ctx.beginPath();
      ctx.arc(e.x, e.y, size, 0, Math.PI * 2);
      ctx.stroke();
      ctx.globalAlpha = 1;
      
      // Simple central glow
      if (prog < 0.4) {
        const glowSize = size * 0.4 * (1 - prog * 2.5);
        ctx.fillStyle = '#fff';
        ctx.beginPath();
        ctx.arc(e.x, e.y, Math.max(5, glowSize), 0, Math.PI * 2);
        ctx.fill();
      }
    }
    
    // === BOSS EFFECTS (preserved) ===
    if (e.type === 'void_slash' || e.type === 'ice_slash') {
      const facing = e.facing || 1;
      const size = Math.max(1, (e.size || 1) * 120 * prog);
      ctx.strokeStyle = e.color;
      ctx.lineWidth = Math.max(1, 12 * (1 - prog));
      ctx.lineCap = 'round';
      ctx.beginPath();
      ctx.arc(e.x, e.y, size, facing === 1 ? -1.2 : Math.PI - 1.2, facing === 1 ? 1.2 : Math.PI + 1.2);
      ctx.stroke();
    }
    
    if (e.type === 'void_slam') {
      // Ground slam shockwave
      const size = (e.size || 150) * prog;
      ctx.strokeStyle = e.color;
      ctx.lineWidth = Math.max(2, 15 * (1 - prog));
      ctx.beginPath();
      ctx.ellipse(e.x, e.y, size, size * 0.3, 0, 0, Math.PI * 2);
      ctx.stroke();
      // Inner ring
      ctx.strokeStyle = '#fff';
      ctx.lineWidth = Math.max(1, 8 * (1 - prog));
      ctx.beginPath();
      ctx.ellipse(e.x, e.y, size * 0.5, size * 0.15, 0, 0, Math.PI * 2);
      ctx.stroke();
    }
    
    if (e.type === 'void_charge' || e.type === 'frost_charge') {
      // Charging energy
      const size = (e.size || 50) * (1 - prog * 0.5);
      ctx.fillStyle = e.color;
      ctx.shadowColor = e.color;
      ctx.shadowBlur = 20;
      ctx.beginPath();
      ctx.arc(e.x, e.y, size, 0, Math.PI * 2);
      ctx.fill();
      ctx.shadowBlur = 0;
    }
    
    if (e.type === 'item_collect' || e.type === 'weapon_collect') {
      // Sparkly pickup effect
      const size = (e.size || 60) * prog;
      ctx.strokeStyle = e.color;
      ctx.lineWidth = Math.max(1, 4 * (1 - prog));
      ctx.shadowColor = e.color;
      ctx.shadowBlur = 15;
      // Expanding ring
      ctx.beginPath();
      ctx.arc(e.x, e.y, size, 0, Math.PI * 2);
      ctx.stroke();
      // Sparkles
      for (let i = 0; i < 6; i++) {
        const angle = (i / 6) * Math.PI * 2 + prog * Math.PI;
        const dist = size * 0.8;
        const sx = e.x + Math.cos(angle) * dist;
        const sy = e.y + Math.sin(angle) * dist;
        ctx.fillStyle = e.color;
        ctx.beginPath();
        ctx.arc(sx, sy, 4 * (1 - prog), 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.shadowBlur = 0;
    }
    
    if (e.type === 'land') {
      // Landing dust cloud
      const size = (e.size || 60) * prog;
      ctx.fillStyle = e.color + '60';
      ctx.beginPath();
      ctx.ellipse(e.x, e.y, size, size * 0.3, 0, 0, Math.PI * 2);
      ctx.fill();
    }
    
    if (e.type === 'tail_sweep') {
      const size = Math.max(1, (e.size || 200) * prog);
      ctx.strokeStyle = e.color;
      ctx.lineWidth = Math.max(1, 15 * (1 - prog));
      ctx.beginPath();
      ctx.ellipse(e.x, e.y, size, Math.max(1, size * 0.3), 0, 0, Math.PI * 2);
      ctx.stroke();
    }
    
    if (e.type === 'lightning') {
      ctx.strokeStyle = e.color;
      ctx.lineWidth = Math.max(1, 7 * (1 - prog));
      ctx.beginPath();
      ctx.moveTo(e.x, 0);
      for (let y = 0; y < CFG.GROUND_Y; y += 42) {
        ctx.lineTo(e.x + (Math.random() - 0.5) * 52, y);
      }
      ctx.stroke();
      const r = Math.max(1, 42 * (1 - prog));
      ctx.fillStyle = '#fff';
      ctx.beginPath(); ctx.arc(e.x, CFG.GROUND_Y - 62, r, 0, Math.PI * 2); ctx.fill();
    }
    
    if (e.type === 'dash' || e.type === 'shadow_dash') {
      for (let i = 0; i < 7; i++) {
        const r = Math.max(1, 21 * (1 - prog));
        ctx.fillStyle = e.color + Math.floor((1 - i / 7) * 120).toString(16).padStart(2, '0');
        ctx.beginPath();
        ctx.arc(e.x + i * 26 * (e.facing || 1) * -1 * prog, e.y, r, 0, Math.PI * 2);
        ctx.fill();
      }
    }
    
    if (e.type === 'eruption' || e.type === 'ice_pillar') {
      const height = Math.max(1, 150 * (1 - prog));
      ctx.fillStyle = e.color;
      ctx.beginPath();
      ctx.moveTo(e.x - 30, CFG.GROUND_Y);
      ctx.lineTo(e.x - 15, CFG.GROUND_Y - height);
      ctx.lineTo(e.x + 15, CFG.GROUND_Y - height);
      ctx.lineTo(e.x + 30, CFG.GROUND_Y);
      ctx.fill();
    }
    
    if (e.type === 'singularity' || e.type === 'absolute_zero') {
      const size = Math.max(1, (e.size || 200) * (0.5 + prog * 0.5));
      const grad = ctx.createRadialGradient(e.x, e.y, 0, e.x, e.y, size);
      grad.addColorStop(0, '#fff');
      grad.addColorStop(0.3, e.color);
      grad.addColorStop(1, 'transparent');
      ctx.fillStyle = grad;
      ctx.beginPath(); ctx.arc(e.x, e.y, size, 0, Math.PI * 2); ctx.fill();
    }
    
    // === NEW COMBAT EFFECTS ===
    
    // Launcher attack - upward slash arc
    if (e.type === 'launcher') {
      const size = (e.size || 70) * prog;
      const facing = e.facing || 1;
      ctx.strokeStyle = e.color;
      ctx.lineWidth = 8 * (1 - prog);
      ctx.lineCap = 'round';
      ctx.shadowColor = e.color;
      ctx.shadowBlur = 15;
      ctx.beginPath();
      // Upward arc
      ctx.arc(e.x, e.y + 20, size, 
        facing === 1 ? -Math.PI * 0.8 : Math.PI * 0.2,
        facing === 1 ? -Math.PI * 0.2 : Math.PI * 0.8
      );
      ctx.stroke();
      ctx.shadowBlur = 0;
    }
    
    // Sweep attack - low horizontal arc
    if (e.type === 'sweep') {
      const size = (e.size || 100) * prog;
      const facing = e.facing || 1;
      ctx.strokeStyle = e.color;
      ctx.lineWidth = 6 * (1 - prog);
      ctx.lineCap = 'round';
      ctx.shadowColor = e.color;
      ctx.shadowBlur = 12;
      ctx.beginPath();
      // Low sweep arc
      ctx.ellipse(e.x + facing * 30, e.y, size, size * 0.3, 0, 
        facing === 1 ? Math.PI * 0.6 : -Math.PI * 0.4,
        facing === 1 ? Math.PI * 1.4 : Math.PI * 0.4
      );
      ctx.stroke();
      ctx.shadowBlur = 0;
    }
    
    // Heavy hit - big impact explosion
    if (e.type === 'heavy_hit') {
      const size = (e.size || 120) * (0.3 + prog * 0.7);
      // Outer ring
      ctx.strokeStyle = e.color;
      ctx.lineWidth = 10 * (1 - prog);
      ctx.shadowColor = e.color;
      ctx.shadowBlur = 25;
      ctx.beginPath();
      ctx.arc(e.x, e.y, size, 0, Math.PI * 2);
      ctx.stroke();
      // Inner flash
      const innerSize = size * 0.5 * (1 - prog);
      ctx.fillStyle = '#fff';
      ctx.beginPath();
      ctx.arc(e.x, e.y, Math.max(5, innerSize), 0, Math.PI * 2);
      ctx.fill();
      ctx.shadowBlur = 0;
    }
    
    // Impact lines - anime style
    if (e.type === 'impact_line') {
      const len = 60 * (1 - prog);
      const angle = e.angle || 0;
      ctx.strokeStyle = e.color || '#fff';
      ctx.lineWidth = 4 * (1 - prog);
      ctx.lineCap = 'round';
      ctx.beginPath();
      ctx.moveTo(e.x, e.y);
      ctx.lineTo(e.x + Math.cos(angle) * len, e.y + Math.sin(angle) * len);
      ctx.stroke();
    }
    
    // Ground pound shockwave
    if (e.type === 'groundpound') {
      const size = (e.size || 200) * prog;
      ctx.strokeStyle = e.color;
      ctx.lineWidth = 12 * (1 - prog);
      ctx.shadowColor = e.color;
      ctx.shadowBlur = 20;
      ctx.beginPath();
      ctx.ellipse(e.x, e.y, size, size * 0.25, 0, 0, Math.PI * 2);
      ctx.stroke();
      // Ground cracks
      for (let i = 0; i < 5; i++) {
        const angle = (i / 5) * Math.PI + Math.PI;
        const dist = size * 0.8;
        ctx.strokeStyle = '#888';
        ctx.lineWidth = 3 * (1 - prog);
        ctx.beginPath();
        ctx.moveTo(e.x, e.y);
        ctx.lineTo(e.x + Math.cos(angle) * dist, e.y + Math.sin(angle) * dist * 0.3);
        ctx.stroke();
      }
      ctx.shadowBlur = 0;
    }
    
    // Wall jump burst
    if (e.type === 'walljump') {
      for (let i = 0; i < 5; i++) {
        const angle = -Math.PI / 2 + (i - 2) * 0.3;
        const dist = 30 + prog * 40;
        const size = 8 * (1 - prog);
        ctx.fillStyle = e.color;
        ctx.globalAlpha = 1 - prog;
        ctx.beginPath();
        ctx.arc(e.x + Math.cos(angle) * dist, e.y + Math.sin(angle) * dist, size, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.globalAlpha = 1;
    }
    
    // Double jump burst
    if (e.type === 'doublejump') {
      const size = 40 * prog;
      ctx.strokeStyle = e.color;
      ctx.lineWidth = 3 * (1 - prog);
      ctx.beginPath();
      ctx.arc(e.x, e.y, size, 0, Math.PI * 2);
      ctx.stroke();
      // Inner ring
      ctx.beginPath();
      ctx.arc(e.x, e.y, size * 0.6, 0, Math.PI * 2);
      ctx.stroke();
    }
    
    // Roll dust effect
    if (e.type === 'roll') {
      for (let i = 0; i < 4; i++) {
        const offset = (i - 1.5) * 25 * prog;
        const size = 15 * (1 - prog * 0.5);
        ctx.fillStyle = '#888';
        ctx.globalAlpha = (1 - prog) * 0.6;
        ctx.beginPath();
        ctx.arc(e.x + offset, e.y - 10, size, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.globalAlpha = 1;
    }
    
    // Afterimage for dash motion blur
    if (e.type === 'afterimage') {
      ctx.fillStyle = e.color;
      ctx.globalAlpha = (e.alpha || 0.3) * (1 - prog);
      ctx.beginPath();
      ctx.ellipse(e.x, e.y - 60, 25, 40, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.globalAlpha = 1;
    }
    
    // Parry flash
    if (e.type === 'parry_flash') {
      const size = (e.size || 80) * (0.5 + prog * 0.5);
      ctx.strokeStyle = '#fff';
      ctx.lineWidth = 5 * (1 - prog);
      ctx.shadowColor = '#fff';
      ctx.shadowBlur = 20;
      // Star burst
      for (let i = 0; i < 8; i++) {
        const angle = (i / 8) * Math.PI * 2;
        ctx.beginPath();
        ctx.moveTo(e.x, e.y);
        ctx.lineTo(e.x + Math.cos(angle) * size, e.y + Math.sin(angle) * size);
        ctx.stroke();
      }
      ctx.shadowBlur = 0;
    }
    
    // Charge visual
    if (e.type === 'charge') {
      const size = e.size || 30;
      ctx.strokeStyle = e.color;
      ctx.lineWidth = 2;
      ctx.shadowColor = e.color;
      ctx.shadowBlur = 15;
      // Spinning particles
      for (let i = 0; i < 4; i++) {
        const angle = (i / 4) * Math.PI * 2 + prog * Math.PI * 4;
        const dist = size * (1 - prog * 0.3);
        ctx.beginPath();
        ctx.arc(e.x + Math.cos(angle) * dist, e.y + Math.sin(angle) * dist, 5, 0, Math.PI * 2);
        ctx.stroke();
      }
      ctx.shadowBlur = 0;
    }
    
    // Shield effect for invuln
    if (e.type === 'shield') {
      const size = 50 * (1 + prog * 0.3);
      ctx.strokeStyle = e.color;
      ctx.lineWidth = 3 * (1 - prog);
      ctx.globalAlpha = (1 - prog) * 0.7;
      ctx.beginPath();
      ctx.arc(e.x, e.y, size, 0, Math.PI * 2);
      ctx.stroke();
      // Hexagon pattern
      for (let i = 0; i < 6; i++) {
        const angle = (i / 6) * Math.PI * 2;
        const nextAngle = ((i + 1) / 6) * Math.PI * 2;
        ctx.beginPath();
        ctx.moveTo(e.x + Math.cos(angle) * size, e.y + Math.sin(angle) * size);
        ctx.lineTo(e.x + Math.cos(nextAngle) * size, e.y + Math.sin(nextAngle) * size);
        ctx.stroke();
      }
      ctx.globalAlpha = 1;
    }
    
    // Telegraph warning effect
    if (e.type === 'telegraph') {
      const size = (e.size || 40) * (1 - prog * 0.3);
      // Warning indicator above boss
      ctx.strokeStyle = e.color;
      ctx.lineWidth = 4 * (1 - prog * 0.5);
      ctx.shadowColor = e.color;
      ctx.shadowBlur = 15;
      
      // Exclamation mark style warning
      ctx.fillStyle = e.color;
      ctx.font = `bold ${Math.round(size)}px sans-serif`;
      ctx.textAlign = 'center';
      ctx.fillText('!', e.x, e.y);
      
      // Pulsing circle
      ctx.globalAlpha = 0.5 + Math.sin(prog * Math.PI * 4) * 0.3;
      ctx.beginPath();
      ctx.arc(e.x, e.y + 10, size * 0.8, 0, Math.PI * 2);
      ctx.stroke();
      ctx.globalAlpha = 1;
      ctx.shadowBlur = 0;
    }
    
    // === FALLBACK FOR UNKNOWN EFFECTS ===
    const knownEffects = ['hit', 'break', 'enrage', 'fire_punch', 'fire_launch', 'fire_pillar', 
      'inferno_spin', 'crystal_slash', 'crystal_burst', 'crystal_rain', 'shadow_strike', 
      'shadow_trail', 'shadow_afterimage', 'shadow_mark', 'meteor_charge', 'meteor_impact',
      'arcane_charge', 'crystal_prison', 'crystal_explosion', 'shadow_vanish', 'death_mark',
      'phase_energy', 'phase_burst', 'void_slash', 'ice_slash', 'void_slam', 'void_charge',
      'frost_charge', 'item_collect', 'weapon_collect', 'land', 'tail_sweep', 'lightning',
      'dash', 'shadow_dash', 'singularity', 'absolute_zero', 'spark', 'fire',
      'launcher', 'sweep', 'heavy_hit', 'impact_line', 'groundpound', 'walljump',
      'doublejump', 'roll', 'afterimage', 'parry_flash', 'charge', 'shield', 'telegraph'];
    
    if (!knownEffects.includes(e.type)) {
      // Simple fallback render - small fading circle
      const size = Math.max(5, (e.size || 30) * (1 - prog * 0.5));
      ctx.fillStyle = e.color || '#fff';
      ctx.globalAlpha = (1 - prog) * 0.5;
      ctx.beginPath();
      ctx.arc(e.x, e.y, size, 0, Math.PI * 2);
      ctx.fill();
    }
    
    } catch (err) {
      // Silently handle effect rendering errors
      console.warn('Effect render error:', e.type, err);
    }
    
    // CRITICAL: Restore canvas state after EVERY effect - in finally block to guarantee execution
    ctx.restore();
  });
  
  // Damage numbers
  game.dmgNums.forEach(dn => {
    const alpha = Math.min(1, dn.life / 38);
    const baseSize = { crit: 44, special: 40, break: 48, ult: 48, heal: 34, hurt: 36, block: 36, parry: 36, burn: 32, normal: 36 }[dn.type] || 36;
    const col = { crit: '#fbbf24', break: '#f97316', ult: '#f97316', heal: '#22c55e', hurt: '#ef4444', block: '#6366f1', parry: '#fff', burn: '#ff6b35' }[dn.type] || '#fff';
    ctx.font = `bold ${baseSize * (dn.scale || 1)}px sans-serif`;
    ctx.textAlign = 'center';
    ctx.globalAlpha = alpha;
    ctx.strokeStyle = '#000';
    ctx.lineWidth = 6;
    ctx.strokeText(dn.val, dn.x, dn.y);
    ctx.fillStyle = col;
    ctx.fillText(dn.val, dn.x, dn.y);
    ctx.globalAlpha = 1;
  });
  
  } catch (renderError) {
    console.error('Render error:', renderError);
  } finally {
    // CRITICAL: Always call screenFx.post to restore canvas state
    screenFx.post(ctx);
  }
  
  renderHUD();
  
  // Pause
  if (isPaused) {
    ctx.fillStyle = 'rgba(0,0,0,0.85)';
    ctx.fillRect(0, 0, 1200, 700);
    ctx.fillStyle = '#fff';
    ctx.font = 'bold 72px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText('PAUSED', 600, 280);
    ctx.font = '28px sans-serif';
    const isMobile = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);
    if (isMobile) {
      ctx.fillText('Tap ‚è∏Ô∏è to resume', 600, 340);
      ctx.fillText('Tap below to restart or exit:', 600, 400);
      // Draw touch buttons for restart/menu
      ctx.fillStyle = '#3b82f6';
      ctx.beginPath(); ctx.roundRect(350, 440, 200, 60, 12); ctx.fill();
      ctx.fillStyle = '#ef4444';
      ctx.beginPath(); ctx.roundRect(650, 440, 200, 60, 12); ctx.fill();
      ctx.fillStyle = '#fff';
      ctx.font = 'bold 24px sans-serif';
      ctx.fillText('RESTART', 450, 480);
      ctx.fillText('MENU', 750, 480);
    } else {
      ctx.fillText('Press ESC to resume', 600, 340);
      ctx.fillText('Press R to restart | Press M for menu', 600, 380);
      ctx.font = '18px sans-serif';
      ctx.fillStyle = '#888';
      ctx.fillText('Press F to fix stuck screen effects', 600, 420);
    }
  }
  
  // Kill cam - cinematic finish (3 seconds)
  if (killCam) {
    const progress = 1 - (killCam.timer / 180); // 0 to 1 over 3 seconds
    
    // Gradually darken
    const darkness = Math.min(0.85, progress * 1.2);
    ctx.fillStyle = `rgba(0,0,0,${darkness})`;
    ctx.fillRect(0, 0, 1200, 700);
    
    // Spotlight on boss
    const spotSize = 150 + progress * 100;
    const grad = ctx.createRadialGradient(killCam.x, killCam.y - 60, 0, killCam.x, killCam.y - 60, spotSize);
    grad.addColorStop(0, `rgba(251, 191, 36, ${0.3 - progress * 0.1})`);
    grad.addColorStop(1, 'rgba(0, 0, 0, 0)');
    ctx.fillStyle = grad;
    ctx.fillRect(0, 0, 1200, 700);
    
    // "FINISHING BLOW" text - fade in then out
    const textAlpha = progress < 0.3 ? progress / 0.3 : progress > 0.7 ? (1 - progress) / 0.3 : 1;
    ctx.globalAlpha = Math.min(1, textAlpha);
    ctx.fillStyle = '#fbbf24';
    ctx.font = 'bold 36px sans-serif';
    ctx.textAlign = 'center';
    ctx.shadowColor = '#fbbf24';
    ctx.shadowBlur = 20;
    ctx.fillText('FINISHING BLOW', killCam.x, killCam.y - 160);
    ctx.shadowBlur = 0;
    ctx.globalAlpha = 1;
  }
  
  // Victory Screen - staged reveal
  if (game.victory && !killCam) {
    // Increment timer (for staged animations)
    if (!game.victoryTimer) game.victoryTimer = 0;
    game.victoryTimer++;
    const t = game.victoryTimer;
    
    // Reset slowmo after kill cam ends
    if (t === 1) screenFx.slowmo = 1;
    
    // Fade to black (first 30 frames = 0.5 seconds)
    const fadeIn = Math.min(1, t / 30);
    ctx.fillStyle = `rgba(0,0,0,${fadeIn})`;
    ctx.fillRect(0, 0, 1200, 700);
    
    // Subtle golden radial glow
    if (t > 20) {
      const glowAlpha = Math.min(0.2, (t - 20) / 60 * 0.2);
      const grad = ctx.createRadialGradient(600, 300, 0, 600, 300, 400);
      grad.addColorStop(0, `rgba(251, 191, 36, ${glowAlpha})`);
      grad.addColorStop(1, 'rgba(0, 0, 0, 0)');
      ctx.fillStyle = grad;
      ctx.fillRect(0, 0, 1200, 700);
    }
    
    // "VICTORY" - appears at 0.5s, scales up
    if (t > 30) {
      const victoryProgress = Math.min(1, (t - 30) / 45); // 0.75s to fully appear
      const scale = 0.5 + victoryProgress * 0.5;
      const yOffset = (1 - victoryProgress) * 30;
      
      ctx.save();
      ctx.globalAlpha = victoryProgress;
      ctx.fillStyle = '#fbbf24';
      ctx.font = `bold ${Math.round(80 * scale)}px sans-serif`;
      ctx.textAlign = 'center';
      ctx.shadowColor = '#fbbf24';
      ctx.shadowBlur = 25 * victoryProgress;
      ctx.fillText('VICTORY', 600, 180 + yOffset);
      ctx.restore();
    }
    
    // Stats - staggered reveal starting at 1.5s (90 frames)
    ctx.textAlign = 'center';
    const statsStart = 90;
    const statsGap = 25; // 0.4 seconds between each
    
    // Time stat
    if (t > statsStart) {
      const alpha = Math.min(1, (t - statsStart) / 20);
      ctx.globalAlpha = alpha;
      ctx.fillStyle = '#fff';
      ctx.font = '24px sans-serif';
      ctx.fillText(`Time: ${(game.gameTime / 60).toFixed(1)}s`, 600, 270);
    }
    
    // Damage stat
    if (t > statsStart + statsGap) {
      const alpha = Math.min(1, (t - statsStart - statsGap) / 20);
      ctx.globalAlpha = alpha;
      ctx.fillText(`Total Damage: ${game.stats.dmg}`, 600, 310);
    }
    
    // Combo stat
    if (t > statsStart + statsGap * 2) {
      const alpha = Math.min(1, (t - statsStart - statsGap * 2) / 20);
      ctx.globalAlpha = alpha;
      ctx.fillText(`Max Combo: ${game.stats.combo}`, 600, 350);
    }
    
    // Grade - appears at 2.5s (150 frames) with emphasis
    const gradeStart = 150;
    if (t > gradeStart) {
      let grade = 'C', gradeColor = '#3b82f6';
      if (game.stats.damageTaken === 0) { grade = 'S+'; gradeColor = '#fbbf24'; }
      else if (game.stats.damageTaken < 50) { grade = 'S'; gradeColor = '#fbbf24'; }
      else if (game.stats.damageTaken < 100) { grade = 'A'; gradeColor = '#22c55e'; }
      else if (game.stats.damageTaken < 200) { grade = 'B'; gradeColor = '#60a5fa'; }
      
      const gradeProgress = Math.min(1, (t - gradeStart) / 30);
      const gradeScale = 0.3 + gradeProgress * 0.7 + (gradeProgress < 0.5 ? Math.sin(gradeProgress * Math.PI) * 0.2 : 0);
      
      ctx.globalAlpha = gradeProgress;
      
      // Grade circle - smaller, moved left
      ctx.beginPath();
      ctx.arc(400, 450, 45 * gradeScale, 0, Math.PI * 2);
      ctx.fillStyle = 'rgba(255,255,255,0.08)';
      ctx.fill();
      ctx.strokeStyle = gradeColor;
      ctx.lineWidth = 3;
      ctx.stroke();
      
      // Grade letter
      ctx.fillStyle = gradeColor;
      ctx.font = `bold ${Math.round(50 * gradeScale)}px sans-serif`;
      ctx.shadowColor = gradeColor;
      ctx.shadowBlur = 15 * gradeProgress;
      ctx.fillText(grade, 400, 468);
      ctx.shadowBlur = 0;
      ctx.font = '14px sans-serif';
      ctx.fillStyle = '#888';
      ctx.fillText('COMBAT', 400, 505);
      
      // Quiz stats - right side
      const quizReport = QuizSystem.getReport();
      const quizPct = quizReport.accuracy;
      const quizColor = quizPct >= 80 ? '#22c55e' : quizPct >= 60 ? '#f59e0b' : '#ef4444';
      
      ctx.beginPath();
      ctx.arc(800, 450, 45 * gradeScale, 0, Math.PI * 2);
      ctx.fillStyle = 'rgba(255,255,255,0.08)';
      ctx.fill();
      ctx.strokeStyle = quizColor;
      ctx.lineWidth = 3;
      ctx.stroke();
      
      ctx.fillStyle = quizColor;
      ctx.font = `bold ${Math.round(36 * gradeScale)}px sans-serif`;
      ctx.shadowColor = quizColor;
      ctx.shadowBlur = 15 * gradeProgress;
      ctx.fillText(quizPct + '%', 800, 460);
      ctx.shadowBlur = 0;
      ctx.font = '14px sans-serif';
      ctx.fillStyle = '#888';
      ctx.fillText('QUIZ (' + quizReport.correct + '/' + quizReport.totalQuestions + ')', 800, 505);
      ctx.fillText('Level ' + quizReport.finalLevel, 800, 522);
      
      // Save report if in session - USES BATCH SYSTEM (1 write)
      if (t === gradeStart + 1 && SES && SES.code) {
        const studentName = SES.studentName || 'Player';
        // Local display
        if (typeof addStudentReport === 'function') {
          addStudentReport(studentName, quizReport);
        }
        // Firebase batch write
        if (typeof SES.submitResults === 'function') {
          SES.submitResults(quizReport);
        }
      }
    }
    
    // Continue prompt - appears at 3.5s (210 frames), pulses
    if (t > 210) {
      const isMobile = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);
      
      if (isMobile) {
        // Draw touch buttons for mobile
        ctx.globalAlpha = 1;
        ctx.fillStyle = '#22c55e';
        ctx.beginPath(); ctx.roundRect(200, 540, 180, 55, 12); ctx.fill();
        ctx.fillStyle = '#22d3ee';
        ctx.beginPath(); ctx.roundRect(410, 540, 180, 55, 12); ctx.fill();
        ctx.fillStyle = '#6366f1';
        ctx.beginPath(); ctx.roundRect(620, 540, 180, 55, 12); ctx.fill();
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 18px sans-serif';
        ctx.fillText('PLAY AGAIN', 290, 575);
        ctx.fillText('üìö STUDY', 500, 575);
        ctx.fillText('MENU', 710, 575);
        
        // Show missed count
        if (typeof StudyMode !== 'undefined' && StudyMode.missedQuestions.length > 0) {
          ctx.fillStyle = '#fbbf24';
          ctx.font = '14px sans-serif';
          ctx.fillText(StudyMode.missedQuestions.length + ' missed', 500, 600);
        }
      } else {
        const pulseAlpha = 0.4 + Math.sin(t * 0.08) * 0.2;
        ctx.globalAlpha = pulseAlpha;
        ctx.fillStyle = '#888';
        ctx.font = '18px sans-serif';
        ctx.fillText('ENTER: Continue | S: Study Mode | M: Menu', 600, 580);
      }
    }
    
    ctx.globalAlpha = 1;
  }
  
  // Game Over - staged reveal
  if (game.gameOver) {
    // Increment timer
    if (!game.gameOverTimer) game.gameOverTimer = 0;
    game.gameOverTimer++;
    const t = game.gameOverTimer;
    
    // Reset slowmo after 1 second
    if (t === 60) screenFx.slowmo = 1;
    
    // Fade to black
    const fadeIn = Math.min(1, t / 45);
    ctx.fillStyle = `rgba(0,0,0,${fadeIn})`;
    ctx.fillRect(0, 0, 1200, 700);
    
    // Red vignette
    if (t > 30) {
      const vigAlpha = Math.min(0.15, (t - 30) / 60 * 0.15);
      const grad = ctx.createRadialGradient(600, 350, 200, 600, 350, 600);
      grad.addColorStop(0, 'rgba(0, 0, 0, 0)');
      grad.addColorStop(1, `rgba(239, 68, 68, ${vigAlpha})`);
      ctx.fillStyle = grad;
      ctx.fillRect(0, 0, 1200, 700);
    }
    
    // "DEFEATED" - appears at 0.75s
    if (t > 45) {
      const defProgress = Math.min(1, (t - 45) / 40);
      const yOffset = (1 - defProgress) * 40;
      
      ctx.globalAlpha = defProgress;
      ctx.fillStyle = '#ef4444';
      ctx.font = `bold 70px sans-serif`;
      ctx.textAlign = 'center';
      ctx.shadowColor = '#ef4444';
      ctx.shadowBlur = 20 * defProgress;
      ctx.fillText('DEFEATED', 600, 240 + yOffset);
      ctx.shadowBlur = 0;
    }
    
    // Stats - appear at 1.5s
    if (t > 90) {
      const alpha = Math.min(1, (t - 90) / 25);
      ctx.globalAlpha = alpha;
      ctx.fillStyle = '#aaa';
      ctx.font = '22px sans-serif';
      ctx.fillText(`Boss HP Remaining: ${Math.ceil(game.boss.hp)} / ${game.boss.maxHp}`, 600, 340);
    }
    
    if (t > 110) {
      const alpha = Math.min(1, (t - 110) / 25);
      ctx.globalAlpha = alpha;
      ctx.fillText(`Damage Dealt: ${game.stats.dmg}`, 600, 380);
    }
    
    // Continue prompt - appears at 2.5s
    if (t > 150) {
      const isMobile = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);
      
      if (isMobile) {
        // Draw touch buttons for mobile
        ctx.globalAlpha = 1;
        ctx.fillStyle = '#3b82f6';
        ctx.beginPath(); ctx.roundRect(350, 440, 200, 55, 12); ctx.fill();
        ctx.fillStyle = '#ef4444';
        ctx.beginPath(); ctx.roundRect(650, 440, 200, 55, 12); ctx.fill();
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 20px sans-serif';
        ctx.fillText('TRY AGAIN', 450, 475);
        ctx.fillText('MENU', 750, 475);
      } else {
        const pulseAlpha = 0.35 + Math.sin(t * 0.08) * 0.15;
        ctx.globalAlpha = pulseAlpha;
        ctx.fillStyle = '#666';
        ctx.font = '18px sans-serif';
        ctx.fillText('Press ENTER to retry  |  Press M for menu', 600, 480);
      }
    }
    
    ctx.globalAlpha = 1;
  }
  
  // Knowledge challenge overlay - shows while playing
  KnowledgeSystem.render(ctx);
  
  // Quiz overlay - renders on top of everything
  if (QuizSystem.active) {
    QuizSystem.render(ctx);
  }
  
  // Execution move cinematic
  if (typeof ExecutionSystem !== 'undefined' && ExecutionSystem.active) {
    ExecutionSystem.render(ctx);
  }
  
  // Study mode overlay
  if (typeof StudyMode !== 'undefined' && StudyMode.active) {
    StudyMode.render(ctx);
  }
  
  // Execution prompt on mobile
  if (game && game.showExecutePrompt) {
    ctx.fillStyle = 'rgba(251, 191, 36, 0.9)';
    ctx.font = 'bold 28px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText('‚ö° TAP ULTIMATE TO EXECUTE! ‚ö°', 600, 180);
  }
}

function renderHUD() {
  const p = game.player, b = game.boss;
  
  // Player HP
  ctx.fillStyle = '#111';
  ctx.beginPath(); ctx.roundRect(18, 18, 295, 40, 12); ctx.fill();
  const hpGrad = ctx.createLinearGradient(20, 0, 310, 0);
  hpGrad.addColorStop(0, p.hp > p.maxHp * 0.3 ? '#22c55e' : '#ef4444');
  hpGrad.addColorStop(1, p.hp > p.maxHp * 0.3 ? '#16a34a' : '#dc2626');
  ctx.fillStyle = hpGrad;
  ctx.beginPath(); ctx.roundRect(20, 20, Math.max(0, (p.hp / p.maxHp) * 291), 36, 10); ctx.fill();
  ctx.strokeStyle = '#fff';
  ctx.lineWidth = 2;
  ctx.beginPath(); ctx.roundRect(18, 18, 295, 40, 12); ctx.stroke();
  ctx.fillStyle = '#fff';
  ctx.font = 'bold 20px sans-serif';
  ctx.textAlign = 'left';
  ctx.fillText(`${Math.ceil(p.hp)} / ${p.maxHp}`, 36, 46);
  
  // Mana
  ctx.fillStyle = '#111';
  ctx.beginPath(); ctx.roundRect(18, 62, 220, 28, 8); ctx.fill();
  ctx.fillStyle = '#3b82f6';
  ctx.beginPath(); ctx.roundRect(20, 64, Math.max(0, (p.mana / p.maxMana) * 216), 24, 6); ctx.fill();
  ctx.strokeStyle = '#fff';
  ctx.beginPath(); ctx.roundRect(18, 62, 220, 28, 8); ctx.stroke();
  ctx.font = 'bold 15px sans-serif';
  ctx.fillText(`MANA: ${Math.ceil(p.mana)}`, 34, 82);
  
  // Ultimate
  ctx.fillStyle = '#111';
  ctx.beginPath(); ctx.roundRect(18, 94, 180, 24, 8); ctx.fill();
  ctx.fillStyle = p.ultCharge >= 100 ? '#fbbf24' : '#8b5cf6';
  ctx.beginPath(); ctx.roundRect(20, 96, Math.max(0, (p.ultCharge / 100) * 176), 20, 6); ctx.fill();
  ctx.strokeStyle = '#fff';
  ctx.beginPath(); ctx.roundRect(18, 94, 180, 24, 8); ctx.stroke();
  ctx.font = 'bold 13px sans-serif';
  ctx.fillText(p.ultCharge >= 100 ? 'ULT READY! [V]' : 'ULTIMATE', 34, 111);
  
  // Combo
  if (p.combo > 1) {
    ctx.fillStyle = p.combo >= 10 ? '#fbbf24' : p.combo >= 5 ? '#f97316' : '#fff';
    ctx.font = `bold ${30 + Math.min(p.combo / 2, 10)}px sans-serif`;
    ctx.shadowColor = p.combo >= 10 ? '#fbbf24' : '#fff';
    ctx.shadowBlur = 22;
    ctx.fillText(`${p.combo} COMBO!`, 36, 160);
    ctx.shadowBlur = 0;
    ctx.font = '16px sans-serif';
    ctx.fillStyle = '#fbbf24';
    ctx.fillText(`x${(1 + p.combo * 0.05).toFixed(2)}`, 36, 180);
  }
  
  // Status
  if (p.stagger > 0) {
    ctx.fillStyle = '#06b6d4';
    ctx.font = 'bold 20px sans-serif';
    ctx.fillText('FROZEN!', 36, 200);
  }
  if (p.slowedTimer > 0) {
    ctx.fillStyle = '#67e8f9';
    ctx.font = 'bold 16px sans-serif';
    ctx.fillText('SLOWED', 36, p.stagger > 0 ? 225 : 200);
  }
  
  // Boss HP
  ctx.fillStyle = '#111';
  ctx.beginPath(); ctx.roundRect(398, 18, 404, 46, 14); ctx.fill();
  ctx.fillStyle = 'rgba(255,255,255,0.26)';
  ctx.beginPath(); ctx.roundRect(400, 20, 400, 42, 12); ctx.fill();
  ctx.fillStyle = b.enraged ? b.data.enrageColor : b.critical > 0 ? '#fbbf24' : b.data.color;
  ctx.beginPath(); ctx.roundRect(400, 20, Math.max(0, (b.hp / b.maxHp) * 400), 42, 12); ctx.fill();
  ctx.strokeStyle = '#fff';
  ctx.lineWidth = 2;
  ctx.beginPath(); ctx.roundRect(398, 18, 404, 46, 14); ctx.stroke();
  ctx.fillStyle = '#fff';
  ctx.font = 'bold 20px sans-serif';
  ctx.textAlign = 'center';
  ctx.fillText(`${b.enraged ? 'üî• ' : ''}${b.data.name}`, 600, 38);
  ctx.font = '14px sans-serif';
  ctx.fillText(`${Math.ceil(b.hp)} / ${b.maxHp}`, 600, 56);
  
  // Boss phase
  const phase = b.data.phases[b.phase];
  ctx.fillStyle = b.data.color;
  ctx.font = '14px sans-serif';
  ctx.fillText(`${phase.name}`, 600, 82);
  
  // Posture
  ctx.fillStyle = '#111';
  ctx.beginPath(); ctx.roundRect(428, 90, 344, 18, 6); ctx.fill();
  ctx.fillStyle = b.posture > 300 ? '#fbbf24' : '#eab308';
  ctx.beginPath(); ctx.roundRect(430, 92, Math.max(0, (b.posture / 400) * 340), 14, 4); ctx.fill();
  ctx.strokeStyle = '#fff';
  ctx.beginPath(); ctx.roundRect(428, 90, 344, 18, 6); ctx.stroke();
  ctx.font = '10px sans-serif';
  ctx.fillStyle = '#fff';
  ctx.fillText('POSTURE', 600, 104);
  
  // Time & Difficulty
  ctx.textAlign = 'right';
  ctx.fillStyle = '#888';
  ctx.font = '16px sans-serif';
  const mins = Math.floor(game.gameTime / 3600);
  const secs = Math.floor((game.gameTime / 60) % 60);
  ctx.fillText(`${mins}:${secs.toString().padStart(2, '0')}`, 1180, 30);
  ctx.fillStyle = { NIGHTMARE: '#ef4444', HARD: '#f97316', EASY: '#22c55e', NORMAL: '#888' }[game.difficulty];
  ctx.fillText(game.difficulty, 1180, 52);
  
  // KNOWLEDGE PROGRESS - Required to defeat boss!
  const kProgress = KnowledgeSystem.questionsAnswered;
  const kRequired = KnowledgeSystem.requiredQuestions;
  const kComplete = kProgress >= kRequired;
  
  ctx.fillStyle = '#111';
  ctx.beginPath(); ctx.roundRect(1020, 70, 160, 40, 8); ctx.fill();
  ctx.fillStyle = kComplete ? '#22c55e' : '#06b6d4';
  ctx.beginPath(); ctx.roundRect(1022, 72, Math.max(0, (kProgress / kRequired) * 156), 36, 6); ctx.fill();
  ctx.strokeStyle = kComplete ? '#22c55e' : '#06b6d4';
  ctx.lineWidth = 2;
  ctx.beginPath(); ctx.roundRect(1020, 70, 160, 40, 8); ctx.stroke();
  ctx.fillStyle = '#fff';
  ctx.font = 'bold 14px sans-serif';
  ctx.textAlign = 'center';
  ctx.fillText(kComplete ? '‚úì DEFEAT BOSS!' : `? ${kProgress}/${kRequired}`, 1100, 95);
  
  // Controls - only show on desktop
  if (!TouchControls.isMobile) {
    ctx.textAlign = 'left';
    ctx.fillStyle = 'rgba(255,255,255,0.6)';
    ctx.font = '14px sans-serif';
    ctx.fillText('WASD: Move | SHIFT: Dash | Q: Parry | Z: Melee | X: Ranged | C: Special | V: Ultimate | ESC: Pause', 22, 682);
  }
}

// ============ MENUS ============
function renderMenu() {
  const grad = ctx.createLinearGradient(0, 0, 0, 700);
  grad.addColorStop(0, '#050510');
  grad.addColorStop(1, '#10103a');
  ctx.fillStyle = grad;
  ctx.fillRect(0, 0, 1200, 700);
  
  ctx.fillStyle = '#fff';
  for (let i = 0; i < 200; i++) {
    const twinkle = (Math.sin(frame * 0.04 + i) + 1) / 2;
    ctx.globalAlpha = twinkle * 0.7;
    ctx.beginPath();
    ctx.arc((i * 137 + frame * 0.15) % 1200, (i * 89) % 700, 0.6 + twinkle * 2, 0, Math.PI * 2);
    ctx.fill();
  }
  ctx.globalAlpha = 1;
  
  ctx.fillStyle = '#fff';
  ctx.font = 'bold 130px sans-serif';
  ctx.textAlign = 'center';
  ctx.shadowColor = '#8b5cf6';
  ctx.shadowBlur = 65;
  ctx.fillText('CIVITAS', 600, 160);
  ctx.shadowBlur = 0;
  ctx.fillStyle = '#fbbf24';
  ctx.font = 'bold 22px sans-serif';
  ctx.fillText('3 UNIQUE BOSSES EDITION', 600, 205);
  
  const btns = [{ text: 'START GAME', y: 350 }, { text: 'HOW TO PLAY', y: 420 }];
  btns.forEach(btn => {
    const hover = Math.abs(mouseY - btn.y) < 30 && mouseX > 400 && mouseX < 800;
    ctx.fillStyle = hover ? '#8b5cf6' : '#333';
    ctx.beginPath(); ctx.roundRect(400, btn.y - 30, 400, 60, 14); ctx.fill();
    ctx.strokeStyle = hover ? '#fff' : '#666';
    ctx.lineWidth = 2;
    ctx.beginPath(); ctx.roundRect(400, btn.y - 30, 400, 60, 14); ctx.stroke();
    ctx.fillStyle = '#fff';
    ctx.font = 'bold 26px sans-serif';
    ctx.fillText(btn.text, 600, btn.y + 10);
  });
  
  // Boss previews
  ctx.fillStyle = '#888';
  ctx.font = '16px sans-serif';
  ctx.fillText('VOID TITAN - Slow & Devastating  |  FLAME WYRM - Fast & Aggressive  |  FROST QUEEN - Tactical & Elegant', 600, 550);
}

function renderCharSelect() {
  ctx.fillStyle = '#0a0a20';
  ctx.fillRect(0, 0, 1200, 700);
  ctx.fillStyle = '#fff';
  ctx.font = 'bold 48px sans-serif';
  ctx.textAlign = 'center';
  ctx.fillText('SELECT YOUR SPIRIT', 600, 70);
  
  Object.entries(CLASSES).forEach(([key, cls], i) => {
    const x = 150 + i * 350, y = 150;
    const hover = mouseX > x && mouseX < x + 300 && mouseY > y && mouseY < y + 400;
    const selected = selectedClass === key;
    
    ctx.fillStyle = selected ? cls.color + '50' : hover ? cls.color + '40' : '#1a1a3a';
    ctx.beginPath(); ctx.roundRect(x, y, 300, 400, 16); ctx.fill();
    ctx.strokeStyle = selected ? '#fff' : cls.color;
    ctx.lineWidth = selected ? 5 : hover ? 4 : 2;
    ctx.beginPath(); ctx.roundRect(x, y, 300, 400, 16); ctx.stroke();
    
    // Spirit preview
    const spiritGlow = ctx.createRadialGradient(x + 150, y + 120, 0, x + 150, y + 120, 70);
    spiritGlow.addColorStop(0, cls.glow + '95');
    spiritGlow.addColorStop(1, 'transparent');
    ctx.fillStyle = spiritGlow;
    ctx.beginPath(); ctx.arc(x + 150, y + 120, 70, 0, Math.PI * 2); ctx.fill();
    ctx.fillStyle = cls.core;
    ctx.beginPath(); ctx.arc(x + 150, y + 120, 35, 0, Math.PI * 2); ctx.fill();
    ctx.fillStyle = cls.element === 'fire' ? '#ff0' : '#fff';
    ctx.beginPath();
    ctx.arc(x + 138, y + 112, 6, 0, Math.PI * 2);
    ctx.arc(x + 162, y + 112, 6, 0, Math.PI * 2);
    ctx.fill();
    
    ctx.fillStyle = cls.glow;
    ctx.font = 'bold 32px sans-serif';
    ctx.fillText(cls.name, x + 150, y + 220);
    ctx.fillStyle = 'rgba(255,255,255,0.7)';
    ctx.font = '16px sans-serif';
    ctx.fillText(cls.theme, x + 150, y + 250);
    ctx.fillStyle = '#888';
    ctx.font = '14px sans-serif';
    ctx.textAlign = 'left';
    ctx.fillText(`HP: ${cls.hp}`, x + 40, y + 290);
    ctx.fillText(`MANA: ${cls.mana}`, x + 40, y + 315);
    ctx.fillText(`SPEED: ${cls.speed}x`, x + 160, y + 290);
    ctx.fillText(`DMG: ${cls.damage}x`, x + 160, y + 315);
    ctx.textAlign = 'center';
    ctx.fillStyle = cls.color;
    ctx.font = 'bold 18px sans-serif';
    ctx.fillText(`${cls.element.toUpperCase()} ELEMENT`, x + 150, y + 370);
  });
  
  // Subject Filter (Quiz Topics)
  ctx.fillStyle = '#888';
  ctx.font = '14px sans-serif';
  ctx.fillText('FOCUS TOPICS (optional):', 600, 565);
  
  if (typeof SubjectFilter !== 'undefined') {
    SubjectFilter.standards.forEach((std, i) => {
      const sx = 280 + i * 220;
      const sy = 580;
      const hover = mouseX > sx - 100 && mouseX < sx + 100 && mouseY > sy - 15 && mouseY < sy + 15;
      const sel = SubjectFilter.isSelected(std.id);
      
      ctx.fillStyle = sel ? '#6366f1' : hover ? '#333' : '#222';
      ctx.beginPath(); ctx.roundRect(sx - 100, sy - 15, 200, 30, 6); ctx.fill();
      
      if (sel) {
        ctx.strokeStyle = '#6366f1';
        ctx.lineWidth = 2;
        ctx.beginPath(); ctx.roundRect(sx - 100, sy - 15, 200, 30, 6); ctx.stroke();
      }
      
      ctx.fillStyle = sel ? '#fff' : '#aaa';
      ctx.font = '12px sans-serif';
      ctx.fillText(std.name, sx, sy + 4);
    });
  }
  
  // Difficulty
  ctx.fillStyle = '#fff';
  ctx.font = 'bold 24px sans-serif';
  ctx.fillText('DIFFICULTY', 600, 630);
  ['EASY', 'NORMAL', 'HARD', 'NIGHTMARE'].forEach((d, i) => {
    const dx = 300 + i * 150;
    const hover = Math.abs(mouseX - dx) < 60 && Math.abs(mouseY - 665) < 20;
    const sel = difficulty === d;
    ctx.fillStyle = sel ? ({ NIGHTMARE: '#ef4444', HARD: '#f97316', EASY: '#22c55e', NORMAL: '#8b5cf6' }[d]) : hover ? '#444' : '#222';
    ctx.beginPath(); ctx.roundRect(dx - 60, 645, 120, 40, 8); ctx.fill();
    ctx.fillStyle = '#fff';
    ctx.font = sel ? 'bold 16px sans-serif' : '14px sans-serif';
    ctx.fillText(d, dx, 670);
  });
  
  // Continue button (only show if class selected)
  if (selectedClass) {
    const contHover = mouseX > 1000 && mouseX < 1180 && mouseY > 640 && mouseY < 690;
    ctx.fillStyle = contHover ? '#8b5cf6' : '#6366f1';
    ctx.beginPath(); ctx.roundRect(1000, 640, 180, 50, 10); ctx.fill();
    ctx.fillStyle = '#fff';
    ctx.font = 'bold 18px sans-serif';
    ctx.fillText('CONTINUE ‚Üí', 1090, 672);
  }
  
  // Back
  const backHover = mouseX < 100 && mouseY > 650;
  ctx.fillStyle = backHover ? '#444' : '#222';
  ctx.beginPath(); ctx.roundRect(20, 650, 80, 35, 8); ctx.fill();
  ctx.fillStyle = '#fff';
  ctx.font = '16px sans-serif';
  ctx.fillText('‚Üê BACK', 60, 673);
}

function renderDiffSelect() {
  ctx.fillStyle = '#0a0a20';
  ctx.fillRect(0, 0, 1200, 700);
  ctx.fillStyle = '#fff';
  ctx.font = 'bold 48px sans-serif';
  ctx.textAlign = 'center';
  ctx.fillText('SELECT DIFFICULTY', 600, 100);
  
  const diffs = Object.entries(CFG.DIFFICULTY);
  diffs.forEach(([key, cfg], i) => {
    const x = 150 + i * 250, y = 180;
    const hover = mouseX > x && mouseX < x + 200 && mouseY > y && mouseY < y + 350;
    const sel = difficulty === key;
    
    const colors = { EASY: '#22c55e', NORMAL: '#3b82f6', HARD: '#f97316', NIGHTMARE: '#ef4444' };
    ctx.fillStyle = sel ? colors[key] + '60' : hover ? '#2a2a4a' : '#1a1a3a';
    ctx.beginPath(); ctx.roundRect(x, y, 200, 350, 16); ctx.fill();
    ctx.strokeStyle = sel ? colors[key] : '#444';
    ctx.lineWidth = sel ? 4 : 2;
    ctx.beginPath(); ctx.roundRect(x, y, 200, 350, 16); ctx.stroke();
    
    ctx.fillStyle = colors[key];
    ctx.font = 'bold 28px sans-serif';
    ctx.fillText(key, x + 100, y + 50);
    
    ctx.fillStyle = '#888';
    ctx.font = '14px sans-serif';
    ctx.fillText(`Player HP: ${(cfg.playerHp * 100).toFixed(0)}%`, x + 100, y + 100);
    ctx.fillText(`Boss HP: ${(cfg.bossHp * 100).toFixed(0)}%`, x + 100, y + 130);
    ctx.fillText(`Boss DMG: ${(cfg.bossDmg * 100).toFixed(0)}%`, x + 100, y + 160);
    ctx.fillText(`Boss Speed: ${(cfg.bossSpeed * 100).toFixed(0)}%`, x + 100, y + 190);
  });
  
  // Continue button
  if (difficulty) {
    const contHover = mouseX > 500 && mouseX < 700 && mouseY > 580 && mouseY < 640;
    ctx.fillStyle = contHover ? '#8b5cf6' : '#6366f1';
    ctx.beginPath(); ctx.roundRect(500, 580, 200, 60, 12); ctx.fill();
    ctx.fillStyle = '#fff';
    ctx.font = 'bold 24px sans-serif';
    ctx.fillText('CONTINUE ‚Üí', 600, 618);
  }
  
  // Back button
  const backHover = mouseX < 100 && mouseY > 650;
  ctx.fillStyle = backHover ? '#444' : '#222';
  ctx.beginPath(); ctx.roundRect(20, 650, 80, 35, 8); ctx.fill();
  ctx.fillStyle = '#fff';
  ctx.font = '16px sans-serif';
  ctx.fillText('‚Üê BACK', 60, 673);
}

function renderBossSelect() {
  ctx.fillStyle = '#0a0a20';
  ctx.fillRect(0, 0, 1200, 700);
  ctx.fillStyle = '#fff';
  ctx.font = 'bold 48px sans-serif';
  ctx.textAlign = 'center';
  ctx.fillText('SELECT BOSS', 600, 60);
  
  Object.entries(BOSSES).forEach(([key, bossData], i) => {
    const x = 100 + i * 360, y = 120;
    const hover = mouseX > x && mouseX < x + 320 && mouseY > y && mouseY < y + 450;
    const sel = selectedBoss === key;
    
    ctx.fillStyle = hover ? bossData.color + '30' : '#1a1a3a';
    ctx.beginPath(); ctx.roundRect(x, y, 320, 450, 16); ctx.fill();
    ctx.strokeStyle = sel ? '#fbbf24' : bossData.color;
    ctx.lineWidth = sel ? 4 : 2;
    ctx.beginPath(); ctx.roundRect(x, y, 320, 450, 16); ctx.stroke();
    
    // Boss icon
    ctx.fillStyle = bossData.color;
    ctx.beginPath(); ctx.arc(x + 160, y + 100, 60, 0, Math.PI * 2); ctx.fill();
    ctx.fillStyle = '#fff';
    ctx.font = 'bold 50px sans-serif';
    const icons = { VOID_TITAN: 'üëÅÔ∏è', FLAME_WYRM: 'üêâ', FROST_QUEEN: 'üëë' };
    ctx.fillText(icons[key] || 'üëπ', x + 160, y + 115);
    
    ctx.fillStyle = bossData.color;
    ctx.font = 'bold 24px sans-serif';
    ctx.fillText(bossData.name, x + 160, y + 190);
    ctx.fillStyle = 'rgba(255,255,255,0.6)';
    ctx.font = '14px sans-serif';
    ctx.fillText(bossData.title, x + 160, y + 215);
    
    // Personality
    const personalities = {
      slow_tank: 'Slow but Devastating',
      aggressive_fast: 'Fast & Relentless',
      tactical_defensive: 'Tactical & Elegant'
    };
    ctx.fillStyle = bossData.color;
    ctx.font = 'bold 14px sans-serif';
    ctx.fillText(personalities[bossData.personality], x + 160, y + 245);
    
    // Stats
    ctx.fillStyle = '#888';
    ctx.font = '13px sans-serif';
    ctx.fillText(`HP: ${bossData.hp} | DMG: ${bossData.damage} | SPD: ${bossData.speed}`, x + 160, y + 280);
    ctx.fillText(`Phases: ${bossData.phases.length}`, x + 160, y + 300);
    
    // Unique attacks preview
    ctx.fillStyle = '#666';
    ctx.font = '12px sans-serif';
    const attackList = Object.keys(bossData.attacks).slice(0, 4).join(', ');
    ctx.fillText(`Attacks: ${attackList}...`, x + 160, y + 330);
    
    // Theme hint
    const themes = {
      VOID_TITAN: 'üåë Gravity & Darkness',
      FLAME_WYRM: 'üî• Fire & Speed',
      FROST_QUEEN: '‚ùÑÔ∏è Ice & Control'
    };
    ctx.fillStyle = bossData.secondColor;
    ctx.font = '16px sans-serif';
    ctx.fillText(themes[key], x + 160, y + 370);
    
    if (sel) {
      ctx.fillStyle = '#fbbf24';
      ctx.font = 'bold 16px sans-serif';
      ctx.fillText('SELECTED', x + 160, y + 420);
    }
  });
  
  // Start button
  const startHover = mouseX > 500 && mouseX < 700 && mouseY > 600 && mouseY < 660;
  ctx.fillStyle = startHover ? '#22c55e' : '#166534';
  ctx.beginPath(); ctx.roundRect(500, 600, 200, 60, 12); ctx.fill();
  ctx.fillStyle = '#fff';
  ctx.font = 'bold 28px sans-serif';
  ctx.fillText('FIGHT!', 600, 640);
  
  // Back
  const backHover = mouseX < 100 && mouseY > 650;
  ctx.fillStyle = backHover ? '#444' : '#222';
  ctx.beginPath(); ctx.roundRect(20, 650, 80, 35, 8); ctx.fill();
  ctx.fillStyle = '#fff';
  ctx.font = '16px sans-serif';
  ctx.fillText('‚Üê BACK', 60, 673);
}

// ============ INPUT ============
window.addEventListener('keydown', e => {
  const key = e.key.toLowerCase();
  keys[key] = true;
  initAudio();
  if (['arrowup', 'arrowdown', 'arrowleft', 'arrowright', ' '].includes(key)) e.preventDefault();
  
  // Knowledge challenge key handling (1-4 keys) - doesn't block movement
  if (KnowledgeSystem.active) {
    if (KnowledgeSystem.handleKey(key)) {
      e.preventDefault();
    }
  }
  
  // Quiz key handling - takes priority
  if (QuizSystem.active && !QuizSystem.answered) {
    if (QuizSystem.handleKey(key)) {
      e.preventDefault();
      return;
    }
  }
  
  if (key === 'escape' && state === 'game' && !game.victory && !game.gameOver && !QuizSystem.active) isPaused = !isPaused;
  if (key === 'enter') {
    if (game?.victory || game?.gameOver) { state = 'menu'; game = null; isPaused = false; }
  }
  if (key === 's' && game?.victory) {
    // Study Mode on victory screen
    if (typeof StudyMode !== 'undefined' && StudyMode.missedQuestions.length > 0) {
      StudyMode.start();
    }
  }
  if (key === 'r' && isPaused) { game = createGame(selectedClass, selectedBoss, difficulty); isPaused = false; }
  if (key === 'm' && (isPaused || game?.gameOver)) { state = 'menu'; game = null; isPaused = false; }
  
  // EMERGENCY FIX: Press 'F' when paused to fix stuck screen effects
  if (key === 'f' && isPaused && game) {
    screenFx.resetSlowmo();
    screenFx.shake = 0;
    screenFx.shakeX = 0;
    screenFx.shakeY = 0;
    screenFx.tintAlpha = 0;
    game.effects = [];
    game.dmgNums = [];
    if (particles) particles.list = [];
    clearAllTimeouts();
    console.log('Emergency fix applied - screen effects reset');
  }
  
  // ENHANCED: V key for tier attack
  if (key === 'v' && state === 'game' && game && !game.victory && !game.gameOver && !QuizSystem.active && !isPaused) {
    if (typeof TierSystem !== 'undefined' && game.player && game.boss) {
      TierSystem.vAttack(game.player, game.boss);
    }
  }
});
window.addEventListener('keyup', e => { keys[e.key.toLowerCase()] = false; });

canvas.addEventListener('mousemove', e => {
  const rect = canvas.getBoundingClientRect();
  mouseX = (e.clientX - rect.left) * (1200 / rect.width);
  mouseY = (e.clientY - rect.top) * (700 / rect.height);
});

// Touch support for menu screens
canvas.addEventListener('touchstart', e => {
  const rect = canvas.getBoundingClientRect();
  const touch = e.changedTouches[0];
  mouseX = (touch.clientX - rect.left) * (1200 / rect.width);
  mouseY = (touch.clientY - rect.top) * (700 / rect.height);
  
  // Tap to continue on victory/game over
  if (game && (game.victory || game.gameOver)) {
    // Wait a bit for the animation to complete
    if ((game.victory && game.victoryTimer > 180) || (game.gameOver && game.gameOverTimer > 120)) {
      // ENHANCED: Show battle review before returning to menu
      if (typeof TierSystem !== 'undefined' && !game.reviewShown) {
        game.reviewShown = true;
        TierSystem.showReview(game.victory);
        return; // Wait for review to be dismissed
      }
      state = 'menu';
      game = null;
      isPaused = false;
      if (typeof TierSystem !== 'undefined') TierSystem.reset();
    }
  }
  
  // Handle pause screen buttons
  if (isPaused) {
    // Restart button (350, 440, 200, 60)
    if (mouseX > 350 && mouseX < 550 && mouseY > 440 && mouseY < 500) {
      game = createGame(selectedClass, selectedBoss, difficulty);
      isPaused = false;
    }
    // Menu button (650, 440, 200, 60)
    if (mouseX > 650 && mouseX < 850 && mouseY > 440 && mouseY < 500) {
      state = 'menu';
      game = null;
      isPaused = false;
    }
  }
}, { passive: true });

canvas.addEventListener('touchend', e => {
  e.preventDefault(); // Important for iOS
  const rect = canvas.getBoundingClientRect();
  const touch = e.changedTouches[0];
  mouseX = (touch.clientX - rect.left) * (1200 / rect.width);
  mouseY = (touch.clientY - rect.top) * (700 / rect.height);
  
  // Quiz click handling
  if (QuizSystem.active && !QuizSystem.answered) {
    if (QuizSystem.handleClick(mouseX, mouseY)) {
      return;
    }
  }
  
  // Victory screen buttons
  if (state === 'game' && game && game.victory && game.victoryTimer > 210) {
    // Play Again button (left)
    if (mouseX > 200 && mouseX < 380 && mouseY > 540 && mouseY < 595) {
      if (typeof Haptics !== 'undefined') Haptics.medium();
      game = createGame(selectedClass, selectedBoss, difficulty);
      return;
    }
    // Study Mode button (middle)
    if (mouseX > 410 && mouseX < 590 && mouseY > 540 && mouseY < 595) {
      if (typeof Haptics !== 'undefined') Haptics.light();
      if (typeof StudyMode !== 'undefined' && StudyMode.missedQuestions.length > 0) {
        StudyMode.start();
      } else {
        spawnDmgNum(600, 300, 'No missed questions!', 'heal');
      }
      return;
    }
    // Menu button (right)
    if (mouseX > 620 && mouseX < 800 && mouseY > 540 && mouseY < 595) {
      if (typeof Haptics !== 'undefined') Haptics.light();
      state = 'menu';
      game = null;
      return;
    }
  }
  
  // Study Mode click handling
  if (typeof StudyMode !== 'undefined' && StudyMode.active) {
    if (StudyMode.handleClick(mouseX, mouseY)) {
      return;
    }
  }
  
  // Game Over screen buttons
  if (state === 'game' && game && game.gameOver && game.gameOverTimer > 150) {
    // Try Again button (left)
    if (mouseX > 350 && mouseX < 550 && mouseY > 440 && mouseY < 495) {
      Haptics.medium();
      game = createGame(selectedClass, selectedBoss, difficulty);
      return;
    }
    // Menu button (right)
    if (mouseX > 650 && mouseX < 850 && mouseY > 440 && mouseY < 495) {
      Haptics.light();
      state = 'menu';
      game = null;
      return;
    }
  }
  
  // Pause screen buttons
  if (state === 'game' && isPaused) {
    // Restart button
    if (mouseX > 350 && mouseX < 550 && mouseY > 440 && mouseY < 500) {
      Haptics.medium();
      isPaused = false;
      game = createGame(selectedClass, selectedBoss, difficulty);
      return;
    }
    // Menu button
    if (mouseX > 650 && mouseX < 850 && mouseY > 440 && mouseY < 500) {
      Haptics.light();
      isPaused = false;
      state = 'menu';
      game = null;
      return;
    }
  }
  
  if (state === 'game' && !QuizSystem.active) return; // Let touch controls handle gameplay
  
  // Trigger the same logic as click
  handleMenuClick();
}, { passive: false });

canvas.addEventListener('click', () => {
  // Quiz click handling
  if (QuizSystem.active && !QuizSystem.answered) {
    if (QuizSystem.handleClick(mouseX, mouseY)) {
      return;
    }
  }
  handleMenuClick();
});

function handleMenuClick() {
  initAudio();
  playSound('menu');
  
  if (state === 'menu') {
    if (mouseY > 320 && mouseY < 380 && mouseX > 400 && mouseX < 800) state = 'charSelect';
    if (mouseY > 390 && mouseY < 450 && mouseX > 400 && mouseX < 800) {
      const isMobile = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);
      if (isMobile) {
        alert('TOUCH CONTROLS:\n\n‚¨ÖÔ∏è Left side: Virtual Joystick\n‚û°Ô∏è Right side buttons:\n  ‚öîÔ∏è Attack\n  üéØ Ranged\n  ‚ú® Special\n  ‚¨ÜÔ∏è Jump\n  üí® Dash\n  üí• Ultimate\n  üõ°Ô∏è Parry\n\nBOSS TIPS:\n‚Ä¢ VOID TITAN: Slow but devastating\n‚Ä¢ FLAME WYRM: Fast & aggressive\n‚Ä¢ FROST QUEEN: Tactical & elegant');
      } else {
        alert('CONTROLS:\nWASD/Arrows: Move\nSPACE/W: Jump (triple jump)\nSHIFT/L: Dash (invincible)\nQ/U: Parry\nZ/J: Melee\nX/K: Ranged\nC/I: Special\nV/O: Ultimate');
      }
    }
  }
  else if (state === 'charSelect') {
    Object.keys(CLASSES).forEach((key, i) => {
      const x = 150 + i * 350;
      if (mouseX > x && mouseX < x + 300 && mouseY > 150 && mouseY < 550) {
        selectedClass = key;
      }
    });
    
    // Subject filter buttons
    if (typeof SubjectFilter !== 'undefined') {
      SubjectFilter.standards.forEach((std, i) => {
        const sx = 280 + i * 220;
        const sy = 580;
        if (mouseX > sx - 100 && mouseX < sx + 100 && mouseY > sy - 15 && mouseY < sy + 15) {
          SubjectFilter.toggle(std.id);
          playSound('menu');
        }
      });
    }
    
    // Difficulty selection (moved down)
    ['EASY', 'NORMAL', 'HARD', 'NIGHTMARE'].forEach((d, i) => {
      const dx = 300 + i * 150;
      if (Math.abs(mouseX - dx) < 60 && Math.abs(mouseY - 665) < 20) difficulty = d;
    });
    
    // Continue to boss select if class is selected (moved to right)
    if (selectedClass && mouseX > 1000 && mouseX < 1180 && mouseY > 640 && mouseY < 690) {
      state = 'bossSelect';
    }
    if (mouseX < 100 && mouseY > 650) state = 'menu';
  }
  else if (state === 'diffSelect') {
    // Difficulty selection
    const diffs = Object.keys(CFG.DIFFICULTY);
    diffs.forEach((key, i) => {
      const x = 150 + i * 250;
      if (mouseX > x && mouseX < x + 200 && mouseY > 180 && mouseY < 530) {
        difficulty = key;
      }
    });
    // Continue button
    if (difficulty && mouseX > 500 && mouseX < 700 && mouseY > 580 && mouseY < 640) {
      state = 'bossSelect';
    }
    // Back button
    if (mouseX < 100 && mouseY > 650) state = 'charSelect';
  }
  else if (state === 'bossSelect') {
    Object.keys(BOSSES).forEach((key, i) => {
      const x = 100 + i * 360;
      if (mouseX > x && mouseX < x + 320 && mouseY > 120 && mouseY < 570) selectedBoss = key;
    });
    if (selectedBoss && mouseX > 500 && mouseX < 700 && mouseY > 600 && mouseY < 660) {
      game = createGame(selectedClass, selectedBoss, difficulty);
      state = 'game';
    }
    if (mouseX < 100 && mouseY > 650) state = 'charSelect';
  }
}

// ============ RESIZE & LOOP ============
function resize() {
  const vw = window.innerWidth || document.documentElement.clientWidth;
  const vh = window.innerHeight || document.documentElement.clientHeight;
  const isMobile = vw <= 1024 || ('ontouchstart' in window);
  const isPortrait = vh > vw;
  
  let scale, displayWidth, displayHeight, offsetX, offsetY;
  
  if (isMobile && isPortrait) {
    // PORTRAIT: Fill width, position game at top
    scale = vw / BASE_WIDTH;
    displayWidth = Math.floor(vw);
    displayHeight = Math.floor(BASE_HEIGHT * scale);
    offsetX = 0;
    // Put game at top, leave bottom 40% for controls
    offsetY = 0;
  } else if (isMobile && !isPortrait) {
    // LANDSCAPE: Fill as much as possible
    const scaleX = vw / BASE_WIDTH;
    const scaleY = vh / BASE_HEIGHT;
    scale = Math.min(scaleX, scaleY * 0.95); // Leave tiny margin
    displayWidth = Math.floor(BASE_WIDTH * scale);
    displayHeight = Math.floor(BASE_HEIGHT * scale);
    offsetX = Math.floor((vw - displayWidth) / 2);
    offsetY = Math.floor((vh - displayHeight) / 2);
  } else {
    // DESKTOP: Standard letterbox
    const scaleX = vw / BASE_WIDTH;
    const scaleY = vh / BASE_HEIGHT;
    scale = Math.min(scaleX, scaleY);
    displayWidth = Math.floor(BASE_WIDTH * scale);
    displayHeight = Math.floor(BASE_HEIGHT * scale);
    offsetX = Math.floor((vw - displayWidth) / 2);
    offsetY = Math.floor((vh - displayHeight) / 2);
  }
  
  canvas.style.width = displayWidth + 'px';
  canvas.style.height = displayHeight + 'px';
  canvas.style.left = offsetX + 'px';
  canvas.style.top = offsetY + 'px';
  
  window.gameScale = scale;
  window.gameOffsetX = offsetX;
  window.gameOffsetY = offsetY;
}

let resizeTimeout;
function debouncedResize() {
  clearTimeout(resizeTimeout);
  resizeTimeout = setTimeout(resize, 50);
}

resize();
window.addEventListener('resize', debouncedResize);
window.addEventListener('orientationchange', () => setTimeout(resize, 100));

// ============ MAIN GAME LOOP ============
let loopId = null;
let isLoopRunning = false;
let lastFrameTime = 0;
const TARGET_FPS = 60;
const FRAME_TIME = 1000 / TARGET_FPS;

function loop(timestamp) {
  // Frame rate limiting for consistent performance
  const elapsed = timestamp - lastFrameTime;
  
  // Skip if not enough time passed (helps on high refresh rate screens)
  if (elapsed < FRAME_TIME * 0.8) {
    loopId = requestAnimationFrame(loop);
    return;
  }
  
  // FREEZE DETECTION: If more than 2 seconds between frames, force reset
  if (lastFrameTime > 0 && elapsed > 2000) {
    console.warn('Freeze detected, recovering...');
    if (game) {
      game.effects = [];
      game.dmgNums = [];
      game.projectiles = [];
      screenFx.resetSlowmo();
      screenFx.shake = 0;
      PhaseManager.reset();
      if (QuizSystem.active) {
        QuizSystem.active = false;
        QuizSystem.showResult = false;
      }
    }
  }
  lastFrameTime = timestamp;
  
  try {
    update();
  } catch (e) {
    console.error('UPDATE ERROR:', e);
  }
  
  try {
    render();
  } catch (e) {
    console.error('RENDER ERROR:', e);
  }
  
  loopId = requestAnimationFrame(loop);
}

function startLoop() {
  if (isLoopRunning) return;
  isLoopRunning = true;
  loopId = requestAnimationFrame(loop);
}

function stopLoop() {
  if (loopId) {
    cancelAnimationFrame(loopId);
    loopId = null;
  }
  isLoopRunning = false;
}

// Handle tab visibility - pause when hidden
document.addEventListener('visibilitychange', () => {
  if (document.hidden) {
    stopLoop();
  } else {
    startLoop();
  }
});

// Start the game loop
startLoop();

// ============ MOBILE TOUCH CONTROLS ============
const TouchControls = {
  isMobile: false,
  joystick: { active: false, startX: 0, startY: 0, currentX: 0, currentY: 0, id: null, maxDist: 45 },
  buttons: { jumpHeld: false },
  
  // === GESTURE CONTROLS ===
  gestureMode: false,        // Enable gesture controls
  swipeThreshold: 50,        // Min distance for swipe
  swipeStart: { x: 0, y: 0, time: 0, id: null },
  lastSwipeTime: 0,
  
  // === BATTERY SAVER ===
  batterySaver: false,       // 30fps mode
  
  // === AUTO-ATTACK MODE ===
  autoAttack: false,         // Auto-attack for younger players
  
  init() {
    // Detect mobile/tablet
    this.isMobile = ('ontouchstart' in window) || 
                    (navigator.maxTouchPoints > 0) || 
                    /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) ||
                    (window.innerWidth <= 1024);
    
    if (!this.isMobile) return;
    
    // Load preferences
    try {
      this.gestureMode = localStorage.getItem('civitas_gestures') === 'true';
      this.batterySaver = localStorage.getItem('civitas_battery') === 'true';
      this.autoAttack = localStorage.getItem('civitas_autoattack') === 'true';
    } catch(e) {}
    
    // Apply battery saver
    if (this.batterySaver) {
      TARGET_FPS = 30;
    }
    
    // Prevent default touch behaviors
    document.body.addEventListener('touchmove', e => {
      if (e.target.closest('#session-overlay')) return;
      if (e.target.closest('.s-card')) return;
      if (e.target.closest('.s-grid')) return;
      if (e.target.closest('.rev-panel')) return;
      e.preventDefault();
    }, { passive: false });
    
    // Prevent double-tap zoom
    let lastTap = 0;
    document.body.addEventListener('touchend', e => {
      const now = Date.now();
      if (now - lastTap < 300) {
        e.preventDefault();
      }
      lastTap = now;
    }, { passive: false });
    
    this.setupJoystick();
    this.setupButtons();
    this.setupMenuTouch();
    this.setupGestures();
    
    console.log('Touch controls initialized for mobile');
  },
  
  // === GESTURE CONTROLS SETUP ===
  setupGestures() {
    if (!this.gestureMode) return;
    
    const zone = document.getElementById('joystick-zone');
    if (!zone) return;
    
    zone.addEventListener('touchstart', (e) => {
      const touch = e.changedTouches[0];
      this.swipeStart = {
        x: touch.clientX,
        y: touch.clientY,
        time: Date.now(),
        id: touch.identifier
      };
    }, { passive: true });
    
    zone.addEventListener('touchend', (e) => {
      const now = Date.now();
      if (now - this.lastSwipeTime < 200) return; // Cooldown
      
      for (let touch of e.changedTouches) {
        if (touch.identifier === this.swipeStart.id) {
          const dx = touch.clientX - this.swipeStart.x;
          const dy = touch.clientY - this.swipeStart.y;
          const dt = now - this.swipeStart.time;
          const dist = Math.sqrt(dx*dx + dy*dy);
          
          // Must be fast swipe
          if (dt < 300 && dist > this.swipeThreshold) {
            const angle = Math.atan2(dy, dx);
            
            // Swipe up = jump
            if (angle < -Math.PI * 0.25 && angle > -Math.PI * 0.75) {
              keys[' '] = true;
              keys['w'] = true;
              setTimeout(() => { keys[' '] = false; keys['w'] = false; }, 100);
              this.lastSwipeTime = now;
              if (typeof Haptics !== 'undefined') Haptics.light();
            }
            // Swipe right = dash right
            else if (Math.abs(angle) < Math.PI * 0.25) {
              if (game && game.player) game.player.facing = 1;
              keys['shift'] = true;
              setTimeout(() => { keys['shift'] = false; }, 100);
              this.lastSwipeTime = now;
              if (typeof Haptics !== 'undefined') Haptics.medium();
            }
            // Swipe left = dash left
            else if (Math.abs(angle) > Math.PI * 0.75) {
              if (game && game.player) game.player.facing = -1;
              keys['shift'] = true;
              setTimeout(() => { keys['shift'] = false; }, 100);
              this.lastSwipeTime = now;
              if (typeof Haptics !== 'undefined') Haptics.medium();
            }
            // Swipe down = parry
            else if (angle > Math.PI * 0.25 && angle < Math.PI * 0.75) {
              keys['q'] = true;
              setTimeout(() => { keys['q'] = false; }, 100);
              this.lastSwipeTime = now;
              if (typeof Haptics !== 'undefined') Haptics.light();
            }
          }
        }
      }
    }, { passive: true });
  },
  
  // === TOGGLE SETTINGS ===
  toggleGestures() {
    this.gestureMode = !this.gestureMode;
    try { localStorage.setItem('civitas_gestures', this.gestureMode ? 'true' : 'false'); } catch(e) {}
    if (this.gestureMode) this.setupGestures();
    return this.gestureMode;
  },
  
  toggleBatterySaver() {
    this.batterySaver = !this.batterySaver;
    try { localStorage.setItem('civitas_battery', this.batterySaver ? 'true' : 'false'); } catch(e) {}
    // Note: Requires restart to take effect
    return this.batterySaver;
  },
  
  toggleAutoAttack() {
    this.autoAttack = !this.autoAttack;
    try { localStorage.setItem('civitas_autoattack', this.autoAttack ? 'true' : 'false'); } catch(e) {}
    return this.autoAttack;
  },
  
  setupJoystick() {
    const zone = document.getElementById('joystick-zone');
    const base = document.getElementById('joystick-base');
    const thumb = document.getElementById('joystick-thumb');
    if (!zone || !base || !thumb) return;
    
    // Calculate max distance based on joystick size
    const getMaxDist = () => {
      const baseSize = base.offsetWidth || 120;
      const thumbSize = thumb.offsetWidth || 50;
      return (baseSize - thumbSize) / 2;
    };
    
    zone.addEventListener('touchstart', (e) => {
      if (this.joystick.active) return;
      const touch = e.changedTouches[0];
      this.joystick.active = true;
      this.joystick.id = touch.identifier;
      this.joystick.startX = touch.clientX;
      this.joystick.startY = touch.clientY;
      this.joystick.currentX = 0;
      this.joystick.currentY = 0;
      this.joystick.maxDist = getMaxDist();
      
      // Move base to touch position (floating joystick)
      const rect = zone.getBoundingClientRect();
      const halfBase = (base.offsetWidth || 120) / 2;
      const newLeft = Math.max(10, Math.min(touch.clientX - rect.left - halfBase, rect.width - halfBase * 2 - 10));
      const newBottom = Math.max(10, Math.min(rect.bottom - touch.clientY - halfBase, rect.height - halfBase * 2 - 10));
      base.style.left = newLeft + 'px';
      base.style.bottom = newBottom + 'px';
      
      // Haptic feedback
      if (navigator.vibrate) navigator.vibrate(5);
    }, { passive: true });
    
    zone.addEventListener('touchmove', (e) => {
      if (!this.joystick.active) return;
      const maxDist = this.joystick.maxDist || 45;
      
      for (let touch of e.changedTouches) {
        if (touch.identifier === this.joystick.id) {
          let dx = touch.clientX - this.joystick.startX;
          let dy = touch.clientY - this.joystick.startY;
          const dist = Math.sqrt(dx*dx + dy*dy);
          
          if (dist > maxDist) {
            dx = dx / dist * maxDist;
            dy = dy / dist * maxDist;
          }
          
          this.joystick.currentX = dx / maxDist; // -1 to 1
          this.joystick.currentY = dy / maxDist; // -1 to 1
          
          // Use transform for GPU acceleration
          thumb.style.transform = `translate3d(${dx}px, ${dy}px, 0)`;
          this.updateMovementKeys();
        }
      }
    }, { passive: true });
    
    const endJoystick = (e) => {
      for (let touch of e.changedTouches) {
        if (touch.identifier === this.joystick.id) {
          this.joystick.active = false;
          this.joystick.currentX = 0;
          this.joystick.currentY = 0;
          thumb.style.transform = 'translate3d(0, 0, 0)';
          this.updateMovementKeys();
          
          // Reset base position
          base.style.left = '';
          base.style.bottom = '';
        }
      }
    };
    
    zone.addEventListener('touchend', endJoystick, { passive: true });
    zone.addEventListener('touchcancel', endJoystick, { passive: true });
  },
  
  updateMovementKeys() {
    const deadzone = 0.25;
    const x = this.joystick.currentX;
    const y = this.joystick.currentY;
    
    // Horizontal
    keys['a'] = x < -deadzone;
    keys['arrowleft'] = x < -deadzone;
    keys['d'] = x > deadzone;
    keys['arrowright'] = x > deadzone;
    
    // Vertical (up = jump) - only if not in gesture mode
    if (!this.gestureMode) {
      if (y < -0.5 && !this.buttons.jumpHeld) {
        keys[' '] = true;
        keys['w'] = true;
        this.buttons.jumpHeld = true;
      } else if (y >= -0.3) {
        this.buttons.jumpHeld = false;
        keys[' '] = false;
        keys['w'] = false;
      }
    }
    
    // === AUTO-ATTACK ===
    if (this.autoAttack && game && game.boss && state === 'game') {
      const p = game.player;
      const b = game.boss;
      const dist = Math.abs(p.x - b.x);
      
      // Auto attack when in range
      if (dist < 200 && p.attackTimer <= 0 && b.invuln <= 0) {
        keys['z'] = true;
        setTimeout(() => { keys['z'] = false; }, 50);
      }
      
      // Auto dodge when boss is attacking
      if (b.state && b.state.includes('attack') && b.stateTimer > 20 && b.stateTimer < 40) {
        if (p.dashCD <= 0) {
          keys['shift'] = true;
          setTimeout(() => { keys['shift'] = false; }, 50);
        }
      }
    }
  },
  
  setupButtons() {
    const btnMap = {
      'btn-attack': ['z', 'j'],      // Melee
      'btn-ranged': ['x', 'k'],      // Ranged
      'btn-special': ['c', 'i'],     // Special
      'btn-jump': [' ', 'w'],        // Jump
      'btn-dash': ['shift', 'l'],    // Dash
      'btn-ultimate': ['v', 'o'],    // Ultimate
      'btn-parry': ['q', 'u']        // Parry
    };
    
    Object.entries(btnMap).forEach(([id, keyList]) => {
      const btn = document.getElementById(id);
      if (!btn) return;
      
      btn.addEventListener('touchstart', (e) => {
        e.preventDefault();
        btn.classList.add('pressed');
        keyList.forEach(k => keys[k] = true);
        
        // Haptic feedback
        if (navigator.vibrate) navigator.vibrate(10);
      }, { passive: false });
      
      btn.addEventListener('touchend', (e) => {
        e.preventDefault();
        btn.classList.remove('pressed');
        keyList.forEach(k => keys[k] = false);
      }, { passive: false });
      
      btn.addEventListener('touchcancel', (e) => {
        btn.classList.remove('pressed');
        keyList.forEach(k => keys[k] = false);
      }, { passive: true });
    });
    
    // Pause button
    const pauseBtn = document.getElementById('btn-pause');
    if (pauseBtn) {
      pauseBtn.addEventListener('touchstart', (e) => {
        e.preventDefault();
        if (state === 'game' && game && !game.victory && !game.gameOver) {
          isPaused = !isPaused;
          if (navigator.vibrate) navigator.vibrate(20);
        }
      }, { passive: false });
    }
  },
  
  setupMenuTouch() {
    // Handle canvas touches for menu navigation
    canvas.addEventListener('touchstart', (e) => {
      if (state !== 'menu' && state !== 'charSelect' && state !== 'diffSelect' && state !== 'bossSelect') return;
      
      const rect = canvas.getBoundingClientRect();
      const scaleX = 1200 / rect.width;
      const scaleY = 700 / rect.height;
      
      for (let touch of e.changedTouches) {
        const x = (touch.clientX - rect.left) * scaleX;
        const y = (touch.clientY - rect.top) * scaleY;
        
        // Simulate mouse position and click
        mouseX = x;
        mouseY = y;
        
        // Trigger click handler
        this.handleMenuTouch(x, y);
      }
    }, { passive: true });
  },
  
  handleMenuTouch(x, y) {
    // Main menu
    if (state === 'menu') {
      // Start button area
      if (x > 400 && x < 800 && y > 550 && y < 650) {
        state = 'charSelect';
        playSound('menu');
      }
    }
    
    // Character select
    else if (state === 'charSelect') {
      Object.keys(CLASSES).forEach((key, i) => {
        const cx = 100 + i * 360;
        if (x > cx && x < cx + 320 && y > 120 && y < 500) {
          selectedClass = key;
          playSound('menu');
        }
      });
      // Continue button
      if (x > 500 && x < 700 && y > 600 && y < 660 && selectedClass) {
        state = 'diffSelect';
        playSound('menu');
      }
      // Back
      if (x < 120 && y > 640) {
        state = 'menu';
        playSound('menu');
      }
    }
    
    // Difficulty select
    else if (state === 'diffSelect') {
      const diffs = Object.keys(CFG.DIFFICULTY);
      diffs.forEach((key, i) => {
        const dx = 200 + i * 220;
        if (x > dx && x < dx + 180 && y > 200 && y < 420) {
          difficulty = key;
          playSound('menu');
        }
      });
      // Continue
      if (x > 500 && x < 700 && y > 600 && y < 660 && difficulty) {
        state = 'bossSelect';
        playSound('menu');
      }
      // Back
      if (x < 120 && y > 640) {
        state = 'charSelect';
        playSound('menu');
      }
    }
    
    // Boss select
    else if (state === 'bossSelect') {
      Object.keys(BOSSES).forEach((key, i) => {
        const bx = 100 + i * 360;
        if (x > bx && x < bx + 320 && y > 120 && y < 570) {
          selectedBoss = key;
          playSound('menu');
        }
      });
      // Start
      if (x > 500 && x < 700 && y > 600 && y < 660 && selectedBoss) {
        game = createGame(selectedClass, selectedBoss, difficulty);
        state = 'game';
        playSound('menu');
      }
      // Back
      if (x < 120 && y > 640) {
        state = 'diffSelect';
        playSound('menu');
      }
    }
  },
  
  show() {
    const el = document.getElementById('touch-controls');
    if (el && this.isMobile) {
      el.classList.add('active');
      document.body.classList.add('game-active');
    }
  },
  
  hide() {
    const el = document.getElementById('touch-controls');
    if (el) {
      el.classList.remove('active');
      document.body.classList.remove('game-active');
    }
  },
  
  updateUltButton() {
    if (!this.isMobile) return;
    const btn = document.getElementById('btn-ultimate');
    if (!btn || !game) return;
    
    const ready = game.player && game.player.ultCharge >= 100 && game.player.mana >= 55;
    btn.classList.toggle('ready', ready);
  }
};

// ============ LOADING SCREEN ============
const LoadingScreen = {
  hide() {
    const el = document.getElementById('loading-screen');
    if (el) {
      el.classList.add('hidden');
      // Remove from DOM after transition
      setTimeout(() => el.remove(), 600);
    }
  }
};

// ============ TUTORIAL SYSTEM ============
const Tutorial = {
  shown: false,
  
  init() {
    const isMobile = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);
    if (!isMobile) return;
    
    // Check if already seen
    try {
      this.shown = localStorage.getItem('civitas_tutorial_seen') === 'true';
    } catch(e) {}
    
    const startBtn = document.getElementById('tutorial-start');
    const skipBtn = document.getElementById('tutorial-skip');
    
    if (startBtn) {
      startBtn.addEventListener('click', () => this.close());
      startBtn.addEventListener('touchend', (e) => { e.preventDefault(); this.close(); });
    }
    if (skipBtn) {
      skipBtn.addEventListener('click', () => this.closeAndRemember());
      skipBtn.addEventListener('touchend', (e) => { e.preventDefault(); this.closeAndRemember(); });
    }
  },
  
  show() {
    if (this.shown) return;
    const el = document.getElementById('tutorial-overlay');
    if (el) el.classList.add('show');
  },
  
  close() {
    const el = document.getElementById('tutorial-overlay');
    if (el) el.classList.remove('show');
  },
  
  closeAndRemember() {
    this.close();
    this.shown = true;
    try {
      localStorage.setItem('civitas_tutorial_seen', 'true');
    } catch(e) {}
  }
};

// ============ SOUND SYSTEM ============
const SoundManager = {
  muted: false,
  
  init() {
    const btn = document.getElementById('btn-sound');
    if (!btn) return;
    
    // Load saved preference
    try {
      this.muted = localStorage.getItem('civitas_muted') === 'true';
      this.updateButton();
    } catch(e) {}
    
    btn.addEventListener('touchstart', (e) => {
      e.preventDefault();
      this.toggle();
    }, { passive: false });
    
    btn.addEventListener('click', () => this.toggle());
  },
  
  toggle() {
    this.muted = !this.muted;
    this.updateButton();
    
    // Haptic feedback
    if (navigator.vibrate) navigator.vibrate(10);
    
    try {
      localStorage.setItem('civitas_muted', this.muted ? 'true' : 'false');
    } catch(e) {}
  },
  
  updateButton() {
    const btn = document.getElementById('btn-sound');
    if (!btn) return;
    btn.classList.toggle('muted', this.muted);
    btn.querySelector('span').textContent = this.muted ? 'üîá' : 'üîä';
  },
  
  canPlay() {
    return !this.muted;
  }
};

// ============ HAPTIC FEEDBACK ============
const Haptics = {
  light() {
    if (navigator.vibrate) navigator.vibrate(5);
  },
  medium() {
    if (navigator.vibrate) navigator.vibrate(15);
  },
  heavy() {
    if (navigator.vibrate) navigator.vibrate([20, 30, 20]);
  },
  success() {
    if (navigator.vibrate) navigator.vibrate([10, 50, 10, 50, 30]);
  },
  error() {
    if (navigator.vibrate) navigator.vibrate([50, 30, 50]);
  }
};

// ============ MOBILE SETTINGS ============
const MobileSettings = {
  visible: false,
  
  init() {
    const settingsBtn = document.getElementById('btn-settings');
    const closeBtn = document.getElementById('close-settings');
    const overlay = document.getElementById('mobile-settings');
    
    if (settingsBtn) {
      settingsBtn.addEventListener('touchstart', (e) => {
        e.preventDefault();
        this.show();
      }, { passive: false });
      settingsBtn.addEventListener('click', () => this.show());
    }
    
    if (closeBtn) {
      closeBtn.addEventListener('touchstart', (e) => {
        e.preventDefault();
        this.hide();
      }, { passive: false });
      closeBtn.addEventListener('click', () => this.hide());
    }
    
    // Toggle handlers
    const gestureItem = document.getElementById('setting-gesture');
    const autoItem = document.getElementById('setting-autoattack');
    const batteryItem = document.getElementById('setting-battery');
    
    if (gestureItem) {
      gestureItem.addEventListener('touchstart', (e) => {
        e.preventDefault();
        this.toggleGesture();
      }, { passive: false });
      gestureItem.addEventListener('click', () => this.toggleGesture());
    }
    
    if (autoItem) {
      autoItem.addEventListener('touchstart', (e) => {
        e.preventDefault();
        this.toggleAutoAttack();
      }, { passive: false });
      autoItem.addEventListener('click', () => this.toggleAutoAttack());
    }
    
    if (batteryItem) {
      batteryItem.addEventListener('touchstart', (e) => {
        e.preventDefault();
        this.toggleBattery();
      }, { passive: false });
      batteryItem.addEventListener('click', () => this.toggleBattery());
    }
    
    // Update initial states
    this.updateUI();
  },
  
  show() {
    const overlay = document.getElementById('mobile-settings');
    if (overlay) {
      overlay.classList.add('show');
      this.visible = true;
      this.updateUI();
    }
    Haptics.light();
  },
  
  hide() {
    const overlay = document.getElementById('mobile-settings');
    if (overlay) {
      overlay.classList.remove('show');
      this.visible = false;
    }
    Haptics.light();
  },
  
  toggleGesture() {
    if (typeof TouchControls !== 'undefined') {
      TouchControls.toggleGestures();
      this.updateUI();
      Haptics.medium();
    }
  },
  
  toggleAutoAttack() {
    if (typeof TouchControls !== 'undefined') {
      TouchControls.toggleAutoAttack();
      this.updateUI();
      Haptics.medium();
    }
  },
  
  toggleBattery() {
    if (typeof TouchControls !== 'undefined') {
      TouchControls.toggleBatterySaver();
      this.updateUI();
      Haptics.medium();
      // Note: Battery saver requires restart
      alert('Battery saver mode will take effect on next game restart.');
    }
  },
  
  updateUI() {
    const gestureItem = document.getElementById('setting-gesture');
    const autoItem = document.getElementById('setting-autoattack');
    const batteryItem = document.getElementById('setting-battery');
    
    if (typeof TouchControls !== 'undefined') {
      if (gestureItem) {
        gestureItem.classList.toggle('active', TouchControls.gestureMode);
        gestureItem.querySelector('.setting-toggle').textContent = TouchControls.gestureMode ? 'ON' : 'OFF';
      }
      if (autoItem) {
        autoItem.classList.toggle('active', TouchControls.autoAttack);
        autoItem.querySelector('.setting-toggle').textContent = TouchControls.autoAttack ? 'ON' : 'OFF';
      }
      if (batteryItem) {
        batteryItem.classList.toggle('active', TouchControls.batterySaver);
        batteryItem.querySelector('.setting-toggle').textContent = TouchControls.batterySaver ? 'ON' : 'OFF';
      }
    }
  }
};

// ============ CONNECTION STATUS ============
const ConnectionUI = {
  el: null,
  textEl: null,
  
  init() {
    this.el = document.getElementById('connection-status');
    this.textEl = document.getElementById('connection-text');
  },
  
  show(status, text) {
    if (!this.el || !this.textEl) return;
    this.el.className = 'show ' + status;
    this.textEl.textContent = text;
  },
  
  hide() {
    if (this.el) this.el.classList.remove('show');
  },
  
  connected() {
    this.show('connected', 'Connected');
    setTimeout(() => this.hide(), 2000);
  },
  
  connecting() {
    this.show('connecting', 'Connecting...');
  },
  
  error(msg) {
    this.show('error', msg || 'Connection lost');
  }
};

// Initialize touch controls
document.addEventListener('DOMContentLoaded', () => {
  // Hide loading screen after short delay
  setTimeout(() => LoadingScreen.hide(), 800);
  
  // Initialize systems
  Tutorial.init();
  SoundManager.init();
  MobileSettings.init();
  ConnectionUI.init();
  TouchControls.init();
  
  // Re-check mobile on resize/orientation change
  const checkMobile = () => {
    const wasMobile = TouchControls.isMobile;
    TouchControls.isMobile = ('ontouchstart' in window) || 
                              (navigator.maxTouchPoints > 0) ||
                              /Android|iPhone|iPad|iPod/i.test(navigator.userAgent);
    
    // Re-init if changed to mobile
    if (!wasMobile && TouchControls.isMobile) {
      TouchControls.init();
    }
  };
  
  window.addEventListener('resize', checkMobile);
  window.addEventListener('orientationchange', checkMobile);
});

// Show/hide touch controls based on game state
const originalUpdate = update;
update = function() {
  originalUpdate();
  
  // Show touch controls during gameplay
  if (state === 'game' && game && !game.victory && !game.gameOver) {
    TouchControls.show();
    TouchControls.updateUltButton();
  } else {
    TouchControls.hide();
  }
};

// CLEANUP on page unload - flush any pending Firebase data
window.addEventListener('beforeunload', () => {
  if (typeof SES !== 'undefined' && SES.code && SES.studentId) {
    // Attempt to flush pending data
    const report = typeof QuizSystem !== 'undefined' ? QuizSystem.getReport() : null;
    SES.submitResults(report);
  }
});

// Also cleanup on visibility change (mobile tab switching)
document.addEventListener('visibilitychange', () => {
  if (document.hidden && typeof SES !== 'undefined' && SES.code && SES.studentId) {
    const report = typeof QuizSystem !== 'undefined' ? QuizSystem.getReport() : null;
    SES.submitResults(report);
  }
});
</script>
</body>
</html>
